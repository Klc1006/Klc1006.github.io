{"meta":{"title":null,"subtitle":"","description":"","author":"Klc","url":"https://Klc1006.github.io","root":"/"},"pages":[],"posts":[{"title":"面向对象编程 OOP（cpp语言篇）","slug":"cpp","date":"2023-03-06T17:25:59.594Z","updated":"2023-03-06T17:25:26.412Z","comments":true,"path":"2023/03/07/cpp/","link":"","permalink":"https://klc1006.github.io/2023/03/07/cpp/","excerpt":"","text":"引言 面向过程设计 导致程序结构不灵活。若高层算法需要修改，那么可能 底层的算法也因此需要修改。 导致代码难以复用 面向对象设计 class是保留字，说明DATE是类名。在{}中列出类的成员。 类的成员包括： 数据成员：一般说来，数据成员是需要隐藏的对象；即外部的程序是不 能直接访问这些数据的，应该通过函数成员来访问这些数据。所以一般 情况下，数据成员通过关键字private声明为私有成员（private member ） 函数成员：通过关键字public声明为公有成员（public member）。外部 程序可以访问共有成员，但无法访问私有成员。 对于类的使用者（即用户代码，简称用户）而言，只需要获得DATE.h ，即可调用类对象的公有函数访问其内部的数据成员。使用者无法直接 访问私有成员，也无需知晓公有函数的内部实现。 UML Coding 123456789101112131415class DATE // DATE.h----Specification file of class DATE&#123; public: void Set( int, int, int ); int getMonth() const; int getDay() const; int getYear() const; void Print() const; void Increment(); void Decrement(); private: int month; int day; int year;&#125;; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192//DATE.cpp //the implementation of each member function of DATE.#include &quot;DATE.h&quot;#include &lt;iostream&gt;using namespace std;int DaysInMonth( int, int ); void DATE::Set(int newYear, int newMonth,int newDay )&#123; month = newMonth; day = newDay; year = newYear; &#125;int DATE::getMonth() const&#123; return month;&#125;int DATE::getDay() const&#123; return day;&#125;int DATE::getYear() const&#123;return year;&#125;void DATE::Print() const&#123; switch (month) &#123; case 1 : cout &lt;&lt; &quot;January&quot;; break; case 2 : cout &lt;&lt; &quot;February&quot;; break; case 12 : cout &lt;&lt; &quot;December&quot;; &#125; cout &lt;&lt; &#x27; &#x27; &lt;&lt; day &lt;&lt; &quot;, &quot; &lt;&lt; year &lt;&lt; endl &lt;&lt; endl;&#125;void DATE::Increment()&#123; day++; if (day &gt; DaysInMonth(month, year)) &#123; day = 1; month++; if (month &gt; 12) &#123; month = 1; year++; &#125; &#125;&#125;void DATE::Decrement()&#123; day--; if ( day == 0 ) &#123; if( month == 1 ) &#123; day = 31; month = 12; year--; &#125; else &#123; month--; day = DaysInMonth( month, year ); &#125; &#125;&#125;int DaysInMonth( /* in */ int mo, /* in */ int yr )&#123; switch (mo) &#123; case 1: case 3: case 5: case 7: case 8: case 10: case 12: return 31; case 4: case 6: case 9: case 11: return 30; case 2: if ((yr % 4 == 0 &amp;&amp; yr % 100 != 0) ||yr % 400 == 0) return 29; else return 28; &#125;&#125; 123456789101112131415161718192021222324//client.cpp#include &quot;DATE.h&quot;#include &lt;iostream&gt;using namespace std;int main()&#123; DATE date1, date2; //① int tmp; date1.Set( 2020, 7, 1 ); date1.Print(); date1.Increment(); date1.Print(); date2.Set( 1997, 7, 1 ); date2.Print(); date2.Decrement(); date2.Print(); tmp = date1.getYear(); tmp++; date1.Set( tmp, 12, 20 ); date1.Print(); cout &lt;&lt; date1.year; //error? return 0;&#125; 开发平台和编译器 gcc和g++是GNU的c&amp;cpp编译器 gcc/g++执行编译时，需要四步 生成.i文件，预处理【预处理器cpp】 生成文件.s 文件，将预处理后的文件转换成汇编语言【编译器egcs】 生成.o文件，将汇编变为目标代码（机器代码）【汇编器as】 生成可执行程序，连接目标代码【连接器ld】 Namespace 12345678#include&lt; iostream &gt;main()&#123; int a; cin &gt;&gt; a; cout &lt;&lt; a ; return 0;&#125; 经预处理器处理后，扩展为左边的 代码。根据前面所述的标识符作用 范围规则：cin和cout是在名字空间 std内声明的，而std是一个块 （block），因此在其外当然不能直 接使用cin和cout。所以以下代码实 际上有语法错误。 因此才出现 using namespace std;这样的语句来解决这个问题。 123456789101112namespace std&#123; istream cin; ostream cout;&#125;int main()&#123; int a; cin &gt;&gt; a; cout &lt;&lt; a ; return 0;&#125; 3种方式使用Namespace标识符 使用由命名空间、作用域解析运算符::和所需标识符组成的限定名称 1std::cin &gt;&gt; a; 编写using声明 12using std::abs ;cin &gt;&gt; a; 本地或全局编写using指令 12using namespace std ; cin &gt;&gt; a; 用处 命名空间用于防止命名冲突。 命名空间std通常用于覆盖标准C++库的标准C++定义、声明等。 例1 123456789101112namespace mfc &#123; //vendor 1’s namespace int inflag; //vendor 1’s inflag&#125;namespace owl &#123; //vendor 2’s namespace int inflag; //vendor 2’s inflag&#125;mfc::inflag = 3; //mfc’s inflagowl::inflag = -823; //owl’s inflagusing mfc::inflag;inflag = 3;owl::inflag = -823; 例2 12345678910namespace mfc &#123; //vendor 1’s namespace int inflag; //vendor 1’s inflag void g(int);&#125;using mfc::inflag; //using declaration for inflaginflag = 100; //OKg(8); //Error!mfc::g(8); //OK, full nameusing mfc::g; //using declaration for gg(8); //OK 例3 12345678namespace mfc &#123; //vendor 1’s namespaceint inflag; //vendor 1’s inflagvoid g(int);&#125;using namespace mfc;//using directiveinflag = 21; //mfc::inflagg(-66); //mfc::gowl::inflag=341; //full name needed 范围解析运算符（Scope Resolution Operator） 可以使用作用域解析运算符引用隐藏的全局名称:: 1234567int x;void f2( )&#123; int x = 1; // hide global x ::x = 2; // assign to global x x=2; //assign to local x&#125; (but, there is no way to use a hidden local name) I/O cout与输出的实质 12cout &lt;&lt; “the answer is: ” &lt;&lt; 3*4 &lt;&lt; endl; //该语句在屏幕上输出 the answer is 12 计算机对3*4求值得整数值12； &lt;&lt;把字符‘t’、’h’ … ‘s’、’:’、’ ‘放入cout流中； &lt;&lt;把整数值12转化为字符‘1’和‘2’，也放入cout流中 endl产生一个换行符，该字符也被放入cout流中 cout把这些字符送往显示器 image-20230307012016458 cin与输入的实质 1cin &gt;&gt; someInt &gt;&gt; someFloat &gt;&gt; someChar ; 键盘输入的字符一个一个进入输入流cin里面； 一个&gt;&gt;代表一个输入过程。&gt;&gt;从cin中一个接一个获取字符， 这个获取过程在哪里结束取决于变量的数据类型。该获取过 程结束后，&gt;&gt;根据变量的数据类型，把刚才获得的字符序列 转化成跟变量类型一致的数据；然后把这个数据赋给变量。 下一个&gt;&gt;开始。 image-20230307012311466","categories":[],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://klc1006.github.io/tags/cpp/"}]},{"title":"【AI Course】A*和 IDA*算法解决15-puzzle问题","slug":"AI Course3","date":"2023-03-06T11:38:29.661Z","updated":"2023-03-06T10:56:49.939Z","comments":true,"path":"2023/03/06/AI Course3/","link":"","permalink":"https://klc1006.github.io/2023/03/06/AI%20Course3/","excerpt":"","text":"中山大学计算机学院 人工智能实验报告（三） (2022春季实验报告) 课程名称:Artificial Intelligence 教学班级 专业方向 学号 姓名 计科1班 计算机科学与技术 20337013 陈梁坤 一、实验题目 使用A*和 IDA*算法解决15-puzzle问题，启发式函数自己选取，可以尝试多种不同的启发式函数 二、实验内容 1.算法原理 问题重述 15数码问题本质上就是棋盘上乱序的15个数字将牌（整数1~15），通过允许空格周围的四个方向的将牌向空格移动，通过移动空格周围的数字将牌改变棋盘的格局（状态）。本实验的目标就是移动将牌。将初始状态改为目标状态 A*算法原理 A*算法应用启发式搜索的原理，启发式搜索又叫有信息搜索。利用问题当前状态所具有的信息来引导问题的解决方向（向最有希望的方向前进），相较于盲目搜索（无信息搜索），能够降低问题的复杂度。 定义函数： 函数 意义 g(n) 从初始节点到节点n付出的实际代价 h(n) 从节点n到目标节点的最优路径的估计代价 h*(n) 从节点n到目标节点的最优路径的实际代价 f(n) 从初始节点到目标节点的最优路径的估计代价 \\[ f(n)=g(n)+h(n) \\] A*算法可以看作BFS的优化，在BFS算法st的基础上加以提升：从初始节点（状态）开始，检测后继节点（状态），选取f(n)最小的节点进行拓展（可以利用优先队列来实现），同时更新被访问过的节点的g(n),直到找到目标节点，即当前节点的f(n)==0 核心算法步骤： ①从起始状态start开始，把start作为一个待处理的对象加入优先队列OPEN中 ②从起始状态开始，搜索空格周围可能处理的下一个状态，并把他们加入OPEN中，计算这些状态的f(n),g(n),h(n),设置存储他们的父状态start 或设置存储上一步操作 ③从OPEN中删除状态start，并加入CLOSE列表（相当于visit数组），循环操作直到找到目标状态或者开启列表为空 ④从OPEN中找到f(n)最小的状态，并进行拓展，计算这些状态的f(n),g(n),h(n),设置存储他们的父状态start 或设置存储上一步操作 ⑥如果新的相邻状态已经在开启列表，则更新他们的g(x) IDA*算法原理 IDA*是迭代加深深度优先搜索的拓展，与A*算法的结合。由于不需要存储父节点（状态），空间复杂度远远小于A* 定义函数 函数 意义 g(n) 从初始节点到节点n付出的实际代价 h(n) 从节点n到目标节点的最优路径的估计代价 h*(n) 从节点n到目标节点的最优路径的实际代价 f(n) 从初始节点到目标节点的最优路径的估计代价 在每一步的迭代深度搜索的过程中，都是优先对邻接状态f(n)最小的状态进行搜索，当某一层的搜素的所有可访问的最小可估价函数&gt;某一给定的阈值时，即h(n)&gt;h*(n)，进行剪纸，不在访问，进行回溯。 核心算法布置 ①设计阈值bound，定义递归的进程 ②从起始状态start开始，计算start可达到的每一个下一个状态的估计f(n),选取最小的节点作为下一个访问状态 ③对于某一个状态，如果估价函数大于bound，返回当前状态的估价函数值，范围为false ④对一某一个状态，如果是目标状态，则返回true，并返回该状态。 2.关键代码展示 **启发式函数** 123456789101112131415161718MDT=[] #定义矩阵MDT,MDT[i][j]定义为第i个格子到第j个格子的曼哈顿距离for i in range(16): tmp=[] for j in range(16): tmp.append(abs(int(i / N) - int(j / N))+abs(int(i % N) - int(j % N))) #构造每个数字将牌到目标位置的曼哈顿距离 MDT.append(tmp) #虽然增加了空间的使用，但是减少了函数的调用，把调用函数转化为访问空间def manhattan(pz): #定义曼哈顿距离函数（启发式函数） sum=0 #初始化h(n)为0 for i in range(N2): if pz[0][i]==N2: #当数字为16，即空格位置，不算入h(n)估价，跳过 continue sum+=MDT[i][pz[0][i]-1] #遍历每个数字，计算累积的的最终状态代价 return sum #返回h(n) ​ A*算法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465def Astar(s): OPEN=PriorityQueue() #优先队列OPEN存放待访问状态，f(n)函数小的状态优先拓展 s.MD=manhattan(s) #求初始状态的h(n) s.cost=0 #定义初始状态的g(n)为0 CLOSE=&#123;&#125; #定义CLOSE数组，存放拓展过的状态节点 u=puzzle() #声明u便于暂存当前状态 v=puzzle() # 声明v便于暂存当前状态 initial=State() # 声initial便于暂存当前状态 # initial.puzzle.MD=0+s.MD # initial.puzzle.cost=0+s.cost # initial.puzzle.space=0+s.space # for i in range(45): # initial.puzzle.path[i]=0+s.path[i] # for i in range(16): # initial.puzzle.f[i]=0+s.f[i] initial.puzzle=copy.deepcopy(s) #深拷贝函数耗时较长 initial.estimated=manhattan(s) #计算初始状态h(n) OPEN.put(initial) #初始状态加入队列 while (not OPEN.empty()): #当队列不为空，搜索不停止 global sum #就算探索状态节点 sum+=1 st=State() #声明st便于暂存出队状态节点 st=copy.deepcopy(OPEN.get()) #st暂存出队状态节点 # print(st.puzzle.f) u=copy.deepcopy(st.puzzle) #u暂存出队状态节点的数字棋盘 # print(u.f) if(u.MD==0): #当启发函数最小估计代价为0，即搜索至目标状态 # print(u.f) # print(u.path) print(len(CLOSE)) return u #返回成功搜索节点状态 CLOSE[u.f.__str__()]=True #CLOSE数组存储已经拓展过的状态节点 sx=int(u.space/N) #空格的横坐标 sy=int(u.space%N) #空格的纵坐标 # print(sx,sy) for r in range(4): #对四个方向的邻接状态进行探索 tx=sx+diraction[r][0] #下一个状态的横坐标 ty=sy+diraction[r][1] #下一个状态的纵坐标 if (tx&lt;0 or ty&lt;0 or tx&gt;=N or ty&gt;=N):#空格越界，接续执行 continue v=copy.deepcopy(u) #保存出队状态 v.MD-=MDT[tx*N+ty][v.f[tx*N+ty]-1] v.MD+=MDT[sx*N+sy][v.f[tx*N+ty]-1] #计算移动数字后的状态的h(n) temp=v.f[tx * N + ty] v.f[tx * N + ty]=v.f[sx * N + sy] v.f[sx * N + sy]=temp #移动数字的操作:被移动数字与16交换 v.space=tx*N+ty #记录移动后空格所处的位置 if(not (v.f.__str__() in CLOSE) ): #环检测，如果没有出过队 # path[v.cost]=dir[r] #找路径和状态 # print(v.f) v.path.append(r) #队列加入邻接状态 v.cost+=1 #cost++ g(n)函数 new=State() #创建新的state，用于入队列 new.puzzle=copy.deepcopy(v) new.estimated=v.cost+v.MD OPEN.put(new) #入优先队列OPEN return -1 ​ IDA*算法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102def IDAstar(depth,prev): #IDA*函数 global sum_node #统计访问过的状态的数量 sum_node+=1 global state #使用全局变量 状态state global bound #使用全局变量 阈值bound if state[2] ==0: #如果当前状态到目标状态的最小估计代价为0,即当前状态为目标状态 return (True,depth+state[2]) #返回（搜索成功，成功搜索步数） if depth+state[2]&gt;bound: #如果初始状态到当前状态的最小代价g(n)=depth+当前状态到目标状态的最小估计代价h(n)&gt;阈值 return (False,depth+state[2]) #返回（搜索失败，失败搜索步数） sx=int(state[1]/N) #一维位置转换为二维坐标 sy=int(state[1]%N) #一维位置转换为二维坐标 tmp=[[],0,0] #用于存储当前状态，便于回溯 successor=[] #后继，邻接状态 for r in range(4): tx=sx+diraction[r][0] #下一个状态的横坐标 ty=sy+diraction[r][1] #下一个状态的纵坐标 if (tx&lt;0 or ty&lt;0 or tx&gt;=N or ty&gt;=N): #空格越界，接续执行 continue if((max(prev,r)-min(prev,r))==2): #不走回头路 continue h_n=state[2]-MDT[tx*N+ty][state[0][tx*N+ty]-1] h_n+=MDT[sx*N+sy][state[0][tx*N+ty]-1] #计算移动数字后的状态的h(n) successor.append((h_n,r)) #插入后继数组 sorted(successor,key=lambda x:(x[0],x[1])) #对后继数组进行排序，h(n)较小的优先访问 successor.reverse() Min=[False,9999] #保存邻接状态的最小代价 for r in successor: tx=sx+diraction[r[1]][0] #下一个状态的横坐标 ty=sy+diraction[r[1]][1] #下一个状态的纵坐标 if (tx&lt;0 or ty&lt;0 or tx&gt;=N or ty&gt;=N): #空格越界，接续执行 continue if((max(prev,r[1])-min(prev,r[1]))==2): #对上一个状态判重剪枝 continue #tmp=copy.deepcopy(state) #存储当前状态，便于回溯 for item in state[0]: tmp[0].append(item) tmp[1]=0+state[1] tmp[2]=0+state[2] state[2]-=MDT[tx*N+ty][state[0][tx*N+ty]-1] state[2]+=MDT[sx*N+sy][state[0][tx*N+ty]-1] #计算移动数字后的状态的h(n) temp=state[0][tx * N + ty] state[0][tx * N + ty]=state[0][sx * N + sy] state[0][sx * N + sy]=temp #移动数字的操作:被移动数字与16交换 # print(state[0]) state[1]=tx*N+ty #记录移动后空格所处的位置 a=(False,0) #记录递归搜索后搜索成功与否，以及搜索步长 if(not str(state[0]) in CLOSE): #环检测 CLOSE[str(state[0])]=depth+state[2] #如果没有探索过，加入字典，并记录该状态的f(n) a=IDAstar(depth+1,r[1]) #迭代深搜 if(a[0]): #如果搜索成功 path[depth]=r[1] #记录当前深度的操作 return a #返回（搜索成功，最小步长） else: if(a[1]&lt;Min[1]): #如果没有搜索成功 Min[1]=a[1] #更新邻接状态的最小代价，用于更新阈值bound else: if CLOSE[str(state[0])]&gt;=(depth+state[2]): #如果当前状态已经被探索过，而且先前探索过的状态的f(n)&gt;目前相同状态的f(n) CLOSE[str(state[0])]=depth+state[2] #更新该状态的最小f(n) a=IDAstar(depth+1,r[1]) #迭代搜索 if(a[0]): #如果搜索成功 path[depth]=r[1] #记录当前深度的操作 return a #返回（搜索成功，最小步长） elif a[1]&lt;Min[1]: #如果没有搜索成功 Min[1]=a[1] #更新邻接状态的最小代价，用于更新阈值bound #state=copy.deepcopy(tmp) #回溯 for i in range(16): state[0][i]=0+tmp[0][i] state[1]=0+tmp[1] state[2]=0+tmp[2] return Mindef ID(In): #迭代深搜 global state #使用全局变量 状态state global bound #使用全局变量 阈值bound In[2] = manhattan(In) while True: #bound的值用全局变量进行更新 #state=copy.deepcopy(In) #使用深拷贝函数，保存状态 for i in range(16): state[0][i]=0+In[0][i] state[1]=0+In[1] state[2]=0+In[2] a=IDAstar(0,-100) #进入IDA*算法，返回（a[0]搜索成功与否，a[1]搜索代价） if (a[0]): #搜索成功，保存搜索路径 ans=&quot;&quot; for i in range(bound): ans+=dir[path[i]] #path利用0右边移动，1上边移动，2左边移动，3下边移动，保存 return ans bound=a[1] #阈值更新临界状态的最小代价f(n) if bound&gt;100: #超过限制退出循环 break return &quot;failed&quot; 3.创新点&amp;优化 提前判断该15数码问题是否有解 123456789101112def isValid(In): ans=1 for i in range(16): if not In[0][i]: ans+=6-i%4-i/4 for j in range(i): if In[0][j]&gt;In[0][i]: ans+=1 if ans&amp;1: return 1 #合法 else: return 0 #不合法 image-20220317000740937 原理： 在算N数码的逆序数时，不把0算入在内； 当N为奇数时， 当 两个N数码的逆序数 奇偶性相同时，可以互达，否则不行； 当N为偶数时，当 两个N数码的奇偶性相同的话，那么两个N数码中的0所在行的差值 k，k也必须是偶数时，才能互达； 当两个N数码的奇偶性不同时，那么两个N数码中的0所在行的差值 k，k也必须是奇数时，才能互达； 将深拷贝换成赋值语句 123456#tmp=copy.deepcopy(state) #存储当前状态，便于回溯for item in state[0]: tmp[0].append(item)tmp[1]=0+state[1]tmp[2]=0+state[2] 时间对比： 样例1 样例2 样例3 样例4 直接赋值 0.5s 0.3s 0.1s 4s 调用深拷贝函数 5.25s 3.1s 1.17s 38s 使用copy.deepcopy()是，程序新建地址空间，耗费大量时间，可以看到直接使用赋值语句，减少copy.deepcopy()函数的调用，大大提高用时效率。 **对IDA*加入环检测，较少访问节点次数** 123456789101112131415161718if(not str(state[0]) in CLOSE): #环检测 CLOSE[str(state[0])]=depth+state[2] #如果没有探索过，加入字典，并记录该状态的f(n) a=IDAstar(depth+1,r[1]) #迭代深搜 if(a[0]): #如果搜索成功 path[depth]=r[1] #记录当前深度的操作 return a #返回（搜索成功，最小步长） else: if(a[1]&lt;Min[1]): #如果没有搜索成功 Min[1]=a[1] #更新邻接状态的最小代价，用于更新阈值boundelse: if CLOSE[str(state[0])]&gt;=(depth+state[2]): #如果当前状态已经被探索过，而且先前探索过的状态的f(n)&gt;目前相同状态的f(n) CLOSE[str(state[0])]=depth+state[2] #更新该状态的最小f(n) a=IDAstar(depth+1,r[1]) #迭代搜索 if(a[0]): #如果搜索成功 path[depth]=r[1] #记录当前深度的操作 return a #返回（搜索成功，最小步长） elif a[1]&lt;Min[1]: #如果没有搜索成功 Min[1]=a[1] #更新邻接状态的最小代价，用于更新阈值bound 加入环检测后，针对IDA*的性能分析如下表： 样例1 样例2 样例3 样例4 有环检测剪枝 18651 12201 4315 158044 无环检测剪枝 21985 15389 4414 261175 仅对IDA*做出改进，可以看到加入环检测（判重）剪枝后，探索的状态节点有所减少，样例4为例，探访的状态节点少了五分之二 提前计算每个数字到指定位置的曼哈顿距离 123456MDT=[]for i in range(16): tmp=[] for j in range(16): tmp.append(abs(int(i / N) - int(j / N))+abs(int(i % N) - int(j % N))) MDT.append(tmp) 能够减少函数的调用，把函数调用转换为访问二维列表，提高运算效率 先对初步判断其后继状态节点的最小估计函数，较小的先探索 12345678910111213successor=[] #后继，邻接状态for r in range(4): tx=sx+diraction[r][0] #下一个状态的横坐标 ty=sy+diraction[r][1] #下一个状态的纵坐标 if (tx&lt;0 or ty&lt;0 or tx&gt;=N or ty&gt;=N): #空格越界，接续执行 continue if((max(prev,r)-min(prev,r))==2): #不走回头路 continue h_n=state[2]-MDT[tx*N+ty][state[0][tx*N+ty]-1] h_n+=MDT[sx*N+sy][state[0][tx*N+ty]-1] #计算移动数字后的状态的h(n) successor.append((h_n,r)) #插入后继数组sorted(successor,key=lambda x:(x[0],x[1])) #对后继数组进行排序，h(n)较小的优先访问successor.reverse() 访问节点： 样例1 样例2 样例3 样例4 有排序 18651 12201 4315 158044 无排序 18514 6087 6498 43405 运行耗时： 样例1 样例2 样例3 样例4 有排序 0.5s 0.3s 0.1s 4s 无排序 0.68s 0.285s 0.29s 1.7s 可以看到对邻接状态的最小估价进行排序，并没有实质上减少状态节点的访问。对于样例3有明显的改进，但是对于样例4反而增加了访问的状态节点数，增加了运算时间。 三、实验结果及分析 1.实验结果展示实例 A* 实验结果 期望结果 IDA* 实验结果 期望结果 2.评测指标展示及分析 A*与IDA*算法性能分析 A*算法采取的是广度优先搜索的策略，但是在运算过程中，我们引入启发函数，使得在广度搜索的时候是有意识的优先拓展最小代价比较小的部分，有一定前进的方向，但是目标仍然不明确。虽然该算法是有提示的搜素，但是可以发现该算法所用的时间复杂度较大，因为该算法需要使用大量的空间存储以及探索过的状态节点，以防止重复探索 IDA*算法采用的是迭代深度优先搜索的策略，搜索过程中会采用估价函数，通过剪枝减少不必要的搜索。该算法通过更新阈值来不断迭代深度搜索。由于使用了回溯的方法，所以在回溯过程中不必保存中间状态，大大节省空间。然而在每次回溯过程中，需要从头搜索，由此，该算法的时间复杂性较大 由于A*算法与IDA*算法所写的代码不能够完全一致，所以在理论上与实践中运行程序所用的时间存在一定的差距，我们通过比较两个算法访问状态节点的数目，比较两个算法的时间复杂度。 样例1 样例2 样例3 样例4 A* 3180 5649 3871 28017 IDA* 18651 12201 4315 158044 可以看到IDA*相较于A*算法，访问节点的数目上较多，所以该算法的时间复杂度理论上要大。 **为什么实验结果表明A*算法所用的时间会比IDA*的算法所用时长？** 样例1 样例2 样例3 样例4 A* 5s 9s 6s 47s IDA 0.5s 0.3s 0.1s 4s 原因是 A*算法在调用函数时创建大量的空间，创建空间所用的时间已经远大于算法真正所需要的时间。 另一方面，A*算法在保存状态时在5处使用了copy.deepcopy()函数，相较于没有使用该函数的IDA*时间性能较差，事实上，IDA*是优化后的版本，将copy.deepcopy（）函数替换为赋值语句，大大提高了计算性能。 启发式函数性能分析 在极端情况下,如果h(n)=0,那么只有g(n)实际上是有用的,这时A*算法也就是迪杰斯特拉算法,它能保证一定可以找到一条最优路径. 如果h(n)总是小于(或者等于)从结点n走到目标结点的步数,那么A算法是一定可以找到最优路径的.h(n)越小,A扩展的结点越多,导致A*算法越慢. 如果h(n)恰好等于从结点n走到目标结点的步数,A算法扩展的所有结点都在最优路径上,它不会扩展任何其他无关结点,此时A算法的速度是非常快的.尽管你无法总是做到这一点,但在某些特定情况下你确实做到.知道A*算法可以在某些时候运行的很好是一件很值得高兴的事. 如果h(n)所给出的信息有时大于从结点n走到目标结点的步数,那么A*算法将无法确保能够找到最优路径,但它会运行得更快. 在另一种极端的情况下,如果h(n)非常接近于g(n),那么只有h(n)将起作用,此时A*算法实际上变成宽度优先搜索. 当h(n)尽量接近h*(n)时算法是较为优秀的 曼哈顿距离的启发函数以及算是一个优秀的启发式函数了 环检测，剪枝性能分析 对IDA*做出改进 无环检测 有环检测 样例1 样例2 样例3 样例4 有环检测剪枝 18651 12201 4315 158044 无环检测剪枝 21985 15389 4414 261175 仅对IDA*做出改进，可以看到加入环检测（判重）剪枝后，探索的状态节点有所减少，样例四为例，探访的状态节点少了五分之二 c++与python 性能分析 在用python写这两份算法之前，先用c++编写了这两个算法，用c++写程序相较于python性能也有很大的提升 使用C++运行IDA*算法代码 运行ppt上的代码（最初四个样例） 样例1： image-20220316154305038 样例2： image-20220316154108436 样例3： image-20220316154329768 样例4： image-20220316154346252 由于python运行时间较长 此处只对ppt样例4和ppt样例2进行演示： 样例2 image-20220316202125114 image-20220316202134604 样例4 image-20220316154646873 image-20220316154531485 可以看到仅仅是样例4，用python版本的IDA*算法也跑了220s左右而样例2也跑了393s ppt样例1 ppt样例2 ppt样例3 ppt样例4 c++版IDA* 100s 0.4s 152s 2.2s python版IDA* —— 393s —— 220s 原因： c++和python代码都会转变成CPU指令，然而python转换出来的cpu指令会比较多。 c++是编译型语言，需要通过预处理，编译，链接之后才会生成可执行文件 python是解释型语言，需要把源代码转换成字节码文件，再由python虚拟机一条条执行字节码指令，需要经过解释器这个过程 四、思考题 如果用列表作为字典的键，会发生什么现象？用元组呢？ 字典用法解释： 键必须是可哈希的，大多数Python对象可以作为键，但它们必须是可哈希的对象。像列表和字典这样的可变类型，由于它们不是可哈希的，所以不能作为键。 所有不可变的类型都是可哈希的，因此它们都可以做为字典的键。 数字和字符串可以被用做字典的键，元组是不可变的但也可能不是一成不变的，因此用元组做有效的键必须要加限制：若元组中只包括像数字和字符串这样的不可变参数，才可以作为字典中有效的键。 为什么键必须是可哈希的？ 解释器调用哈希函数，根据字典中键的值来计算存储你的数据的位置。如果键是可变对象，它的值可改变。如果键发生变化，哈希函数会映射到不同的地址来存储数据。如果这样的情况发生，哈希函数就不可能可靠地存储或获取相关的数据。选择可哈希的键的原因就是因为它们的值不能改变。 image-20220316233121076 字典中的键为list是可变的，不可哈希，报错 image-20220316233130209 字典中的键是元组，不可变，可哈希，程序正常运行 image-20220316233137776 字典中的键是元组，但是元组中含有list类型元素，导致元组可变，不可哈希，程序报错 在本课件第 2 章和第 4 章提到的数据类型中，哪些是可变数据类型， 哪些是不可变数据类型？试结合代码分析。 可变 /不可变 数据类型：变量值发生改变时，变量的内存地址 不变/改变 。 • 提示：① 你可能会用到 id() 函数。② Python 的赋值运算符（ （=）是引用传递。） 数字是不可变数据类型 image-20220316233922159 image-20220316233926553 每一个数字都由一片地址空间进行存储，=只是引用传递，本质上还是对同一片空间进行访问 列表是可变数据类型 image-20220316233936044 更改列表里面的元素，地址没有发生改变 元组是不可变数据类型 image-20220316233950944 image-20220316234726505 对元组内元素发生更改，会报错 字符串是不可变数据类型 image-20220316233941648 对字符串本身发生更改，地址会发生改变，追加元素，对原来字符串并没有发生更改 字典是可变数据类型 image-20220316234005372 更改字典里面的元素，地址没有发生改变 集合是不可变数据类型 image-20220316234316013 集合中有可变数据类型，会报错 image-20220316234022985 修改集合后，地址未发生更改，但是集合原本的元素并没有发生更改 五、参考资料 https://blog.csdn.net/free4wuyou/article/details/15676597?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164733496816781685340998%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=164733496816781685340998&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2allfirst_rank_ecpm_v1~rank_v31_ecpm-5-15676597.142 https://blog.csdn.net/qq_40998706/article/details/87828065?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164741396216780271553315%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=164741396216780271553315&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2allfirst_rank_ecpm_v1~rank_v31_ecpm-1-87828065.142 https://blog.csdn.net/stl112514/article/details/37689823?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164744586416780271921157%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=164744586416780271921157&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2allfirst_rank_ecpm_v1~rank_v31_ecpm-1-37689823.142","categories":[],"tags":[{"name":"A*","slug":"A","permalink":"https://klc1006.github.io/tags/A/"},{"name":"IDA*","slug":"IDA","permalink":"https://klc1006.github.io/tags/IDA/"}]},{"title":"【AI Course】PDDL解决规划问题","slug":"AI Course 12","date":"2023-03-06T11:38:29.648Z","updated":"2023-03-06T11:36:53.794Z","comments":true,"path":"2023/03/06/AI Course 12/","link":"","permalink":"https://klc1006.github.io/2023/03/06/AI%20Course%2012/","excerpt":"","text":"中山大学计算机学院 人工智能实验报告（十二） (2022春季实验报告) 课程名称:Artificial Intelligence 教学班级 专业方向 学号 姓名 计科1班 计算机科学与技术 20337013 陈梁坤 一、实验题目 使用pddl补充完整两个问题，分别为blocks问题和puzzle问题 二、实验内容 算法原理 PDDL：Planning Domain Deﬁnition Language 规划领域定义语言，是一种解决人工智能规划问题的比较前沿的方法。PDDL常用于解决智能规划问题，例如机器人将一个屋子的球搬运到另一间屋子里，通过合理的组织流程建造一间房子等。PDDL的规划任务（planning task）由五部分组成。 Objects（对象） Things in the world that interest us. Predicates（谓词） Properties of objects that we are interested in; can be true or false. Initial state（初始状态） The state of the world that we start in. Goal speciﬁcation（目标规范） Things that we want to be true. Actions/Operators（操作/运算符） Ways of changing the state of the world. PDDL指定的规划任务分为两个文件，domain 文件和 problem 文件。 A domain file（域文件） for predicates and actions. A problem file（问题文件） for objects, initial state and goal specification. Domain Files 域文件定义如下： 123456(define (domain &lt;domain name&gt;) &lt;PDDL code for predicates&gt; &lt;PDDL code for first action&gt; [...] &lt;PDDL code for last action&gt;) Problem Files 问题文件定义如下： 123456(define (problem &lt;problem name&gt;) (:domain &lt;domain name&gt;) &lt;PDDL code for objects&gt; &lt;PDDL code for initial state&gt; &lt;PDDL code for goal specification&gt;) 关键代码展示 blocks问题 123456789(define (problem prob) (:domain blocks) (:objects A B C D E F - physob) (:init (clear A)(on A B)(on B C)(ontable C) (ontable D) (ontable F)(on E D)(clear E)(clear F)) (:goal (and (clear F) (on F A) (on A C) (ontable C)(clear E) (on E B) (on B D) (ontable D)) ) ) 12345678910111213141516171819202122(define (domain blocks) (:requirements :strips :typing:equality :universal-preconditions :conditional-effects) (:types physob) (:predicates (ontable ?x - physob) (clear ?x - physob) (on ?x ?y - physob) ) (:action move :parameters (?x - physob ?y - physob ?z - physob) :precondition(and (clear ?x) (clear ?y) (not(on ?x ?y)) (or (ontable ?x) (on ?x ?z) )) :effect( and (not(clear ?y)) (on ?x ?y) (when(ontable ?x) (not(ontable ?x)) ) (when(on ?x ?z) (and (not(on ?x ?z))(clear ?z))) ) ) (:action moveToTable :parameters (?x - physob ?y - physob) :precondition(and (clear ?x) (not(ontable ?x)) (on ?x ?y)) :effect( and (ontable ?x ) (clear ?y) (not (on ?x ?y))) ) ) 动作move 参数三个积木：x,y,z precondition:积木x顶部为空，积木y顶部为空，积木x不在积木y上，积木x在桌面上或者积木x在积木y上 effect：积木y顶部不为空，积木x在积木y上 如果积木x原来在桌子上，添加积木x不在桌子上 如果积木原来在积木z上，添加积木x不在积木y上 积木z顶部为空 动作moveToTable 参数两个积木x，y precondition：积木x顶部为空，积木x不在桌子上，积木x在积木y上 effect：添加积木x在桌子上，积木y的顶部为空 积木x不在积木上 puzzle问题 初始状态 image-20220613190231563 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859(define (problem prob) (:domain puzzle) (:objects n1 n2 n3 n4 n5 n6 n7 n8 n0 - num l11 l12 l13 l21 l22 l23 l31 l32 l33 - loc) (:init (at n1 l11) (at n2 l12) (at n3 l13) (at n7 l21) (at n8 l22) (at n0 l23) (at n6 l31) (at n4 l32) (at n5 l33) (adjacent l11 l12) (adjacent l11 l21) (adjacent l12 l11) (adjacent l12 l13) (adjacent l12 l22) (adjacent l13 l12) (adjacent l13 l23) (adjacent l21 l11) (adjacent l21 l22) (adjacent l21 l31) (adjacent l22 l12) (adjacent l22 l23) (adjacent l22 l32) (adjacent l22 l21) (adjacent l23 l13) (adjacent l23 l13) (adjacent l23 l13) (adjacent l31 l21) (adjacent l31 l32) (adjacent l32 l31) (adjacent l32 l22) (adjacent l32 l33) (adjacent l33 l23) (adjacent l33 l32) ) (:goal (and(at n1 l11) (at n2 l12) (at n3 l13) (at n4 l21) (at n5 l22) (at n6 l23) (at n7 l31) (at n8 l32) (at n0 l33) ) )) 12345678910111213(define (domain puzzle) (:requirements :strips :equality:typing) (:types num loc) (:predicates (:action slide :parameters (?x - num ?y - loc ?z - loc ) :precondition (and (at n0 ?y) (at ?x ?z) (adjacent ?y ?z)) :effect (and (not(at n0 ?y)) (not(at ?x ?z)) (at n0 ?z) (at ?x ?y)) )) 动作slide 参数x：num，y:loc，z：loc 实现逻辑：将数字x从位置z转移至位置y precondition：位置y为空，数字x在位置z上，位置y和位置z相邻 effect：添加位置y不为空，数字x不在位置z，位置z为空，数字x在位置y 三、实验结果及分析 实验结果展示实例 blocks 实验结果 image-20220613193258535 验证步骤 根据上述步骤做下面积木移动动作 image-20220615154456087 image-20220615154503641 image-20220615154517215 image-20220615154531814 image-20220615154626567 image-20220615154646212 image-20220615154653872 image-20220615154703004 image-20220615154710335 image-20220615154716996 该规划器能够得到正确的步骤，使得积木由初始状态，变为目标状态，但但是规划出来的步骤仍然存在冗余项，该规划步骤不是最小步骤。 puzzle 实验结果 image-20220613193053867 步骤验证 验证程序： 1234567891011121314151617puzzle=[[1,2,3],[7,8,0],[6,4,5]]step=[]with open(&quot;step&quot;,&#x27;r&#x27;) as file: lines=file.readlines()[:] for data in lines: data=data.split() step.append([data[2],data[3]])cnt=0for item in step: cnt+=1 print(&quot;\\nstep&quot;,cnt) puzzle[int(item[0][1])-1][int(item[0][2])-1], puzzle[int(item[1][1])-1][int(item[1][2])-1] = puzzle[int(item[1][1])-1][int(item[1][2])-1] ,puzzle[int(item[0][1])-1][int(item[0][2])-1] for i in range(len(puzzle)): for j in range(len(puzzle[i])): print(puzzle[i][j],end=&quot; &quot;) print() 验证结果： image-20220613192822353 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154step 11 2 07 8 36 4 5step 21 0 27 8 36 4 5step 31 8 27 0 36 4 5step 41 8 27 4 36 0 5step 51 8 27 4 30 6 5step 61 8 20 4 37 6 5step 71 8 24 0 37 6 5 step 81 8 24 3 07 6 5step 91 8 04 3 27 6 5step 101 0 84 3 27 6 5step 111 3 84 0 27 6 5step 121 3 84 2 07 6 5step 131 3 04 2 87 6 5step 141 0 34 2 87 6 5step 151 2 34 0 87 6 5 step 161 2 34 6 87 0 5step 171 2 34 6 87 5 0step 181 2 34 6 07 5 8step 191 2 04 6 37 5 8step 201 0 24 6 37 5 8step 211 6 24 0 37 5 8step 221 6 24 3 07 5 8step 231 6 04 3 27 5 8step 241 0 64 3 27 5 8step 251 3 64 0 2 7 5 8step 261 3 64 2 07 5 8step 271 3 04 2 67 5 8step 281 0 34 2 67 5 8step 291 2 34 0 67 5 8step 301 2 34 5 67 0 8step 311 2 34 5 67 8 0 按照规划器给出的步骤，成功将8-puzzle还原，需要31步，该规划步骤仍然存在许多冗余步骤，不是最小步骤。","categories":[],"tags":[{"name":"PDDL","slug":"PDDL","permalink":"https://klc1006.github.io/tags/PDDL/"},{"name":"规划问题","slug":"规划问题","permalink":"https://klc1006.github.io/tags/%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98/"}]},{"title":"【AI Course】KNN完成情感分类标签","slug":"AI Course 8","date":"2023-03-06T11:38:29.640Z","updated":"2023-03-06T11:30:06.893Z","comments":true,"path":"2023/03/06/AI Course 8/","link":"","permalink":"https://klc1006.github.io/2023/03/06/AI%20Course%208/","excerpt":"","text":"中山大学计算机学院 人工智能实验报告（八） (2022春季实验报告) 课程名称:Artificial Intelligence 教学班级 专业方向 学号 姓名 计科1班 计算机科学与技术 20337013 陈梁坤 一、实验题目 在给定文本数据集完成文本情感分类训练，在测试集完成测试，计算准确率。 要求 文本的特征可以使用TF或TF-IDF（也可以使用sklearn库提取特征） 利用k-NN完成对测试集的分类，并计算准确率 需要提交简要报告+代码 加分项： 距离度量 算法效率优化 二、实验内容 算法原理 概念：KNN（K Near Neighbor）：k个最近的邻居，即每个样本都可以用它最接近的k个邻居来代表。 image-20220518170654848 最近邻 (k-Nearest Neighbors， KNN) 算法是一种分类算法， 1968年由 Cover和 Hart 提出， 应用场景有字符识别、 文本分类、 图像识别等领域。 该算法的思想是： 一个样本与数据集中的k个样本最相似， 如果这k个样本中的大多数属于某一个类别， 则该样本也属于这个类别。 距离度量 当p=2时，就是欧氏距离（对应L2范数） 最常见的两点之间或多点之间的距离表示法，又称之为欧几里得度量，它定义于欧几里得空间中。n维空间中两个点x1(x11,x12,…,x1n)与 x2(x21,x22,…,x2n)间的欧氏距离 欧氏距离 L2范数： image-20220518172512266 •余弦相似度： image-20220519101722620 余弦值作为衡量两个个体间差异的大小的度量 为正且值越大，表示两个文本差距越小，为负代表差距越大， K值的选择 一、近似误差与估计误差： 近似误差：对现有训练集的训练误差，关注训练集，如果近似误差过小可能会出现过拟合的现象，对现有的训练集能有很好的预测，但是对未知的测试样本将会出现较大偏差的预测。模型本身不是最接近最佳模型。 估计误差：可以理解为对测试集的测试误差，关注测试集，估计误差小说明对未知数据的预测能力好，模型本身最接近最佳模型。 二、K值确定标准： K值过小：k值小，特征空间被划分为更多子空间（模型的项越多），整体模型变复杂，容易发生过拟合，k值越小，选择的范围就比较小，训练的时候命中率较高，近似误差小，而用test的时候就容易出错，估计误差大，容易过拟合。 K值=N：无论输入实例是什么，都将简单的预测他属于训练实例中最多的类。 关键代码展示 训练代码 123456789101112131415161718192021def train_data(train_set): with open(&quot;train.txt&quot;,&#x27;r&#x27;) as file: lines=file.readlines()[1:] #读取第二行到最倒数第一行 for sntn in lines: sntn=sntn.split() sntn[1]=int(sntn[1]) #修改字符为整型 dict=&#123;&#125; #建立空字典 for i in range(3,len(sntn)): #从第三个单词开始遍历句子（有效单词） if(not(sntn[i] in mark)): #加入训练集合 mark[sntn[i]]=0 word.append(sntn[i]) #便于标记训练集句子和测试集句子的单词数量 temp=sentence(sntn,len(sntn)-3,&#123;&#125;) #建立句子类，存入到训练集和train_set train_set.append(temp) for i in range(len(train_set)): #遍历训练集合train_set,计算每个句子的单词频数 dict=copy(mark) for j in range(3,len(train_set[i].sentence)): dict[train_set[i].sentence[j]]+=1 train_set[i].dict=copy(dict) 测试代码 123456789101112131415161718def test_data(test_set): with open(&quot;test.txt&quot;,&#x27;r&#x27;) as file: lines=file.readlines()[1:] #读取第二行到最倒数第一行 for sntn in lines: sntn=sntn.split() sntn[1]=int(sntn[1]) #修改字符为整型 dict=&#123;&#125; #建立空字典 temp=sentence(sntn,len(sntn)-3,dict) #建立句子类，存入到测试集和test_set test_set.append(temp) for i in range(len(test_set)): #遍历训练集合train_set,计算每个句子的单词频数 dict=copy(mark) for j in range(3,len(test_set[i].sentence)): if(test_set[i].sentence[j] in dict): dict[test_set[i].sentence[j]]+=1 #采用TF策略，计算某个单词在该句子计算的频数 test_set[i].dict=copy(dict) KNN核心算法 12345678910111213141516171819202122232425262728293031res=[]def KNN(train_set,test_set,K): emo_possible=train_set[0].sentence[1] #设置默认心情 min=999999999 sum=0 #记录正确数 for i in range(len(test_set)): #遍历测试句子 min=999999999 emo=[0,0,0,0,0,0,0] #记录距离较短的前K个预测 qp=[] #记录预测心情，以及对应的距离 max=-1 for k in range(len(train_set)): #测试句子与训练句子一一比对 dist=0 for j in range(len(word)): #计算测试句子与训练句子的距离（欧氏距离） dist+=abs(test_set[i].dict[word[j]]-train_set[k].dict[word[j]]) dist=dist**0.5 qp.append([dist,train_set[k].sentence[1]]) #记录预测心情，以及对应的距离 qp.sort() #按距离从小到大排队 for k in range(int(K)): #记录距离较短的前K个预测 emo[qp[k][1]]+=1 #记录预测心情出现的频数 for k in range(1,7): #选择预测频数心情作为最终预测心情 if(emo[k]&gt;max): max=emo[k] emo_possible=k res.append(emo_possible) #记录最终预测心情 if(res[i]==test_set[i].sentence[1]): sum+=1 #如果预测正确，sum++ print(sum/len(test_set)) #答应正确率 另设计：采用sklearn和余弦相似度 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778def cosine_distance(x, y): #计算余弦相似度 xnorm = np.linalg.norm(x) ynorm = np.linalg.norm(y) #计算模长 if xnorm == 0: return 0 return 1.0 - np.dot(x,y) / (xnorm * ynorm) #计算相似度def euclidean_distance(x, y): return np.linalg.norm(x - y) #计算欧式距离def testing(train,test, k): label = [] train_data = [] test_data=[] #处理训练文件数据 with open(train_file) as train: for each in train: if each == &quot;documentId emotion words\\n&quot;: continue temp = each.split(&#x27; &#x27;, 3) label.append(int(temp[1])) #标记句子心情 train_data.append(temp[3].replace(&#x27;\\n&#x27;, &#x27;&#x27;)) #从temp[3]开始读入训练句子 #处理测试文件数据 label2=[] with open(test_file) as test: for each in test: if each == &quot;documentId emotion words\\n&quot;: continue temp = each.split(&#x27; &#x27;, 3) label2.append(int(temp[1])) test_data.append(temp[3].replace(&#x27;\\n&#x27;, &#x27;&#x27;)) #使用sklearn的CountVectorizer处理文本，生成词库和词语出现次数的矩阵 lenth = int(len(train_data) ) length=int(len(test_data) ) # test_data = train_data[lenth:] train_label = label[0:lenth] ans = label2[:] #标记心情 tfidf = TfidfVectorizer() tfidf.token_pattern = r&quot;(?u)\\b\\w+\\b&quot; tfidf_train = tfidf.fit_transform(train_data[0:lenth]) tfidf_vec = tfidf_train.toarray() #使用sklearn的KNeighborsClassifier进行分类 knn = KNeighborsClassifier(n_neighbors = k, metric=&quot;cosine&quot;) knn.fit(tfidf_vec, train_label) tfidf_test = tfidf.transform(test_data) test_vec = tfidf_test.toarray() predict_label = knn.predict(test_vec) # print(&quot;Sklearn&#x27;s result:&quot;,predict_label.tolist()) print(&quot;Sklearn&#x27;s accuracy:&quot;, metrics.accuracy_score(ans, predict_label))#########以上是调用sklearn进行学习测试######### test_vec = tfidf_test.toarray() #自己进行测试 all = len(test_data) correct = 0 my_label = [] for i, text in enumerate(test_vec): emo_count = [0, 0, 0, 0, 0, 0] dis = [] for each in tfidf_vec: #逐句计算余弦相似度 dis.append(cosine_distance(text, each)) temp = sorted(enumerate(dis), key=lambda x:x[1]) sortdis = [x[0] for x in temp] #按距离从小到大进行排序 for j in range(k): emo_count[train_label[sortdis[j]] - 1] += 1 max_data = max(emo_count)#选择前K个中的众数作为预测的心情 my_label.append(emo_count.index(max_data) + 1) if (emo_count.index(max_data) + 1) == ans[i]: #检测预测是否正确，若正确correct++ correct += 1 print(&quot;My accuracy:&quot;, correct / all)#####以上借用sklearn数据特征，使用自定义的距离公式（余弦相似度）进行学习测试###### 优化改进 距离计算&amp;算法效率 123456789for k in range(len(train_set)): same_word=0 for j in range(3,len(test_set[i].sentence)): if(not(test_set[i].sentence[j] in mark)): continue if(test_set[i].sentence[j] in train_set[k].dict): same_word+=1 temp=len(train_set[k].dict)+len(test_set[i].dict)-2*same_word dist=(len(train_set[k].dict)+len(test_set[i].dict)-2*same_word)**0.5 采用one hot 策略，简化计算公式 对比 改进前 改进后 改进后的计算相较于之前的算法要加快许多而且准确度也较高，原因是将遍历单词计算频数，简化为一个公式 dist=(len(train_set[k].dict)+len(test_set[i].dict)-2*same_word)**0.5 测试句子与训练句子做对比，找出相同的单词，那么这些单词在计算欧式距离时抵消 相反，那些不相同的单词将纳入计算训练句子和测试句子的考量 三、实验结果及分析 实验结果展示实例 自行设计的数据结构 image-20220519082210038 第一列显示预测的心情 ，第二列显示预测的心情，第三列显示预测结果。 可以看到预测是joy的句子占大多数，原因是训练句子里面joy的比例较大，使得训练集某些句子产生聚集，使得预测句子产生误差。 测试句子的正确率为36.9%，设置的K=34 使用sklearn库 image-20220519101233681 sklearn库测试句子的正确率为37.4%，设置的K=34 自行设计的距离计算（余弦相似度）测试句子的正确率为36.1%，设置的K=34","categories":[],"tags":[{"name":"KNN","slug":"KNN","permalink":"https://klc1006.github.io/tags/KNN/"},{"name":"分类","slug":"分类","permalink":"https://klc1006.github.io/tags/%E5%88%86%E7%B1%BB/"}]},{"title":"【AI Course】朴素贝叶斯","slug":"AI Course 7 203","date":"2023-03-06T11:38:29.637Z","updated":"2023-03-06T11:31:16.062Z","comments":true,"path":"2023/03/06/AI Course 7 203/","link":"","permalink":"https://klc1006.github.io/2023/03/06/AI%20Course%207%20203/","excerpt":"","text":"中山大学计算机学院 人工智能实验报告（七） (2022春季实验报告) 课程名称:Artificial Intelligence 教学班级 专业方向 学号 姓名 计科1班 计算机科学与技术 20337013 陈梁坤 一、实验题目 在给定文本数据集完成文本情感分类训练，在测试集完成测试，计算准确率。 思考：在前面的文本分类算法中，如果测试文本中的单词没有在训练文本中出现会造成什么结果？ 会影响到后验概率的计算结果，使分类产生偏差。解决这一问题的方法是采用贝叶斯估计。具体地，方法为： image-20220511210520596 式中 λ≥0。等价于在随机变量各个取值的频数上赋予一个正数 λ≥0。当 λ=0 时就是极大似然估计。尝取 λ=1，这时称为拉普拉斯平滑 (Laplacian smoothing)。 要求使用拉普拉斯平滑技巧提高准确率 二、实验内容 算法原理 朴素贝叶斯法 思想：朴素贝叶斯假设，又称条件独立性假设 做法：根据贝叶斯定理来估计每个类别的后验概率。 朴素贝叶斯法的目标是找到 image-20220511202930293 image-20220511205602180 image-20220511205530600 image-20220511205640632 关键代码展示 训练数据集 123456789101112131415161718192021222324252627282930emotion=[0,0,0,0,0,0,0]#记录整个训练数据集不同的情感的频数total=[0,0,0,0,0,0,0] #记录每种情感的中不同单词的个数mark=&#123;&#125;dict=[]def trainNB(train_set): global total words=&#123;&#125; with open(&quot;train.txt&quot;,&#x27;r&#x27;) as file: lines=file.readlines()[1:]#读取第二行到最倒数第一行 for sentence in lines: sentence=sentence.split() # sentence[0]：句子编号 sentence[1]：情绪编号 sentence[2]:情绪 sentence[1]=int(sentence[1]) #将情绪变换转成int便于判断 emotion[sentence[1]]+=1 #记录整个训练数据集不同的情感的频数 train_set.append(sentence) #用train_set记录整个训练数据集 for i in range(1,7):# d=&#123;&#125; #记录某一情绪之下，某一个单词出现的频数 for j in range(len(train_set)): #编译整个训练数据集 if(train_set[j][1]==i): for k in range(3,len(train_set[j])): # mark[train_set[j][k]]=0 #记录整个训练数据集的不同单词的个数，总数用于拉普拉斯平滑技巧 total[i]+=1 #记录每一种情感的不同单词的个数 if(train_set[j][k] in d): #单词加入字典便于查找 d[train_set[j][k]]+=1 else: d[train_set[j][k]]=1 dict.append(d #记录每一种情绪的单词频数表 测试数据集 123456789101112131415161718192021222324252627282930313233v=[]#记录测试的出的情感集合def testNB(train_set,test_set): with open(&quot;test.txt&quot;,&#x27;r&#x27;) as file: lines=file.readlines()[1:]#读取第二行到最倒数第一行 for sentence in lines: sentence=sentence.split() sentence[1]=int(sentence[1]) test_set.append(sentence)#读取测试数据集的句子 emo_prossible=1 #标记当前最优可能的情感 max_prob=-1 #最大可能概率 curr_prob=1 #记录档当前情感的概率 correct=0 #记录测试正确的数目 for i in range(len(test_set)): #遍历测试集合，取出句子逐一比对 emo_prossible=1 #初始化当前最优可能的情感 max_prob=-1 #初始化最优可能的情感的概率 for j in range(len(dict)): curr_prob=1 #初始化当前的情感的概率 for k in range(3, len(test_set[i])): #取出测试句子中的每个单词 if(test_set[i][k] in dict[j]): #采用拉普拉斯平滑计算概率 curr_prob*= (dict[j][test_set[i][k]]+alpha)/(total[j+1]+len(mark)*alpha) elif(test_set[i][k] in mark): #如果从测试句子的单词不在当前训练语句里面，采用拉普拉斯平滑避免概率为0 curr_prob*=(alpha)/(total[j+1]+len(mark)*alpha) #设置参数为1 curr_prob*=emotion[j+1]/len(train_set) if(curr_prob&gt;max_prob): #更新最优可能情感的信息 max_prob=curr_prob emo_prossible=j+1 v.append(emo_prossible) #将每句估计的情感保存 if(emo_prossible==test_set[i][1]): correct+=1 #记录正确估计情感的频数 print(correct/len(test_set)) #输出正确率 对比输出 12345678def result_comparison(test_set): print(&quot;assessment fact&quot;) for i in range(len(test_set)): if(v[i]==test_set[i][1]): print(emo[v[i]],test_set[i][2],&quot; &quot;,end=&quot;&quot;) print(&quot;correct&quot;) else: print(emo[v[i]],test_set[i][2]) 三、实验结果及分析 实验结果展示实例 不使用拉普拉斯平滑 设置alpha=0 image-20220511210146496 输出结果 第一列是估计的情感，第二列是实际情感，如果估计正确输出correct 最后一行显示该估计算法的正确率 可以看到当不用拉普拉斯平滑时，正确率只有23.4% 使用拉普拉斯平滑 image-20220511201955088 输出结果 第一列是估计的情感，第二列是实际情感，如果估计正确输出correct 最后一行显示该估计算法的正确率 可以看到当使用拉普拉斯平滑后正确率提高到了38.4%","categories":[],"tags":[{"name":"朴素贝叶斯","slug":"朴素贝叶斯","permalink":"https://klc1006.github.io/tags/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/"}]},{"title":"【AI Course】归结演绎推理","slug":"AI Course 6","date":"2023-03-06T11:38:29.636Z","updated":"2023-03-06T11:38:00.197Z","comments":true,"path":"2023/03/06/AI Course 6/","link":"","permalink":"https://klc1006.github.io/2023/03/06/AI%20Course%206/","excerpt":"","text":"中山大学计算机学院 人工智能实验报告（六） (2022春季实验报告) 课程名称:Artificial Intelligence 教学班级 专业方向 学号 姓名 计科1班 计算机科学与技术 20337013 陈梁坤 一、实验题目 编写程序，实现一阶逻辑归结算法，并用于求解给出的三个逻辑推理问题，要求输出按照如下格式： (P(x),Q(g(x))) (R(a),Q(z),¬P(a)) R1a,2c (Q(g(a)),R(a),Q(z)) “R” 表示归结步骤. “1a” 表示第一个子句(1-th)中的第一个 (a-th)个原子公式，即P(x). “2c”表示第二个子句(1-th)中的第三个 (c-th)个原子公式，即¬P(a). “1a”和“2c”是冲突的，所以应用最小合一{X = a}. 二、实验内容 1.算法原理 归结演绎推理 一种基于逻辑“反证法”的机械化定理证明方法。 基本的方法论是将永真性证明转换为不可满足证明。例如：要证明P→Q 的正确性，即可证明 P ∧ ﹁ Q 为不可满足的 该原理通过检查子句集 S 中是否包含空子句，若包含，则 S 不可满足。 若不包含，在 S 中选择合适的子句进行归结，一旦归结出空子句，就说明 S 是不可满足的。 可以看下面的例子有更加直观的理解 image-20220512165537913 最一般合一 为了解决谓词演算归结，不可避免地需要合一算法参与解决。 置换 定义: 置换是一个形如{t1/v1,…, tn/vn}的有限集,其中每个vi是变量,ti是不同于vi的项（常量、变量或函数）(vi≠ti). 当i≠j时，vi≠vj. 无元素组成的置换称为空置换, 记为ε; 被置换元素必是变量，置换元素是项; 置换元素必不同于被置换元素; 在一次置换中，针对同一元素的置换只能出现一次(单次置换的同时性); 无元素组成的置换，成为空置换; 合一 通过变量置换，使得具有两个相同（或相反）原子公式的子句可以归结，合一也被定义使得两个原子公式等价的一组变量替换/赋值 o由于一阶逻辑中存在变量，所以归结之前需要进行合一，如(P(john),Q(fred),R(x))和(¬P(y),R(susan),R(y))两个子句中，我们无法找到一样的原子及其对应的否定，但是不代表它们不能够归结 o通过将y替换为john，我们得到了(P(john),Q(fred),R(x))和(¬P(john),R(susan),R(john))，此时我们两个子句分别存在原子P(john)和它的否定¬P(john)，可以进行归结 最一般合一 指使得两个原子公式等价，最简单的一组变量替换 具体算法如下 输入两原子公式具有相同谓词，不同的参数项以及\"¬\" k=0,σ0={}，S0={f，g} 如果Sk的公式等价，返回σk作为最一般合一结果 否则找出Sk中的不匹配项Dk={e1,e2}t 如果e1=V是常量，e2=t是一个不包含变量V的项，将V=t添加到赋值集合σk+1=σkU{V=t}；并将Sk中的其他变量也赋值为t，得到Sk+1，k=k+1，转到第二步 否则合一失败 归结 将α取否定，加入到KB当中 将更新的KB转换为clausal form得到S 反复调用单步归结 如果得到空子句，即S|-()，说明KB ∧¬α 不可满足，算法终止，可得KB |= α 如果一直归结直到不产生新的子句，在这个过程中没有得到空子句，则KB |= α不成立 单步归结 使用MGU算法从两个子句中得到相同的原子，及其对应的原子否定 去掉该原子并将两个子句合为一个，加入到S子句集合中 例如(¬Student(x),HardWorker(x))和(HardWorker(sue))合并为(¬Student(sue)) 2.关键代码展示 分解句子 12345678910num = 0clauses = []num=int(input()) #输入子句for i in range(0, num): #分解子句为原子式 clause = [] #将原子式分解成谓词和项 for item in re.findall(r&#x27;¬*[a-zA-Z]+\\([a-zA-Z,\\s]*\\)&#x27;, input()): items = re.findall(r&#x27;[¬a-zA-Z]+&#x27;, item) clause.append(items) clauses.append(clause) 计算一个原子式子里的变量个数 123456def variable_num(item): vari_num=0 for i in range(1,len(item)): #遍历原子式 if(len(item[i])==1): #默认变量的长度都是1 vari_num+=1 #发现存在变量，vari_num++ return vari_num #返回变量总数 查找变量索引 12345def vari_index(item): index=1 while(len(item[index])!=1): #查找到第一个变量，返回索引 index+=1 return index #返回索引 判断原子式是否互补 12345def consistant(item1,item2): #再两个原子式传入之前，已经确定谓词互补 for i in range(1,len(item1)):#遍历，判断置换后的原子式是否一致,如果一致可以归结 if(item1[i]!=item2[i]): return False return True 数据结构 12345match=[] #用于记录匹配过的子句step=[] #用于回溯实用的子句for cnt in range(num): step.append((cnt,cnt,cnt,cnt,cnt,cnt)) #step[匹配子句1，匹配子句2，子句的原子式1，子句的原子式2,变量，替换的常量] 遍历子句（归结判断） 1234567891011121314while(i&lt;len(clauses)-1 ): #i,j用于遍历自己一一进行配对，将每一次的配对检测记录再mark数组中 if(new == []): #如果新归结的子句是[],跳出循环 break for j in range(len(clauses)):#如果新归结的子句是[],跳出循环 if(new == []): break #如果新归结的子句是[],跳出循环 for k in range(len(clauses[i])): #对于每一个子句都取出一个原子式，进行一一匹配 if(new == []): break #如果新归结的子句是[],跳出循环 for l in range(len(clauses[j])): ...... match.append((i,j)) #记录匹配过的子句 合一 123456789if(&#x27;¬&#x27;+clauses[i][k][0]==clauses[j][l][0] or clauses[i][k][0]==&#x27;¬&#x27;+clauses[j][l][0] ):# #判断谓词的互补情况 if((i,j) in match or (j,i) in match or i==j ): #匹配过不再匹配，子句自己不能匹配 continue temp1=copy.deepcopy(clauses[i][:])#记录子句1 temp2=copy.deepcopy(clauses[j][:])#记录子句2 item1=copy.deepcopy(clauses[i][k])#记录子句1中的原子式 item2=copy.deepcopy(clauses[j][l])#记录子句2中的原子式 置换 123456789101112131415161718192021dition=&#123;&#125; #记录需要置换的变量和常量del temp1[k] #删除临时子句中1的对应的可能可以归结的原子式del temp2[l] #删除临时子句中1的对应的可能可以归结的原子式id=vari_index(item2) #记录含有变量的原子式中变量的索引下标dition[item2[id]]=item1[id] #记录需要置换的变量和常量与字典给中，编译查找替换变量var1=item2[id] #记录置换的变量var2=item1[id] #记录置换的常量item2[id]=item1[id] #置换变量和常量for t in range(len(temp2)): #需要替换掉子句中对应的所有变量都置换为常量 for idx in range(1,len(temp2[t])): if(temp2[t][idx] in dition): temp2[t][idx]=dition[temp2[t][idx]] #使用字典便于置换if(consistant(item1,item2)): #判断置换后置换后的原子式是否一致，如果一致，则满足归结条件，以下进行归结 new=temp1+temp2 #保存归结后的子句 match.append((i,len(clauses)))#记录新产生的子句有哪两个子句归结生成，不在进行归结，使得子句不会变得归于复杂 match.append((j,len(clauses)))#记录新产生的子句有哪两个子句归结生成，不在进行归结，使得子句不会变得归于复杂 step.append((i,j,k,l,var1,var2))#记录每个子句由那两个子句，那两个原子式生成，保存置换情况 clauses.append(new) 输出步骤 12345678910111213141516171819202122232425262728293031323334353637383940explored=[] #记录输出过的子句，避免重复输出step_num=num-1 #记录目前输出的子句编号def print_step(n): #递归回溯 global step_num if(n&lt;num):return #当搜索子句序号小于起始子句总数时，返回 print_step(step[n][0]) #递归搜索&quot;父母子句&quot; print_step(step[n][1]) #递归搜索&quot;父母子句&quot; if( clauses[n] in explored ):return #避免重复输出子句 step_num+=1 d[n]=step_num #记录子句输出编号 #step[匹配子句1，匹配子句2，子句的原子式1，子句的原子式2,变量，替换的常量] #输出子句 print(&quot;R[&quot;+str(d[step[n][0]]+1),end=&quot;&quot;) if(len(clauses[step[n][0]])!=1): #匹配子句1不止一个原子式 print(chr(step[n][2]+97),end=&quot;&quot;) print(&quot;,&quot;+str(d[step[n][1]]+1),end=&quot;&quot;) if(len(clauses[step[n][1]])!=1): #匹配子句2不止一个原子式 print(chr(step[n][3]+97),end=&quot;&quot;) if(len(step[n])==6): #子句合一存在置换操作，输出置换操作 print(&quot;](&quot;+str(step[n][4])+&quot;=&quot;+str(step[n][5])+&quot;) = &quot;,end=&quot;&quot;) else: print(&quot;R[&quot;+str(d[step[n][0]]+1)+chr(step[n][2]+97)+&quot;,&quot;+str(d[step[n][1]]+1)+chr(step[n][3]+97)+&quot;] = &quot;,end=&quot;&quot;) if(len(clauses[n])==0):print(&quot;[]&quot;) #输出合一后的子句 for i in range(len(clauses[n])): for j in range(len(clauses[n][i])): if(j==0): print(str(clauses[n][i][j])+&quot;(&quot;,end=&quot;&quot;) elif(j==len(clauses[n][i])-1): print(str(clauses[n][i][j])+&quot;)&quot;,end=&quot;&quot;) else: print(str(clauses[n][i][j])+&quot;,&quot;,end=&quot;&quot;) if(i!=len(clauses[n])-1):print(&quot;,&quot;,end=&quot;&quot;) else:print(&quot; &quot;) explored.append(clauses[n]) #把输出过的子句加入explored数组，避免重复输出 3.创新点&amp;优化 1match=[] #用于记录匹配过的子句 加入match数组以避免相同的子句进行归结，减少探索子句。 样例3：3' blocks 优化前 优化后 优化结果表明探索的语句从71句降到了15局，明显减少了探索语句，提高时间效率，很好地解决了重复探索的问题 样例4：自测 优化前 优化后 可以看到优化前后探索子句数量有明显差异，去重方法能够减少探索子句数量，提高算法效率。 三、实验结果及分析 1.实验结果展示实例 样例1：AIpine Club 12345678910111213###### input for AIpine Club ######A(tony)A(mike)A(john)L(tony, rain)L(tony, snow)(¬A(x), S(x), C(x))(¬C(y), ¬L(y, rain))(L(z, snow), ¬S(z))(¬L(tony, u), ¬L(mike, u))(L(tony, v), L(mike, v))(¬A(w), ¬C(w), S(w))################################### 参考结果 实验结果 实验结果比参考结果的归结语句多了一句，实际上是由于遍历顺序导致的，遍历的顺序不同，导致首先产生归结语句也所不同 样例2：hardworker(sue) 123456#### input for hardworker(sue) #### GradStudent(sue) (¬GradStudent(x), Student(x)) (¬Student(x), HardWorker(x)) ¬HardWorker(sue)################################### 参考结果 实验结果 实验结果的归结语句与参考的结果一致，但是归结的句子有所不同，遍历的顺序不同，导致首先产生归结语句也所不同。 样例3：3' blocks 1234567####### input for 3&#x27; blocks ####### On(aa,bb) On(bb,cc) Green(aa) ¬Green(cc) (¬On(x,y), ¬Green(x), Green(y))################################### 参考结果 实验结果 实验结果的归结语句与参考的结果一致，但是归结的句子有所不同，遍历的顺序不同，导致首先产生归结语句也所不同。 样例4：自测 12345T(Wang,Li)C(Li,Zhang)¬ANSWER(Wang)(¬C(Li,y),¬T(z,Li),T(z,y))(¬T(u,Zhang),ANSWER(Wang)) image-20220427175024500 由自测结果表明设计的算法能够归结成功 样例5：自测（归结演绎） 1234T(Wang,Li)C(Li,Zhang)(¬C(Li,y),¬T(z,Li),T(z,y))(¬T(u,Zhang),ANSWER(Wang)) image-20220428150059648 按照自测的归结演绎，成功归结出ANSWER(Wang) 2.指标展示和分析 样例1：AIpine Club image-20220428131323571 探索子句总共产生620句，与优化前的结果相当，此处不在作展示 样例2：hardworker(sue) image-20220428142403308 探索子句总共产生10句，与优化前的结果相当，此处不在作展示 样例3：3' blocks image-20220428142414371 探索子句总共产生15句，相比优化前的探索语句（71句）有所提升 样例4：自测 image-20220428142423200 探索子句总共产生14，相比优化前的探索语句（22句）有所提升 四、总结 本次归结算法设计存储子句，合一操作，置换操作，归结操作。 存储子句需要将原子式分离谓词以及项 置换操作需要判断原子式中变量和常量之间的关系，才有利于程序更加有条理地执行 合一操作在置换操作下进行，判断两个原子式互补即可进行合一 归结操作输出合一后产生的子句，该子句可用于新的归结操作 以上算法通过全局遍历，寻找可归结的子句，在子句较多时能够快速等到归结方案。 五、参考资料 无","categories":[],"tags":[{"name":"归结推理","slug":"归结推理","permalink":"https://klc1006.github.io/tags/%E5%BD%92%E7%BB%93%E6%8E%A8%E7%90%86/"}]},{"title":"【AI Course】一致代价实现最短路径","slug":"AI course 1_20337013","date":"2023-03-06T11:38:29.634Z","updated":"2023-03-06T11:37:44.420Z","comments":true,"path":"2023/03/06/AI course 1_20337013/","link":"","permalink":"https://klc1006.github.io/2023/03/06/AI%20course%201_20337013/","excerpt":"","text":"AI course LabsWeek2 一、实验目的 一致代价搜索（带环检测）实现最小代价路径查找 image-20220302092206013 image-20220302092250062 二、实验原理 ​ 一致代价搜索是在广度优先搜索上进行扩展的，也被成为代价一致搜索，他的基本原理是：一致代价搜索总是扩展路径消耗最小的节点N。N点的路径消耗等于前一节点N-1的路径消耗加上N-1到N节点的路径消耗。 ​ 图的一致性代价搜索使用了优先级队列并在边缘中的状态发现更小代价的路径时引入的额外的检查。边缘的数据结构需要支持有效的成员校测，这样它就结合了优先级队列和哈希表的能力。 流程分析： 1.如果边缘为空，则返回失败。操作：EMPTY?(frontier) 2.否则从边缘中选择一个叶子节点。操作：POP(frontier) 3.目标测试：通过返回，否则将叶子节点的状态放在探索集 4.遍历叶子节点的所有动作 每个动作产生子节点 如果子节点的状态不在探索集或者边缘，则插入到边缘集合。操作：INSERT(child, frontier) 否则如果边缘集合中如果存在此状态且有更高的路径消耗，则用子节点替代边缘集合中的状态 三、实验过程 关键代码 数据输入： 123456789101112131415161718192021222324252627def create_adjList(edgeSet): #建立邻接表 temp=input().split() #输入地图的顶点个数和边的个数 v=int(temp[0]) #将以串类型输入顶点个数强制类型转换为int类型数据 e=int(temp[1]) #将以串类型输入边的个数强制类型转换为int类型数据 for i in range(e): #遍历每一条边 edge=input().split() #定义edge成分为（edge[0]前驱/后继，edge[1]后继/前驱，edge[2]代价） edge[2]=int(edge[2]) #将以串类型输入边的权重强制类型转换为int类型数据 if edge[0] in edgeSet : edgeSet[edge[0]].append((edge[1],edge[2])) #如果已对该顶点建立邻接表信息，在其后面追加与其他顶点建立邻接关系的信息 else: edgeSet[edge[0]]=[(edge[1],edge[2])] #如果未对该顶点建立邻接表信息，新定义该顶点的邻接关系 if edge[1] in edgeSet: #默认建立的是无向图，需要对后继顶点做上述同样的操作，从而建立双向的邻接表 edgeSet[edge[1]].append((edge[0],edge[2])) #如果已对该顶点建立邻接表信息，在其后面追加与其他顶点建立邻接关系的信息 else: edgeSet[edge[1]]=[(edge[0],edge[2])] #如果未对该顶点建立邻接表信息，新定义该顶点的邻接关系 路径查找： 1234567891011121314151617181920212223242526272829303132def find_path(start,end,visit,path): #采用一致代价搜索以及环检测查找最短路径 q=PriorityQueue() #使用优先队列，每一次取积累代价最小的顶点做拓展，从而遍历顶点，直到寻找到目标定点 q.put((0,start,&#x27;0&#x27;)) #队列中元素的组成为（[0]积累代价，[1]当前出队顶点，[2]出队顶点的前驱） PS:&#x27;0&#x27; 用于标记起始点，方便后续遍历输出路径 print(&quot;出队遍历顺序：&quot;,end=&quot;&quot;) while(not q.empty()): #跳出循环的条件：优先队列非空。若优先队列已空，则起始点所处的连通分量里面的所有顶点遍历完毕 temp=q.get() print(temp[1],end=&quot;→&quot;) if visit.count(temp[1])!=0: continue #已经出过队的顶点相当于已经找到起点到该顶点的最小值，不再加入path else: #将最小代价顶点出队，temp成分为（temp[0]积累代价，temp[1]当前出队顶点，temp[2]出队顶点的前驱） path[temp[1]]=temp[2] #保存出队顶点的的前驱，以便查找成功在输出路径，path成份（path[0]出队顶点，path[1]出队顶点的前驱） visit.append(temp[1]) #保存出队结点，用于环检测 if temp[1]==end: minCost=temp[0] #找到目标节点后，保存最小代价并返回 return minCost else: for edge in edgeSet[temp[1]]: #遍历出队顶点的邻接顶点 if visit.count(edge[0])==0: q.put((temp[0]+edge[1],edge[0],temp[1])) #如果邻接顶点没有被探索过，按（积累代价，当前出队顶点，出队顶点的前驱）结构入队 return -1 #如果没有查找成功，返回-1 实现功能 1.查找起点到终点的最小代价路径 2.判断输入的起点终点是否在讨论顶点范围内 3.判断输入的起点终点是否在同一连通分量当中 四、实验结果 case1 image-20220302150653541 分析解释： 一致代价搜索（带环检测），若出队元素已经加入过进path里面，不在对其延拓，且不再加入path数组 图中出队遍历顺序包含不加入path数组的顶点元素 由a→z的代价最小路径为a→b→e→d→z，最小代价为7 case2 image-20220302092735025 case3 image-20220302092756474 case4 image-20220302092551253 case5（查找失败） image-20220302092825714 分析解释： 遍历完a顶点所处连通分量的其余顶点后，没有发现e顶点，输出查找失败fail case6（查找失败） image-20220302093117532 分析解释： 遍历完a顶点所处连通分量的其余顶点后，没有发现e顶点，输出查找失败fail case7（查找失败） image-20220302153710558 分析解释： 发现f顶点并没有在集合edgeSet当中，即讨论的地图不包括f顶点输出查找失败fail","categories":[],"tags":[{"name":"AI","slug":"AI","permalink":"https://klc1006.github.io/tags/AI/"},{"name":"最短路径","slug":"最短路径","permalink":"https://klc1006.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"}]},{"title":"【论文调研】CONVERGING TO UNEXPLOITABLE POLICIES IN CONTINUOUS CONTROL ADVERSARIAL GAMES 笔记","slug":"AdaptiveFSP笔记","date":"2023-03-06T08:34:34.726Z","updated":"2023-03-06T09:24:57.379Z","comments":true,"path":"2023/03/06/AdaptiveFSP笔记/","link":"","permalink":"https://klc1006.github.io/2023/03/06/AdaptiveFSP%E7%AC%94%E8%AE%B0/","excerpt":"Adaptive FSP","text":"Adaptive FSP 名词解释 元策略（meta-strategies）：提出基于复杂的原博弈得到一个规模小得多的经验博弈 empirical game/meta game，通过对经验博弈的推理(meta-reasoning)得到的元策略(meta-strategies)，依托这些信息指导在原策略空间中寻找新的策略，同时使逼近可能的原博弈的均衡解。对于任意联合策略的期望收益，通过适当的方法进行估计并记录在经验收益矩阵 empirical payoff table中 混合nash均衡 image-20230128201928792 主要思想：不仅针对meta policy训练，还针对能够适应BR的adaptive deep RL agent进行训练。 Introduce CFR 主要限制是不清楚如何将其扩展到连续动作空间 FSP：简单地扩展到连续动作空间，FSP是一种求解两人零和（2p0s）博弈的迭代算法（每次迭代都可以查看） 在每次迭代中，每个玩家都会计算出对对手元策略的最佳响应 在普通FSP中，元策略是在先前迭代中计算的所有策略的统一平均值（在迭代k上，它是从迭代1到k−1的所有策略统一平均值） FSP被保证最终收敛到纳什均衡，在纳什均衡中，两个参与者的元策略都是对另一个的最优响应 vanilla FSP的局限性：学习对具有深度RL的元策略的最佳响应可能导致对元策略策略的过度拟合，从而减缓向低可利用性策略的收敛。 （ For example, in a game of soccer the kicker might adversarially figure out how to move in such a way that the population of previous goalie policies has not seen before, causing degenerate behavior (Gleave et al., 2019).） 主要贡献： Adapt FSP增强了迭代k中玩家的元策略，自适应对手主动更新其策略以应对最佳响应。自适应对手充当正则化因子regularizer ，减少对先前策略群体（population of policies）的过度拟合。 步骤 首先证明了AdaptFSP属于一类被称为广义弱化虚拟博弈（GWFP）的算法，所有这些算法都可证明在2p0s博弈中收敛到纳什均衡。 在四个表格和连续博弈中评估AdaptFSP 引入了部分可观测性：将对手的观测延迟十倍 AdaptFSP相较于生成的策略更健壮，可利用性更低，。 AdaptFSP produces policies that are more robust and less exploitable than FSP in these settings Related work fully observable 2p0s games：必须执行连续控制（agents have to perform continuous control） （Bansal et al. (2017) study fully observable 2p0s games in which the agents have to perform continuous control. ） 方法：（对手抽样） opponent sampling：当训练策略时，对手的行为从过去策略的缓冲区中采样。他们没有保留所有策略，而是使用过去策略的滑动窗口（sliding window）。 缺陷：they do not study the exploitability（可利用性） of their learned agents. the question of meta learning in two-player competitive continuous control tasks. 两人竞争性连续控制任务中的元学习问题。 （Al-Shedivat et al. (2017) study the question of meta learning in two-player competitive continuous control tasks.） 实验结果：元学习智能体表现最好Two players play several rounds against each other, and they show that the meta-learning agent performs the best out of several candidate algorithms. 特点（缺陷）：实验环境是完全可观测的，在完全可观察环境中收敛到最优策略的许多算法在部分可观察环境下不保持该特性。 本文实验会会引入部分可观测性 NFSP (Heinrich and Silver, 2016) 使用深度强化学习，从自博弈中学习到2p0s不完美信息博弈中的纳什均衡。 使用深度神经网络来近似平均策略，并使用深度神经网来学习具有RL式奖励的策略，但仅在具有小动作空间的游戏中有效。 足球比赛：球员团队可以在足球比赛中相互竞争 （Liu et al. (2019) introduce the MuJoCo Soccer domain where teams of players can compete against each other in a soccer match.） 去中心化基于种群的训练（decentralized population-based training）表现出合作和可利用性的能力 实验结果：在20分钟内收敛到纳什均衡，但是该足球环境是完全可观察的observable 最大限度地实现信息理论目标，以学习可推广到下游任务的各种技能。 （ysenbach et al. (2018) show they can maximize an information theoretic objective to learn a diverse set of skills that are generalizable to downstream tasks.） 提出了一种基于原型表示的学习不同技能的自我监督方法，该技术对下游任务具有很强的泛化能力（Yarats et al. (2021) present a self-supervised technique for learning different skills based on prototypical representations that shows strong generalization to downstream tasks.） POMDP（部分可观测马尔可夫决策过程）背景下RL的泛化 （Ghosh et al. (2021) study generalization in RL in the context of POMDPs (Partially Observable Markov Decision Process) and show classic RL algorithms do not perform as well in POMDPs as in MDPs.） 验证结果：经典RL算法在POMDP中的表现不如MDP，提出了一种基于集成的方法，并表明它比普通RL更有效地泛化（即解决POMDP）。这不直接适用于2p0s博弈，并且需要为每个agent训练N个策略 本文只需要为每个agent提供两个策略。 BACKGROUND AND NOTATION PPO image-20230128165027876 SAC an off-policy actor-critic algorithm, meaning it uses a buffer of past data to continually update its actor and critic functions image-20230128165346449 image-20230128165410762 image-20230128165310568 SAC updates a replay buffer D by collecting trajectories and performs gradient descent using ADAM on these objective functions NORMAL FORM GAMES a 2p0s game that can be specified by a matrix P ∈ R m×n. Each row in the matrix corresponds to an action of player 1 and each column corresponds to an action of player 2. The entry Pij specifies the payoff if player 1 plays i and player 2 plays j. image-20230128164554920 policy profile \\(\\pi=(\\pi^1,\\pi^2)\\)定义为\\(u^1(\\pi^1,\\pi^2)\\),2p0s:\\(u^1(\\pi^1,\\pi^2)=-u^2(\\pi^1,\\pi^2)\\) 定义best response \\(BR(\\pi^i)\\in \\arg \\max_{\\pi^{-i}}u(\\pi^{-i},\\pi^{i})\\) 定义exploitability .The exploitability of a policy \\(π^1\\) is defined to be how much worse the policy does against \\(BR(π^1 )\\) compared to how a Nash equilibrium strategy \\(π^1_∗\\) does against \\(BR(π^1_∗ )\\), image-20230128171006235 \\(\\epsilon-BR\\) a policy \\(π^2\\) is an ϵ-best response to \\(π^1\\) image-20230128171232225 FP choose a uniform policy\\(\\beta_u^1,\\beta_u^2\\) initialize their average policy to this uniform policy \\(\\pi^1=\\beta_u^1,\\pi^2=\\beta_u^2\\) agent computes a best response to the opponent’s average policy\\(\\beta^p_t=\\arg\\max_{\\beta^p}(\\beta^P,\\pi^{-p}_{t-1})\\) update their average policy\\(\\pi_t^p=\\frac{t-1}{t}\\pi^p_{t-1}+\\frac{1}{t}\\beta^p_t\\) 注意这里使用优化后的average policy\\(\\pi_t^p=\\frac{t-1}{t+1}\\pi^p_{t-1}+\\frac{2}{t+1}\\beta^p_t\\) image-20230122015608822 EXACT CASE 算法提出需要保证计算精确最佳响应 运行N次迭代（或直到收敛） 不是计算对手元策略的最佳响应，而是计算元策略和正则策略的线性组合的最佳响应。 假设进行到AdaptFP的第i次迭代，我们为每个玩家都有元策略\\(\\pi^1_i,\\pi^2_i\\) 将正则化策略初始化为空策略，并且在内部循环的每个迭代j中，我们计算 image-20230128182435540 其中 image-20230128182551501 从玩家1的角度来看（对玩家2来说是对称的），玩家2的内循环是对抗性地找到对对手的最佳响应，玩家1必须学习对adaptable的对手的最佳响应。（From player 1’s perspective (it is symmetric for player 2), the inner loop for player 2 is adversarially finding a best response to the opponent’s, and player 1 must learn a best response to an opponent that is allowed to adapt.） 在内部循环的末尾，将最新的最佳响应添加到元策略中。纯粹基于迭代来比较可利用性是不公平的，因为在自适应情况下，我们计算的最佳响应比在非自适应情况下多得多。因此，在的图中，我们显示了基于为每个玩家计算的最佳响应总数的结果。 证明AFP能够在2p0s问题上收敛至nash均衡 image-20230128183151531 image-20230122015523809 approximate case 近似的情况是类似的，但不使用一个内部循环寻找最佳响应，我们只是在近似player1的最佳对策的过程中不断训练player2的regularizer agent。在每次迭代\\(i\\)中，我们为玩家\\(p\\)训练一个策略\\(\\beta_i^p\\)，正则化因子（ regularizer）\\(\\pi_r^p\\)也是如此，该因子在每次迭代中会重新初始化。该策略使用强化学习算法（例如PPO或者SAC）进行训练，不受\\(\\beta_i^{-p}\\)约束, 在训练中，对手的行为是抽样前i个最佳对策\\(\\beta_i^p,...,\\beta_i^p\\)的平均值，也是如此正则化因子\\(\\pi_r^p\\)。 策略平均操作 DREAM (Steinberger et al., 2020) 在每episode开始时，我们根据权重从一组策略中采样一个策略，并使用该策略运行整个episode image-20230122024942411 Result image-20230128200128836 image-20230128200402443 image-20230128200306828 SAC的训练效率最高，观察包括agent当前位置、相对于球的位置、相对于球门的位置和对手位置的数据。我们通过将对手状态的观察滞后10个时间步，将不完美的信息引入游戏。 image-20230128200416845 image-20230128200445685 使用PPO强化学习算法，因为它在这种环境中最有效。观察结果包括关于agent当前位置以及对方agent的数据。为了在比赛中引入不完美的信息，对手的代理人落后10时间步长。在每episode开始时，我们根据给定的权重从集合中抽取一个策略，并在整个episode中使用该策略。我们在最佳响应的整个培训过程中重复该过程，这确保了策略的训练是与平均策略相比进行训练。 总结展望 在未来，仍有许多工作要开发鲁棒算法来解决连续控制博弈。这种类型的游戏非常重要，因为许多现实世界应用程序都涉及连续的动作空间，包括世界上涉及机器人的应用程序。虽然这项工作侧重于两人零和游戏，但我们认为这只是开发能够在真实世界交互中更广泛有效地发挥作用的代理的第一步。下一步是走向更复杂的连续状态和行动空间环境，包括同时涉及合作和竞争的环境。","categories":[],"tags":[{"name":"论文调研","slug":"论文调研","permalink":"https://klc1006.github.io/tags/%E8%AE%BA%E6%96%87%E8%B0%83%E7%A0%94/"},{"name":"FSP","slug":"FSP","permalink":"https://klc1006.github.io/tags/FSP/"}]},{"title":"【论文调研】Correlated Q-Learning笔记","slug":"Correlated Q-Learning","date":"2023-03-06T08:34:34.725Z","updated":"2023-03-06T09:17:02.996Z","comments":true,"path":"2023/03/06/Correlated Q-Learning/","link":"","permalink":"https://klc1006.github.io/2023/03/06/Correlated%20Q-Learning/","excerpt":"实验风向：设计多智能体Q学习算法来学习一般和马尔可夫博弈中的均衡策略 相关Qlearning：一种基于相关平衡解概念的算法 实验结果：相关Q学习优于纳什Q学习 相关Q在一般和（general sum）博弈中推广了纳什Q，因为相关均衡集包含纳什均衡集。相关Q也推广了 零和博弈，纳什均衡集和极小极大均衡集重合。","text":"实验风向：设计多智能体Q学习算法来学习一般和马尔可夫博弈中的均衡策略 相关Qlearning：一种基于相关平衡解概念的算法 实验结果：相关Q学习优于纳什Q学习 相关Q在一般和（general sum）博弈中推广了纳什Q，因为相关均衡集包含纳什均衡集。相关Q也推广了 零和博弈，纳什均衡集和极小极大均衡集重合。 一些便于理解相关均衡的例子： 交通信号。对于在交叉口相遇的两个agent，交通信号转换为概率为p的联合概率分布（stop，go）和概率为1−p的（go，stop）。没有为（go，go）或（stop，stop）分配概率质量。给出红色信号的agent的最佳行动是停止，而给出绿色信号的agent最佳行动是离开。 困难点：在一般和单次博弈中，存在具有多个值的多个均衡 解决：引入相关Q四种变量解决均衡选择问题 四种变量：功利、平等、财阀和独裁（utilitarian, egalitarian, plutocratic, and dictatorial） overview 本文组织如下。 一次性博弈中相关均衡的定义以及Marko博弈中相关平衡策略的定义。 在第3节中，我们定义了两种版本的多智能体Q-学习，一种是集中式的，另一种是分散式的，我们展示了相关-Q、Nash-Q和FF-Q是如何作为这些通用算法的特例出现的。 在第4节中，我们包括了零和和共同利益马尔可夫博弈的理论讨论，其中我们证明了相关Q学习的某些变体保证收敛到平稳均衡策略。 在第6节中，我们描述了将功利主义、平等主义、财阀主义和独裁相关的Q学习与Q学习、FF-Q和Nash-Q的两个变体进行比较的模拟实验 实验比较 使用各种多智能体Q学习算法进行的实验，其中包括三个网格游戏和网格足球，以及一组随机生成的游戏 我们四分之三的相关Q学习实现是集中的：功利的、平等的和财阀的。（ utilitarian, egalitarian, and plutocratic） 只有独裁（dictatorial）的变体是分散的：（每一个特工都像独裁者一样学习。） 网格游戏 image-20230226175032428 reward： 在GG1中，有两个不同的目标，每个目标值100分。在GG2中，有一个值100分的目标和两个障碍：如果一个代理人试图通过其中一个障碍，那么这一行动失败的概率为1/2。在GG3中，与GG2一样，有一个目标值100分，但没有随机过渡，奖励结构也不同：在开始时，如果两个代理都通过向上移动来避开中心状态，则每个代理将获得20分的奖励；此外，任何选择中心状态的代理都将获得25分的奖励（注：如果两个代理都选择中心状态，则会发生冲突，每个代理都会获得−25=25−50）。 平衡策略 探讨Q-learning学了什么： Q学习不会收敛，也不会学习均衡政策； 敌友Q学习趋同，但无需学习均衡政策； NE-Q的两个变体和CE-Q的所有四个变体学习均衡策略。 image-20230226175852687 测试阶段：反复进行网格游戏。显示了\\(10^4\\)次移动的平均得分。比赛的次数因agent的政策而异：有时agent直接向球门移动。 对于每个学习算法， 收敛性:表示Q值是否收敛； 平衡值:说明任何收敛Q值是否对应于均衡策略； 平衡游戏:说明测试期间的游戏轨迹是否符合平衡策略。 足球游戏 image-20230226181301477 圆圈代表球。如果玩家A移动W，他将失去球给球员B；但如果球员B移动E，试图偷球。 image-20230226183053723 基本Q-learning缺点：2p0s multiple Q-learners 没有达到收敛 在表4中，我们展示了这场足球比赛测试阶段的结果。 除Q学习者外，所有玩家都玩“好”游戏，这意味着每个玩家赢得的游戏数量大致相同；因此，分数接近0，0。 Friend-Q倾向于让对方快速获胜（观察比赛的数量），并且只因为格子足球的对称性，所以踢出了一场“好”的比赛。 总之，在网格足球这一双人零和马尔可夫博弈中，Q学习并不收敛。直观地说，这一结果的基本原理是明确的：Q学习寻求确定性最优策略，但在这个游戏中不存在这种策略。相关Q学习，如纳什Q学习，学习与foe-Q学习相同的Q值。然而，correlated-Q学习可能相关的均衡策略，而foe-Q和Nash-Q学习最小-最大均衡策略。","categories":[],"tags":[]},{"title":"【论文调研】DeepStack:Expert-Level Artificial Intelligence in Heads-Up No-Limit Poker 笔记","slug":"DeepStack笔记","date":"2023-03-06T08:34:34.723Z","updated":"2023-03-06T09:11:10.263Z","comments":true,"path":"2023/03/06/DeepStack笔记/","link":"","permalink":"https://klc1006.github.io/2023/03/06/DeepStack%E7%AC%94%E8%AE%B0/","excerpt":"发表日期: 2017 机构: Alberta University 核心算法：公共树博弈建模+限制深度持续重新求解+深度反事实价值网络+CFR-D算法+范围（range）","text":"发表日期: 2017 机构: Alberta University 核心算法：公共树博弈建模+限制深度持续重新求解+深度反事实价值网络+CFR-D算法+范围（range） HUNL使用的公共树 游戏状态： 私人信息： 两张牌面朝下： 公共状态：包括面朝上放在桌子上的牌和下注顺序玩家的动作。（公共状态的可能序列形成公共树，每个公共状态都有一个关联的公共子树） 可利用性：预期效用与最佳反应对手之间的差异，以及纳什均衡下的预期效用。 匈牙利公共树的一部分。 节点表示公共状态，而边缘表示动作：红色和绿色表示玩家下注动作，绿色表示偶然出现的公共卡。 游戏在终端节点结束，显示为具有关联值的筹码。 对于没有玩家折叠的终端节点，其私人卡形成更强的扑克手的玩家接收状态值。 Deepstack 三个要素： 针对当前公共状态的完善的局部策略计算 用学习值函数避免推理到游戏结束的深度受限前瞻 一组受限的前瞻动作 image-20230217112502369 Continual re-solving 根据特定的解决策略采取了行动，但在某些公共状态下，忘记了这一策略。我们重新构建解决方案策略而不必再次求解整个游戏. 在比赛开始时，我们的范围是统一的，对手的反事实值被初始化为每一手私人牌的处理值。 当轮到我们采取行动时，我们使用存储的范围和对手值重新求解当前公共状态下的子树，并根据计算出的策略采取行动，在我们再次采取行动之前丢弃该策略。在每一个动作之后，无论是由玩家还是偶然发牌，我们都会更新我们的范围和对手的反事实值 根据以下规则： （i）自己的行动：将对手的反事实值替换为我们选择的行动的重新解决策略中计算的值。使用计算策略和贝叶斯规则更新我们自己的范围。 （ii）机会行动：将对手的反事实值替换为从上次重新求解中为该机会行动计算的值。更新我们自己的范围，将手放在给定新公共卡不可能的范围内。 （iii）对手行动：不需要改变我们的范围或对手的值。这些更新确保对手的反事实值满足我们的充分条件，并且整个过程产生纳什均衡的任意接近近似值 这些更新确保对手的反事实值满足我们的充分条件，并且整个过程产生纳什均衡的任意接近近似 该算法高效并避免对动作抽象方法所需的转换步骤的任何需要： 永远不会跟踪对手的范围，而只跟踪他们的反事实值。 不需要了解对手的行动来更新这些值（与传统的re-solvnig是一个重要区别） Limited depth lookahead via intuition. Input：就是对扑克游戏的描述：被发到个人手中的概率分布、游戏的赌注以及任何公开的牌 Output：对在这种游戏中持有某些牌的价值的估计。价值函数是一种直觉，是对 在任意扑克情境中发现自己的价值。在深度限制为四个动作的情况下，该方法将重新求解的游戏大小从开始时的\\(10^{160}\\)个决策点减少到比赛得分降至不超过\\(10^{17}\\)分。 Sound reasoning. DeepStack的深度有限的持续重新解决是合理的。如果DeepStack的直觉是“好的”，并且在每一个re-solving步骤中都使用了“足够的”计算，那么DeepStac将任意接近纳什均衡。 Relationship to heuristic search in perfect information games. 第一，如果不知道参与者如何以及为什么要达到公共状态，就无法对公共状态进行合理的重新解决。相反，必须保持两个额外的向量，即agent的范围和对手的反事实值，以用于重新求解。 第二，重新求解是一个迭代过程，它多次遍历前瞻树，而不是只遍历一次。每次迭代都需要再次查询评估函数，对于超出深度限制的每个公共状态，其范围都不同。 第三，达到深度极限时所需的评估函数在概念上比完美信息设置中更复杂。反实际值函数需要返回给定公共状态和玩家范围的值向量，而不是在游戏中给定单个状态时返回单个值。由于这种复杂性，为了学习这样的价值函数，我们使用了深度学习，这也成功地在完美的信息游戏中学习了复杂的评估函数 Relationship to abstraction-based approaches DeepStack限制其前瞻树中的动作数量，这与动作抽象非常相似。然而，DeepStack中的每一次重新解决都是从实际的公共状态开始的，因此它总是完全不了解当前的情况。该算法也从不需要使用对手的实际动作来获得正确的范围或对手的反事实值，从而避免对手下注的转换。 Overview image-20230217151735867 A. DeepStack在公共树中的推理总是为它在公共状态下可以持有的所有卡牌产生动作概率。它在游戏中保持着两个向量：它自己的范围（range）和它的对手的反事实值。随着游戏的进行，它自己的范围会在它执行完一个动作后通过贝叶斯规则使用它计算出的动作概率进行更新；对手的反事实值在“持续重新求解”中进行了更新。为了计算它必须行动时的动作概率，它使用它的范围和对手的反事实值来执行一个重新求解。为了使重新求解易于处理，它限制了玩家的可用动作，并且前瞻（lookahead）被限制在本回合结束。在重新求解过程中，使用DeepStack的已经学习的评估函数来近似公共状态的反事实值。 B. 评估函数用一个神经网络表示，该神经网络将公共状态和当前迭代的范围作为输入，输出两个玩家的反事实值（图3）。 C. 神经网络在玩游戏之前进行训练，通过生成随机的扑克情境（奖池大小、公共卡牌和玩家范围）并求解它们来生成训练例子。 Deep Counterfactual Value Networks image-20230217152502421 网络的输入是奖池大小、公共卡牌和玩家范围，它们首先被处理成手牌聚类。对7个全连接的隐藏层的输出进行后处理，以保证这些值满足零和约束，然后映射回一个反事实值的向量。 伪代码 DeepStack的限制深度持续重新求解算法的完整伪代码在算法S1中。从概念上讲，DeepStack算法可以分解为四个函数：RE-SOLVE, VALUES, UPDATE_SUBTREE_STRATEGIES和RANGE_GADGET。主要函数是RE-SOLVE，每次DeepStack需要执行动作时都会调用它。它迭代地调用其他函数来细化前瞻树的解。经过T轮迭代后，从要执行动作的子树的根结点处的近似均衡策略中采样一个动作。根据这一动作，DeepStack的范围\\(\\vec{v_1}\\)及其对手的反事实值 \\(\\vec{v_2}\\) 被更新，为下一个决策点做准备。 img img img","categories":[],"tags":[]},{"title":"【论文调研】Fictitious Self-Play in Extensive-Form Games 笔记","slug":"Fictitious Self-Play in Extensive-Form Games笔记","date":"2023-03-06T08:34:34.709Z","updated":"2023-03-06T09:17:33.053Z","comments":true,"path":"2023/03/06/Fictitious Self-Play in Extensive-Form Games笔记/","link":"","permalink":"https://klc1006.github.io/2023/03/06/Fictitious%20Self-Play%20in%20Extensive-Form%20Games%E7%AC%94%E8%AE%B0/","excerpt":"参考链接：https://zhuanlan.zhihu.com/p/38168216","text":"参考链接：https://zhuanlan.zhihu.com/p/38168216 Fictitious play（FP） 每个玩家在自我对局中保持两个策略：平均策略（average strategies）和最优反应策略（best response) ，每个玩家在对局中不断的采取对对手平均策略最优反应策略 best response：在对手策略固定的情形下，能够获得最大收益的策略 Extensive-Form Fictitious Play 一下公式展示这是如何通过加权组合其实现等效的行为策略来实现正常形式策略的混合 image-20230123021039239 Extensive-Form Fictitious Play： image-20230123021252113 image-20230123020931325 首先，它计算当前平均策略的最佳响应曲线。其次，它使用最佳响应曲线来更新平均策略曲线。第一个操作的假定要求在博弈状态的数量上是线性的。对于每个玩家，第二个操作可以独立于他们的对手执行，并且需要在玩家的信息状态的数量中进行线性工作。此外，如果使用确定性最佳响应，定理7的实现权重允许忽略玩家决策节点上除一个子树之外的所有子树。 Fictitious Self-Play FSP是一个机器学习框架，它以基于样本的方式和行为策略实现了广义的弱化虚拟游戏。XFP的维数很低。在每次迭代中，无论其相关性如何，都需要在游戏的所有状态下执行计算。然而，广义的弱化虚拟游戏只需要近似的最佳响应，甚至允许更新中出现一些扰动 FSP用机器学习算法代替了两种虚拟游戏操作，即最佳响应计算和平均策略更新。通过强化学习，从对手的平均策略中学习近似的最佳反应。平均策略更新可以被制定为一个有监督的学习任务，每个玩家学习自己行为的过渡模型。我们在第4.1节中介绍了基于强化学习的最佳响应计算，并在第4.2节中提出了基于监督学习的策略更新 RL 在这项工作中，我们使用FQI从抽样经验的数据集中学习。在每次迭代k时，FSP从自我游戏中抽取游戏片段。每个代理商都会将其体验添加到其重播内存\\(M_{RL}^{i}\\)中。数据以转换元组的集合\\((u_t,a_t,r_{t+1},u_{t+1})\\)的形式存储。每一集\\(\\eta=\\{(u_t,a_t,r_{t+1},u_{t+1})\\},0\\leq t \\leq T\\)，\\(T\\in\\mathbb{N}\\) 都包含有限数量的转换。我们使用固定尺寸的有限存储器。如果记忆已满，新剧集将以先发先出的顺序取代现有剧集。使用有限内存并逐步更新可能会偏离内存近似的基础分布。我们希望获得一个与对手的平均战略分布相似的记忆成分。这可以通过使用自适应策略配置文件来实现，该配置文件可以在代理的平均响应策略和最佳响应策略配置之间进行适当混合。 SL 我们将自己限制在简单模型中，这些模型计算在信息状态下采取行动的次数，或者累计各个策略采取每个行动的概率。这些模型可以在每次迭代k时使用来自\\(\\beta_k\\)的样本进行增量更新。模型更新需要一组采样元组\\((u_t^i,\\rho_t^i)\\)，其中\\((u_t^i)\\)是代理i的信息状态，而\\(\\rho_t^i\\)是agent在此经验采样时在此状态下追求的策略。对于每个元组\\((u_t,\\rho_t)\\)，更新会在信息状态下累积每个动作的权重 image-20230128205655159 Algorithm image-20230123022712765","categories":[],"tags":[]},{"title":"【论文调研】Hierarchical Abstraction, Distributed Equilibrium Computation, and Post-Processing, with Application to a Champion No-Limit Texas Hold'em Agent 笔记","slug":"hierarchical abstraction algorithm笔记","date":"2023-03-06T08:34:34.708Z","updated":"2023-03-06T09:18:01.716Z","comments":true,"path":"2023/03/06/hierarchical abstraction algorithm笔记/","link":"","permalink":"https://klc1006.github.io/2023/03/06/hierarchical%20abstraction%20algorithm%E7%AC%94%E8%AE%B0/","excerpt":"（看得有点迷糊，不确定理解得对不对）","text":"（看得有点迷糊，不确定理解得对不对） Main Abstraction Algorithm 让r是我们执行公共聚类的游戏的特殊回合 对于初始的\\(\\hat{r}\\)−1轮，我们使用任意算法\\(A_r\\)计算第r轮的（潜在不完美回忆）抽象。例如，在扑克中，最强agent在预循环中不使用抽象（即使他们确实使用了抽象，也不需要公共聚类，可以单独执行）。 将第\\(\\hat{r}\\)轮的公共状态聚集到C桶中。 image-20230217171729578 Algorithm for Computing Abstraction of Public Information(有点抽象，有点难懂) 一旦计算了该公共抽象，我们就为之前计算的每个公共桶分别计算私有信息的所有状态的从\\(\\hat{r}\\)到\\(R\\)的每一轮抽象,\\(A_r\\)，这些抽象可以使用任何任意的方法来计算。对于我们的扑克agent，我们使用了一种抽象算法，该算法之前已经被证明与\\(A_r\\)的算法一样性能良好 需要计算大量的公共翻牌 每一对公共状态设置距离函数（相似函数）\\(d_{i,j}\\) 使用聚类算法，和距离函数计算公共抽象 image-20230217172652417 Public Abstraction Clustering Algorithm output\\(c^T [i]\\) as the final abstraction image-20230217172804895 Equilibrium-Finding Algorithm 每当头部节点向集群叶发送数据时，我们的算法都会遇到叶间延迟，并且在接收响应时也会遇到这种延迟。每一次MCCFR迭代，这只相当于不到一毫秒。每次迭代大约需要15毫秒，因此延迟开销是负的。在这种开销很大的设置中，可以通过让子叶在每次迭代中获取更多样本，从而增加采样时间与延迟时间的比率，从而轻松地将其忽略不计。 由于头部节点只能在接收到来自所有集群叶的响应后才能继续，因此如果它们的MCCFR更新完成得比其他叶更快，则一些集群可能会空闲相当长的时间。尽管我们的抽象算法将博弈树均匀地划分为子叶，但这种情况还是会发生：在某些叶上，MCCFR计算的当前策略使得游戏路径更快地结束（例如，通过折叠扑克） 该算法开始于对优先级信息进行采样，并在头部叶片上执行MCCFR。当到达一个动作序列，该动作序列过渡到树的顶部（即，过渡到德克萨斯州Hold'em中的触发器）时，该算法将当前状态发送到K个子叶片C1、C2、…、…，每个子叶片CK然后从其公共桶（即，从分配给它的有效触发器Fk中的一个触发器）采样公共信息，并继续MCCFR的迭代。一旦所有子叶片完成其部分迭代，其计算值~uk将返回到头部叶片。头部叶片计算这些值的加权平均值，并根据公共信息的选择数量。 这确保了预期值是无偏的，也就是说，在预期中，每个失败都被平均加权。然后，头部节点继续其MCCFR的迭代，每当样本退出顶部时（遇到一个触发器序列），重复该过程，直到迭代完成。 在实践中（与伪代码中所示的不同），我们不是在每次采样超过树的顶部时与子节点通信（即，在Texas Hold'em中遇到一个触发器序列），而是使用两遍方法。在第一次通过时，我们只记录遇到了哪些连续（翻牌）序列。然后将这些序列发送给子叶片，以便它们可以计算这些序列的值；子叶片并行工作，但在每个子叶片中，分配给该叶片的连续序列被一个接一个地处理。然后，头部叶片执行与第一次相同的第二次传递，不同之处在于，每当样本超出树的顶部时（即，在Texas Hold'em中到达翻牌），都会使用从子叶片返回的值。 在每个子叶片中，即每个子集群中，我们实际上拥有并使用多个内核（为简单起见，pseu docode中未显示）。每当到达子集群时，每个核心都会得到相同的输入，但使用不同的随机数种子来选择集群中要处理的公共样本（德克萨斯州Hold'em的公共失败），以及如何根据MCCFR对其下的操作进行随机采样。考虑到游戏的性质，内核将以非常低的概率执行冗余工作，并且在集群的不同部分中迭代最多一次就会过时。（另一种选择是将树的一部分锁定在集群中，以防止核心在相同的信息集上工作，但这会带来开销，至少在Texas Hold'em似乎没有必要这样做。） image-20230217194944332 New Family of Post-Processing Technique（处理动作空间比较大的游戏） 后处理技术也被证明有助于缓解将平衡过度拟合到抽象中的问题，以及近似均衡发现可能最终导致不良行为的概率为正的问题。已经研究了两种方法，即阈值化和净化（Ganzfried、Sandholm和Waugh，2012年）。 在阈值化中，低于某个阈值的动作概率被设置为零，然后剩余的概率被重新规范化。净化是阈值化的特殊情况，其中具有最高概率的动作以概率1进行（随机均匀地打破关系）。 我们观察到，将反向映射和阈值化相结合会导致这样一个问题，即在动作空间的某个区域精细地离散动作不利于这些动作，因为平衡发现的概率质量在它们之间被稀释。为了缓解这个问题，我们建议将抽象动作划分为相似类，以便进行阈值处理（但不在阈值处理之后）。例如，在无限制扑克中，任何下注大小都可以达到玩家剩余筹码的数量。在给定的情况下，我们的投注抽象可以允许代理人折叠、调用、下注0.5罐、0.75罐、罐、1.5罐、2罐、5罐，等等。如果动作概率为（0.1，0.25，0.15，0.15，0.2，0.15,0,0），那么净化将选择召唤动作，而绝大多数质量（0.65）是在下注动作上。在这个例子中，我们下面详细介绍的方法将进行一个罐大小的下注（最高概率的下注动作）。 最后，我们观察到，偏向于减少方差的保守操作（例如扑克中的折叠动作）有助于强大的代理人（方差增加了较弱的对手获胜的概率）。我们的实验将表明，在TH中偏好保守的“折叠”动作也会增加预期值。一个原因可能是，如果一个代理人不确定在给定情况下应该做什么（平衡行动概率是混合的），那么该代理人很可能也会不确定，因此最好在这里结束游戏，而不是继续参与代理人较弱的游戏。 我们的新后处理技术结合了上面列出的所有想法。它首先将可用操作分为三类：折叠、调用和下注。如果折叠的概率超过阈值参数，我们将以概率1折叠。否则，我们会在折叠、调用和下注的“元动作”这三个选项之间进行净化。如果选择了下注，那么我们会在特定的下注动作中进行净化。 显然，这项技术有很多变化，因此它产生了一个系列，这取决于使用了什么阈值来确定使用保守动作（折叠）、如何将动作分组以进行阈值处理、在桶中使用了什么值以及在元动作（可能是多个）中使用了哪个阈值。","categories":[],"tags":[]},{"title":"【论文调研】The Dynamics of Reinforcement Learning in Cooperative Multiagent Systems 笔记","slug":"the dynamics of reforcelearning","date":"2023-03-06T08:34:34.707Z","updated":"2023-03-06T09:09:05.958Z","comments":true,"path":"2023/03/06/the dynamics of reforcelearning/","link":"","permalink":"https://klc1006.github.io/2023/03/06/the%20dynamics%20of%20reforcelearning/","excerpt":"区分两个learner： 不知道（或忽略）其他agent的存在的 reforcelearner 明确尝试学习联合动作的价值及其对应者的策略的learner 以这两个视角：研究合作多智能体系统中的Q-learning 关注点： 部分动作可观测性，博弈结构，探索策略 对收敛到（最优和次优）纳什均衡和learned Q value的影响。","text":"区分两个learner： 不知道（或忽略）其他agent的存在的 reforcelearner 明确尝试学习联合动作的价值及其对应者的策略的learner 以这两个视角：研究合作多智能体系统中的Q-learning 关注点： 部分动作可观测性，博弈结构，探索策略 对收敛到（最优和次优）纳什均衡和learned Q value的影响。 Comparing Independent and Joint-Action Learners 简单协调游戏中的相对表现： ILs： 不会认为他们的任何一个选择（平均而言）比另一个更好。 A对于动作a0和a1的Q值将收敛到5，因为每当执行a0时，b0和b1执行的概率为0:5。（在任何时候，由于策略的随机性和学习率的衰减，我们都会预期学习到的Q值不会相同） 两个IL和JAL选择最佳联合动作的概率，作为它们之间交互次数的函数。 温度参数最初为T=16，在T+1次交互作用时衰减了\\(0.9^t\\)。 ILs的协调非常快 两个平衡点都没有偏好:两个平衡中的每一个都在大约一半的试验中获得。 JALs 固定数量的交互操作之后，JAL确实表现得更好。虽然JAL有更多的信息可供他们使用，但融合并没有显著增强。 虽然JAL能够区分不同联合行动的Q值，但他们使用这些信息的能力受到行动选择机制的限制。 “插入”勘探策略的单个行动的价值或多或少与ILs的Q值相同。区别在于：JAL使用显式分布和联合Q值来计算它们，而不是直接更新它们。 The Effects of Partial Action Observability image-20230305195054605 image-20230305200206449 agent i更新对所有的动作更新联合Q-value Pr is computed in the obvious way by i using its beliefs and Bayes rule. 观测模型越准确，agent的收敛速度就会更快 Convergence and Game Structure image-20230305201148923 该博弈具有三个确定性均衡 当k=-100时，agent A发现其第一和第三个动作是因为B的随机探索而没有吸引力 如果A是IL,a0和a2的平均reward会相当低 如果A是JAl，它对B的策略的信仰会使这些行动具有较低的预期价值。 k越接近零，agent发现其第一和第三行动不具吸引力的可能性越低。 image-20230305200819725 收敛到一个最优平衡点受到“惩罚”k的大小的影响。","categories":[],"tags":[]},{"title":"Lab 1","slug":"Lab1","date":"2022-10-02T16:00:00.000Z","updated":"2023-03-06T11:39:19.319Z","comments":true,"path":"2022/10/03/Lab1/","link":"","permalink":"https://klc1006.github.io/2022/10/03/Lab1/","excerpt":"实验题目 Accessing the Database The first laboratory exercise is to connect to a database, populate it with data, and run very simple SQL queries. In case a shared database is provided for course students, user accounts need to be created on the database. Otherwise, the lab should also cover setting up a database system. Information on setting up a database may be found here The next step is to connect to the database. Although most databases have their own text-based interface, we recommend using a graphical interface such as the database browser of the Netbeans IDE, or a database specific interface. More information on accessing these interfaces may be found here. The next step is to create tables and load sample data. Scripts for these tasks can be found here. Try out some queries, and see what they do. Some example queries: select * from instructor select name from instructor where dept_name = 'Comp. Sci.' and salary &gt; 70000 select * from instructor, department where instructor.dept_name = department.dept_name","text":"实验题目 Accessing the Database The first laboratory exercise is to connect to a database, populate it with data, and run very simple SQL queries. In case a shared database is provided for course students, user accounts need to be created on the database. Otherwise, the lab should also cover setting up a database system. Information on setting up a database may be found here The next step is to connect to the database. Although most databases have their own text-based interface, we recommend using a graphical interface such as the database browser of the Netbeans IDE, or a database specific interface. More information on accessing these interfaces may be found here. The next step is to create tables and load sample data. Scripts for these tasks can be found here. Try out some queries, and see what they do. Some example queries: select * from instructor select name from instructor where dept_name = 'Comp. Sci.' and salary &gt; 70000 select * from instructor, department where instructor.dept_name = department.dept_name 实验内容 step1 建立一个数据库系统 这里大家过程不再赘述 image-20220907205936723 step2 选择适合的IDE 这里使用vscode管理数据库，搭建结果如下： image-20220907205825794 step3 创建表 加载样本数据 image-20220907173559352 使用sql文件中的结构化查询语言建立表格，加载relation信息 ①创建数据库 1create database university; 检验是否创建成功 1show databases; ②创建表格 进入使用数据库university 1use university; 创建表格语言如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115create table classroom (building varchar(15), room_number varchar(7), capacity numeric(4,0), primary key (building, room_number) );create table department (dept_name varchar(20), building varchar(15), budget numeric(12,2) check (budget &gt; 0), primary key (dept_name) );create table course (course_id varchar(8), title varchar(50), dept_name varchar(20), credits numeric(2,0) check (credits &gt; 0), primary key (course_id), foreign key (dept_name) references department (dept_name) on delete set null );create table instructor (ID varchar(5), name varchar(20) not null, dept_name varchar(20), salary numeric(8,2) check (salary &gt; 29000), primary key (ID), foreign key (dept_name) references department (dept_name) on delete set null );create table section (course_id varchar(8), sec_id varchar(8), semester varchar(6) check (semester in (&#x27;Fall&#x27;, &#x27;Winter&#x27;, &#x27;Spring&#x27;, &#x27;Summer&#x27;)), year numeric(4,0) check (year &gt; 1701 and year &lt; 2100), building varchar(15), room_number varchar(7), time_slot_id varchar(4), primary key (course_id, sec_id, semester, year), foreign key (course_id) references course (course_id) on delete cascade, foreign key (building, room_number) references classroom (building, room_number) on delete set null );create table teaches (ID varchar(5), course_id varchar(8), sec_id varchar(8), semester varchar(6), year numeric(4,0), primary key (ID, course_id, sec_id, semester, year), foreign key (course_id, sec_id, semester, year) references section (course_id, sec_id, semester, year) on delete cascade, foreign key (ID) references instructor (ID) on delete cascade );create table student (ID varchar(5), name varchar(20) not null, dept_name varchar(20), tot_cred numeric(3,0) check (tot_cred &gt;= 0), primary key (ID), foreign key (dept_name) references department (dept_name) on delete set null );create table takes (ID varchar(5), course_id varchar(8), sec_id varchar(8), semester varchar(6), year numeric(4,0), grade varchar(2), primary key (ID, course_id, sec_id, semester, year), foreign key (course_id, sec_id, semester, year) references section (course_id, sec_id, semester, year) on delete cascade, foreign key (ID) references student (ID) on delete cascade );create table advisor (s_ID varchar(5), i_ID varchar(5), primary key (s_ID), foreign key (i_ID) references instructor (ID) on delete set null, foreign key (s_ID) references student (ID) on delete cascade );create table time_slot (time_slot_id varchar(4), day varchar(1), start_hr numeric(2) check (start_hr &gt;= 0 and start_hr &lt; 24), start_min numeric(2) check (start_min &gt;= 0 and start_min &lt; 60), end_hr numeric(2) check (end_hr &gt;= 0 and end_hr &lt; 24), end_min numeric(2) check (end_min &gt;= 0 and end_min &lt; 60), primary key (time_slot_id, day, start_hr, start_min) );create table prereq (course_id varchar(8), prereq_id varchar(8), primary key (course_id, prereq_id), foreign key (course_id) references course (course_id) on delete cascade, foreign key (prereq_id) references course (course_id) ); 输入加载文件语句： 1source D:\\db\\1\\DDL.sql 加载完成后，输入 1show tables; 查看表格信息如下 image-20220907200208225 ③加载样本信息 输入加载文件语句 1source D:\\db\\1\\smallRelationsInsertFile.sql 内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150delete from prereq;delete from time_slot;delete from advisor;delete from takes;delete from student;delete from teaches;delete from section;delete from instructor;delete from course;delete from department;delete from classroom;insert into classroom values (&#x27;Packard&#x27;, &#x27;101&#x27;, &#x27;500&#x27;);insert into classroom values (&#x27;Painter&#x27;, &#x27;514&#x27;, &#x27;10&#x27;);insert into classroom values (&#x27;Taylor&#x27;, &#x27;3128&#x27;, &#x27;70&#x27;);insert into classroom values (&#x27;Watson&#x27;, &#x27;100&#x27;, &#x27;30&#x27;);insert into classroom values (&#x27;Watson&#x27;, &#x27;120&#x27;, &#x27;50&#x27;);insert into department values (&#x27;Biology&#x27;, &#x27;Watson&#x27;, &#x27;90000&#x27;);insert into department values (&#x27;Comp. Sci.&#x27;, &#x27;Taylor&#x27;, &#x27;100000&#x27;);insert into department values (&#x27;Elec. Eng.&#x27;, &#x27;Taylor&#x27;, &#x27;85000&#x27;);insert into department values (&#x27;Finance&#x27;, &#x27;Painter&#x27;, &#x27;120000&#x27;);insert into department values (&#x27;History&#x27;, &#x27;Painter&#x27;, &#x27;50000&#x27;);insert into department values (&#x27;Music&#x27;, &#x27;Packard&#x27;, &#x27;80000&#x27;);insert into department values (&#x27;Physics&#x27;, &#x27;Watson&#x27;, &#x27;70000&#x27;);insert into course values (&#x27;BIO-101&#x27;, &#x27;Intro. to Biology&#x27;, &#x27;Biology&#x27;, &#x27;4&#x27;);insert into course values (&#x27;BIO-301&#x27;, &#x27;Genetics&#x27;, &#x27;Biology&#x27;, &#x27;4&#x27;);insert into course values (&#x27;BIO-399&#x27;, &#x27;Computational Biology&#x27;, &#x27;Biology&#x27;, &#x27;3&#x27;);insert into course values (&#x27;CS-101&#x27;, &#x27;Intro. to Computer Science&#x27;, &#x27;Comp. Sci.&#x27;, &#x27;4&#x27;);insert into course values (&#x27;CS-190&#x27;, &#x27;Game Design&#x27;, &#x27;Comp. Sci.&#x27;, &#x27;4&#x27;);insert into course values (&#x27;CS-315&#x27;, &#x27;Robotics&#x27;, &#x27;Comp. Sci.&#x27;, &#x27;3&#x27;);insert into course values (&#x27;CS-319&#x27;, &#x27;Image Processing&#x27;, &#x27;Comp. Sci.&#x27;, &#x27;3&#x27;);insert into course values (&#x27;CS-347&#x27;, &#x27;Database System Concepts&#x27;, &#x27;Comp. Sci.&#x27;, &#x27;3&#x27;);insert into course values (&#x27;EE-181&#x27;, &#x27;Intro. to Digital Systems&#x27;, &#x27;Elec. Eng.&#x27;, &#x27;3&#x27;);insert into course values (&#x27;FIN-201&#x27;, &#x27;Investment Banking&#x27;, &#x27;Finance&#x27;, &#x27;3&#x27;);insert into course values (&#x27;HIS-351&#x27;, &#x27;World History&#x27;, &#x27;History&#x27;, &#x27;3&#x27;);insert into course values (&#x27;MU-199&#x27;, &#x27;Music Video Production&#x27;, &#x27;Music&#x27;, &#x27;3&#x27;);insert into course values (&#x27;PHY-101&#x27;, &#x27;Physical Principles&#x27;, &#x27;Physics&#x27;, &#x27;4&#x27;);insert into instructor values (&#x27;10101&#x27;, &#x27;Srinivasan&#x27;, &#x27;Comp. Sci.&#x27;, &#x27;65000&#x27;);insert into instructor values (&#x27;12121&#x27;, &#x27;Wu&#x27;, &#x27;Finance&#x27;, &#x27;90000&#x27;);insert into instructor values (&#x27;15151&#x27;, &#x27;Mozart&#x27;, &#x27;Music&#x27;, &#x27;40000&#x27;);insert into instructor values (&#x27;22222&#x27;, &#x27;Einstein&#x27;, &#x27;Physics&#x27;, &#x27;95000&#x27;);insert into instructor values (&#x27;32343&#x27;, &#x27;El Said&#x27;, &#x27;History&#x27;, &#x27;60000&#x27;);insert into instructor values (&#x27;33456&#x27;, &#x27;Gold&#x27;, &#x27;Physics&#x27;, &#x27;87000&#x27;);insert into instructor values (&#x27;45565&#x27;, &#x27;Katz&#x27;, &#x27;Comp. Sci.&#x27;, &#x27;75000&#x27;);insert into instructor values (&#x27;58583&#x27;, &#x27;Califieri&#x27;, &#x27;History&#x27;, &#x27;62000&#x27;);insert into instructor values (&#x27;76543&#x27;, &#x27;Singh&#x27;, &#x27;Finance&#x27;, &#x27;80000&#x27;);insert into instructor values (&#x27;76766&#x27;, &#x27;Crick&#x27;, &#x27;Biology&#x27;, &#x27;72000&#x27;);insert into instructor values (&#x27;83821&#x27;, &#x27;Brandt&#x27;, &#x27;Comp. Sci.&#x27;, &#x27;92000&#x27;);insert into instructor values (&#x27;98345&#x27;, &#x27;Kim&#x27;, &#x27;Elec. Eng.&#x27;, &#x27;80000&#x27;);insert into section values (&#x27;BIO-101&#x27;, &#x27;1&#x27;, &#x27;Summer&#x27;, &#x27;2017&#x27;, &#x27;Painter&#x27;, &#x27;514&#x27;, &#x27;B&#x27;);insert into section values (&#x27;BIO-301&#x27;, &#x27;1&#x27;, &#x27;Summer&#x27;, &#x27;2018&#x27;, &#x27;Painter&#x27;, &#x27;514&#x27;, &#x27;A&#x27;);insert into section values (&#x27;CS-101&#x27;, &#x27;1&#x27;, &#x27;Fall&#x27;, &#x27;2017&#x27;, &#x27;Packard&#x27;, &#x27;101&#x27;, &#x27;H&#x27;);insert into section values (&#x27;CS-101&#x27;, &#x27;1&#x27;, &#x27;Spring&#x27;, &#x27;2018&#x27;, &#x27;Packard&#x27;, &#x27;101&#x27;, &#x27;F&#x27;);insert into section values (&#x27;CS-190&#x27;, &#x27;1&#x27;, &#x27;Spring&#x27;, &#x27;2017&#x27;, &#x27;Taylor&#x27;, &#x27;3128&#x27;, &#x27;E&#x27;);insert into section values (&#x27;CS-190&#x27;, &#x27;2&#x27;, &#x27;Spring&#x27;, &#x27;2017&#x27;, &#x27;Taylor&#x27;, &#x27;3128&#x27;, &#x27;A&#x27;);insert into section values (&#x27;CS-315&#x27;, &#x27;1&#x27;, &#x27;Spring&#x27;, &#x27;2018&#x27;, &#x27;Watson&#x27;, &#x27;120&#x27;, &#x27;D&#x27;);insert into section values (&#x27;CS-319&#x27;, &#x27;1&#x27;, &#x27;Spring&#x27;, &#x27;2018&#x27;, &#x27;Watson&#x27;, &#x27;100&#x27;, &#x27;B&#x27;);insert into section values (&#x27;CS-319&#x27;, &#x27;2&#x27;, &#x27;Spring&#x27;, &#x27;2018&#x27;, &#x27;Taylor&#x27;, &#x27;3128&#x27;, &#x27;C&#x27;);insert into section values (&#x27;CS-347&#x27;, &#x27;1&#x27;, &#x27;Fall&#x27;, &#x27;2017&#x27;, &#x27;Taylor&#x27;, &#x27;3128&#x27;, &#x27;A&#x27;);insert into section values (&#x27;EE-181&#x27;, &#x27;1&#x27;, &#x27;Spring&#x27;, &#x27;2017&#x27;, &#x27;Taylor&#x27;, &#x27;3128&#x27;, &#x27;C&#x27;);insert into section values (&#x27;FIN-201&#x27;, &#x27;1&#x27;, &#x27;Spring&#x27;, &#x27;2018&#x27;, &#x27;Packard&#x27;, &#x27;101&#x27;, &#x27;B&#x27;);insert into section values (&#x27;HIS-351&#x27;, &#x27;1&#x27;, &#x27;Spring&#x27;, &#x27;2018&#x27;, &#x27;Painter&#x27;, &#x27;514&#x27;, &#x27;C&#x27;);insert into section values (&#x27;MU-199&#x27;, &#x27;1&#x27;, &#x27;Spring&#x27;, &#x27;2018&#x27;, &#x27;Packard&#x27;, &#x27;101&#x27;, &#x27;D&#x27;);insert into section values (&#x27;PHY-101&#x27;, &#x27;1&#x27;, &#x27;Fall&#x27;, &#x27;2017&#x27;, &#x27;Watson&#x27;, &#x27;100&#x27;, &#x27;A&#x27;);insert into teaches values (&#x27;10101&#x27;, &#x27;CS-101&#x27;, &#x27;1&#x27;, &#x27;Fall&#x27;, &#x27;2017&#x27;);insert into teaches values (&#x27;10101&#x27;, &#x27;CS-315&#x27;, &#x27;1&#x27;, &#x27;Spring&#x27;, &#x27;2018&#x27;);insert into teaches values (&#x27;10101&#x27;, &#x27;CS-347&#x27;, &#x27;1&#x27;, &#x27;Fall&#x27;, &#x27;2017&#x27;);insert into teaches values (&#x27;12121&#x27;, &#x27;FIN-201&#x27;, &#x27;1&#x27;, &#x27;Spring&#x27;, &#x27;2018&#x27;);insert into teaches values (&#x27;15151&#x27;, &#x27;MU-199&#x27;, &#x27;1&#x27;, &#x27;Spring&#x27;, &#x27;2018&#x27;);insert into teaches values (&#x27;22222&#x27;, &#x27;PHY-101&#x27;, &#x27;1&#x27;, &#x27;Fall&#x27;, &#x27;2017&#x27;);insert into teaches values (&#x27;32343&#x27;, &#x27;HIS-351&#x27;, &#x27;1&#x27;, &#x27;Spring&#x27;, &#x27;2018&#x27;);insert into teaches values (&#x27;45565&#x27;, &#x27;CS-101&#x27;, &#x27;1&#x27;, &#x27;Spring&#x27;, &#x27;2018&#x27;);insert into teaches values (&#x27;45565&#x27;, &#x27;CS-319&#x27;, &#x27;1&#x27;, &#x27;Spring&#x27;, &#x27;2018&#x27;);insert into teaches values (&#x27;76766&#x27;, &#x27;BIO-101&#x27;, &#x27;1&#x27;, &#x27;Summer&#x27;, &#x27;2017&#x27;);insert into teaches values (&#x27;76766&#x27;, &#x27;BIO-301&#x27;, &#x27;1&#x27;, &#x27;Summer&#x27;, &#x27;2018&#x27;);insert into teaches values (&#x27;83821&#x27;, &#x27;CS-190&#x27;, &#x27;1&#x27;, &#x27;Spring&#x27;, &#x27;2017&#x27;);insert into teaches values (&#x27;83821&#x27;, &#x27;CS-190&#x27;, &#x27;2&#x27;, &#x27;Spring&#x27;, &#x27;2017&#x27;);insert into teaches values (&#x27;83821&#x27;, &#x27;CS-319&#x27;, &#x27;2&#x27;, &#x27;Spring&#x27;, &#x27;2018&#x27;);insert into teaches values (&#x27;98345&#x27;, &#x27;EE-181&#x27;, &#x27;1&#x27;, &#x27;Spring&#x27;, &#x27;2017&#x27;);insert into student values (&#x27;00128&#x27;, &#x27;Zhang&#x27;, &#x27;Comp. Sci.&#x27;, &#x27;102&#x27;);insert into student values (&#x27;12345&#x27;, &#x27;Shankar&#x27;, &#x27;Comp. Sci.&#x27;, &#x27;32&#x27;);insert into student values (&#x27;19991&#x27;, &#x27;Brandt&#x27;, &#x27;History&#x27;, &#x27;80&#x27;);insert into student values (&#x27;23121&#x27;, &#x27;Chavez&#x27;, &#x27;Finance&#x27;, &#x27;110&#x27;);insert into student values (&#x27;44553&#x27;, &#x27;Peltier&#x27;, &#x27;Physics&#x27;, &#x27;56&#x27;);insert into student values (&#x27;45678&#x27;, &#x27;Levy&#x27;, &#x27;Physics&#x27;, &#x27;46&#x27;);insert into student values (&#x27;54321&#x27;, &#x27;Williams&#x27;, &#x27;Comp. Sci.&#x27;, &#x27;54&#x27;);insert into student values (&#x27;55739&#x27;, &#x27;Sanchez&#x27;, &#x27;Music&#x27;, &#x27;38&#x27;);insert into student values (&#x27;70557&#x27;, &#x27;Snow&#x27;, &#x27;Physics&#x27;, &#x27;0&#x27;);insert into student values (&#x27;76543&#x27;, &#x27;Brown&#x27;, &#x27;Comp. Sci.&#x27;, &#x27;58&#x27;);insert into student values (&#x27;76653&#x27;, &#x27;Aoi&#x27;, &#x27;Elec. Eng.&#x27;, &#x27;60&#x27;);insert into student values (&#x27;98765&#x27;, &#x27;Bourikas&#x27;, &#x27;Elec. Eng.&#x27;, &#x27;98&#x27;);insert into student values (&#x27;98988&#x27;, &#x27;Tanaka&#x27;, &#x27;Biology&#x27;, &#x27;120&#x27;);insert into takes values (&#x27;00128&#x27;, &#x27;CS-101&#x27;, &#x27;1&#x27;, &#x27;Fall&#x27;, &#x27;2017&#x27;, &#x27;A&#x27;);insert into takes values (&#x27;00128&#x27;, &#x27;CS-347&#x27;, &#x27;1&#x27;, &#x27;Fall&#x27;, &#x27;2017&#x27;, &#x27;A-&#x27;);insert into takes values (&#x27;12345&#x27;, &#x27;CS-101&#x27;, &#x27;1&#x27;, &#x27;Fall&#x27;, &#x27;2017&#x27;, &#x27;C&#x27;);insert into takes values (&#x27;12345&#x27;, &#x27;CS-190&#x27;, &#x27;2&#x27;, &#x27;Spring&#x27;, &#x27;2017&#x27;, &#x27;A&#x27;);insert into takes values (&#x27;12345&#x27;, &#x27;CS-315&#x27;, &#x27;1&#x27;, &#x27;Spring&#x27;, &#x27;2018&#x27;, &#x27;A&#x27;);insert into takes values (&#x27;12345&#x27;, &#x27;CS-347&#x27;, &#x27;1&#x27;, &#x27;Fall&#x27;, &#x27;2017&#x27;, &#x27;A&#x27;);insert into takes values (&#x27;19991&#x27;, &#x27;HIS-351&#x27;, &#x27;1&#x27;, &#x27;Spring&#x27;, &#x27;2018&#x27;, &#x27;B&#x27;);insert into takes values (&#x27;23121&#x27;, &#x27;FIN-201&#x27;, &#x27;1&#x27;, &#x27;Spring&#x27;, &#x27;2018&#x27;, &#x27;C+&#x27;);insert into takes values (&#x27;44553&#x27;, &#x27;PHY-101&#x27;, &#x27;1&#x27;, &#x27;Fall&#x27;, &#x27;2017&#x27;, &#x27;B-&#x27;);insert into takes values (&#x27;45678&#x27;, &#x27;CS-101&#x27;, &#x27;1&#x27;, &#x27;Fall&#x27;, &#x27;2017&#x27;, &#x27;F&#x27;);insert into takes values (&#x27;45678&#x27;, &#x27;CS-101&#x27;, &#x27;1&#x27;, &#x27;Spring&#x27;, &#x27;2018&#x27;, &#x27;B+&#x27;);insert into takes values (&#x27;45678&#x27;, &#x27;CS-319&#x27;, &#x27;1&#x27;, &#x27;Spring&#x27;, &#x27;2018&#x27;, &#x27;B&#x27;);insert into takes values (&#x27;54321&#x27;, &#x27;CS-101&#x27;, &#x27;1&#x27;, &#x27;Fall&#x27;, &#x27;2017&#x27;, &#x27;A-&#x27;);insert into takes values (&#x27;54321&#x27;, &#x27;CS-190&#x27;, &#x27;2&#x27;, &#x27;Spring&#x27;, &#x27;2017&#x27;, &#x27;B+&#x27;);insert into takes values (&#x27;55739&#x27;, &#x27;MU-199&#x27;, &#x27;1&#x27;, &#x27;Spring&#x27;, &#x27;2018&#x27;, &#x27;A-&#x27;);insert into takes values (&#x27;76543&#x27;, &#x27;CS-101&#x27;, &#x27;1&#x27;, &#x27;Fall&#x27;, &#x27;2017&#x27;, &#x27;A&#x27;);insert into takes values (&#x27;76543&#x27;, &#x27;CS-319&#x27;, &#x27;2&#x27;, &#x27;Spring&#x27;, &#x27;2018&#x27;, &#x27;A&#x27;);insert into takes values (&#x27;76653&#x27;, &#x27;EE-181&#x27;, &#x27;1&#x27;, &#x27;Spring&#x27;, &#x27;2017&#x27;, &#x27;C&#x27;);insert into takes values (&#x27;98765&#x27;, &#x27;CS-101&#x27;, &#x27;1&#x27;, &#x27;Fall&#x27;, &#x27;2017&#x27;, &#x27;C-&#x27;);insert into takes values (&#x27;98765&#x27;, &#x27;CS-315&#x27;, &#x27;1&#x27;, &#x27;Spring&#x27;, &#x27;2018&#x27;, &#x27;B&#x27;);insert into takes values (&#x27;98988&#x27;, &#x27;BIO-101&#x27;, &#x27;1&#x27;, &#x27;Summer&#x27;, &#x27;2017&#x27;, &#x27;A&#x27;);insert into takes values (&#x27;98988&#x27;, &#x27;BIO-301&#x27;, &#x27;1&#x27;, &#x27;Summer&#x27;, &#x27;2018&#x27;, null);insert into advisor values (&#x27;00128&#x27;, &#x27;45565&#x27;);insert into advisor values (&#x27;12345&#x27;, &#x27;10101&#x27;);insert into advisor values (&#x27;23121&#x27;, &#x27;76543&#x27;);insert into advisor values (&#x27;44553&#x27;, &#x27;22222&#x27;);insert into advisor values (&#x27;45678&#x27;, &#x27;22222&#x27;);insert into advisor values (&#x27;76543&#x27;, &#x27;45565&#x27;);insert into advisor values (&#x27;76653&#x27;, &#x27;98345&#x27;);insert into advisor values (&#x27;98765&#x27;, &#x27;98345&#x27;);insert into advisor values (&#x27;98988&#x27;, &#x27;76766&#x27;);insert into time_slot values (&#x27;A&#x27;, &#x27;M&#x27;, &#x27;8&#x27;, &#x27;0&#x27;, &#x27;8&#x27;, &#x27;50&#x27;);insert into time_slot values (&#x27;A&#x27;, &#x27;W&#x27;, &#x27;8&#x27;, &#x27;0&#x27;, &#x27;8&#x27;, &#x27;50&#x27;);insert into time_slot values (&#x27;A&#x27;, &#x27;F&#x27;, &#x27;8&#x27;, &#x27;0&#x27;, &#x27;8&#x27;, &#x27;50&#x27;);insert into time_slot values (&#x27;B&#x27;, &#x27;M&#x27;, &#x27;9&#x27;, &#x27;0&#x27;, &#x27;9&#x27;, &#x27;50&#x27;);insert into time_slot values (&#x27;B&#x27;, &#x27;W&#x27;, &#x27;9&#x27;, &#x27;0&#x27;, &#x27;9&#x27;, &#x27;50&#x27;);insert into time_slot values (&#x27;B&#x27;, &#x27;F&#x27;, &#x27;9&#x27;, &#x27;0&#x27;, &#x27;9&#x27;, &#x27;50&#x27;);insert into time_slot values (&#x27;C&#x27;, &#x27;M&#x27;, &#x27;11&#x27;, &#x27;0&#x27;, &#x27;11&#x27;, &#x27;50&#x27;);insert into time_slot values (&#x27;C&#x27;, &#x27;W&#x27;, &#x27;11&#x27;, &#x27;0&#x27;, &#x27;11&#x27;, &#x27;50&#x27;);insert into time_slot values (&#x27;C&#x27;, &#x27;F&#x27;, &#x27;11&#x27;, &#x27;0&#x27;, &#x27;11&#x27;, &#x27;50&#x27;);insert into time_slot values (&#x27;D&#x27;, &#x27;M&#x27;, &#x27;13&#x27;, &#x27;0&#x27;, &#x27;13&#x27;, &#x27;50&#x27;);insert into time_slot values (&#x27;D&#x27;, &#x27;W&#x27;, &#x27;13&#x27;, &#x27;0&#x27;, &#x27;13&#x27;, &#x27;50&#x27;);insert into time_slot values (&#x27;D&#x27;, &#x27;F&#x27;, &#x27;13&#x27;, &#x27;0&#x27;, &#x27;13&#x27;, &#x27;50&#x27;);insert into time_slot values (&#x27;E&#x27;, &#x27;T&#x27;, &#x27;10&#x27;, &#x27;30&#x27;, &#x27;11&#x27;, &#x27;45 &#x27;);insert into time_slot values (&#x27;E&#x27;, &#x27;R&#x27;, &#x27;10&#x27;, &#x27;30&#x27;, &#x27;11&#x27;, &#x27;45 &#x27;);insert into time_slot values (&#x27;F&#x27;, &#x27;T&#x27;, &#x27;14&#x27;, &#x27;30&#x27;, &#x27;15&#x27;, &#x27;45 &#x27;);insert into time_slot values (&#x27;F&#x27;, &#x27;R&#x27;, &#x27;14&#x27;, &#x27;30&#x27;, &#x27;15&#x27;, &#x27;45 &#x27;);insert into time_slot values (&#x27;G&#x27;, &#x27;M&#x27;, &#x27;16&#x27;, &#x27;0&#x27;, &#x27;16&#x27;, &#x27;50&#x27;);insert into time_slot values (&#x27;G&#x27;, &#x27;W&#x27;, &#x27;16&#x27;, &#x27;0&#x27;, &#x27;16&#x27;, &#x27;50&#x27;);insert into time_slot values (&#x27;G&#x27;, &#x27;F&#x27;, &#x27;16&#x27;, &#x27;0&#x27;, &#x27;16&#x27;, &#x27;50&#x27;);insert into time_slot values (&#x27;H&#x27;, &#x27;W&#x27;, &#x27;10&#x27;, &#x27;0&#x27;, &#x27;12&#x27;, &#x27;30&#x27;);insert into prereq values (&#x27;BIO-301&#x27;, &#x27;BIO-101&#x27;);insert into prereq values (&#x27;BIO-399&#x27;, &#x27;BIO-101&#x27;);insert into prereq values (&#x27;CS-190&#x27;, &#x27;CS-101&#x27;);insert into prereq values (&#x27;CS-315&#x27;, &#x27;CS-101&#x27;);insert into prereq values (&#x27;CS-319&#x27;, &#x27;CS-101&#x27;);insert into prereq values (&#x27;CS-347&#x27;, &#x27;CS-101&#x27;);insert into prereq values (&#x27;EE-181&#x27;, &#x27;PHY-101&#x27;); 输入加载文件语句 1source D:\\db\\1\\largeRelationsInsertFile.sql 内容： 123456789101112131415161718192021delete from prereq;delete from time_slot;delete from advisor;delete from takes;delete from student;delete from teaches;delete from section;delete from instructor;delete from course;delete from department;delete from classroom;insert into time_slot values ( &#x27;A&#x27;, &#x27;M&#x27;, 8, 0, 8, 50);insert into time_slot values ( &#x27;A&#x27;, &#x27;W&#x27;, 8, 0, 8, 50);insert into time_slot values ( &#x27;A&#x27;, &#x27;F&#x27;, 8, 0, 8, 50);insert into time_slot values ( &#x27;B&#x27;, &#x27;M&#x27;, 9, 0, 9, 50);insert into time_slot values ( &#x27;B&#x27;, &#x27;W&#x27;, 9, 0, 9, 50);insert into time_slot values ( &#x27;B&#x27;, &#x27;F&#x27;, 9, 0, 9, 50);insert into time_slot values ( &#x27;C&#x27;, &#x27;M&#x27;, 11, 0, 11, 50);insert into time_slot values ( &#x27;C&#x27;, &#x27;W&#x27;, 11, 0, 11, 50);insert into time_slot values ( &#x27;C&#x27;, &#x27;F&#x27;, 11, 0, 11, 50);... 示例结果如下： 输入 1show columns from classroom; 1show columns from instructor; image-20220907202620296 如图显示了两个表格的含有的信息，包括属性，数据类型等等。 step4 尝试一些sql查询语句 ```sql select * from instructor 123456789 **结果输出：** ![image-20220907204404000](https://s2.loli.net/2022/09/08/Uo48IqZ9sf1tFXv.png) ![image-20220907204412921](https://s2.loli.net/2022/09/08/XiRmdVZlLz1MyfN.png)* ```sql select name from instructor where dept_name = &#x27;Comp. Sci.&#x27; and salary &gt; 70000 结果输出： image-20220907204459661 sql select * from instructor, department where instructor.dept_name = department.dept_name 结果输出： image-20220907204550046 image-20220907204600120 总结 本实验，简单完成数据库的创建，创建列表，以及信息加载，学会使用sql结构化查询语句。 \\[ \\begin{equation} \\left\\{ \\begin{array}{lr} x=\\dfrac{3\\pi}{2}(1+2t)\\cos(\\dfrac{3\\pi}{2}(1+2t)), &amp; \\\\ y=s, &amp; 0 \\leq s \\leq L,|t| \\leq1. \\\\ z=\\dfrac{3\\pi}{2}(1+2t)\\sin(\\dfrac{3\\pi}{2}(1+2t)), &amp; \\end{array} \\right. \\end{equation} \\]","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2022-08-25T08:46:02.561Z","updated":"2022-08-25T08:46:02.562Z","comments":true,"path":"2022/08/25/hello-world/","link":"","permalink":"https://klc1006.github.io/2022/08/25/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://klc1006.github.io/tags/cpp/"},{"name":"A*","slug":"A","permalink":"https://klc1006.github.io/tags/A/"},{"name":"IDA*","slug":"IDA","permalink":"https://klc1006.github.io/tags/IDA/"},{"name":"PDDL","slug":"PDDL","permalink":"https://klc1006.github.io/tags/PDDL/"},{"name":"规划问题","slug":"规划问题","permalink":"https://klc1006.github.io/tags/%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98/"},{"name":"KNN","slug":"KNN","permalink":"https://klc1006.github.io/tags/KNN/"},{"name":"分类","slug":"分类","permalink":"https://klc1006.github.io/tags/%E5%88%86%E7%B1%BB/"},{"name":"朴素贝叶斯","slug":"朴素贝叶斯","permalink":"https://klc1006.github.io/tags/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/"},{"name":"归结推理","slug":"归结推理","permalink":"https://klc1006.github.io/tags/%E5%BD%92%E7%BB%93%E6%8E%A8%E7%90%86/"},{"name":"AI","slug":"AI","permalink":"https://klc1006.github.io/tags/AI/"},{"name":"最短路径","slug":"最短路径","permalink":"https://klc1006.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"},{"name":"论文调研","slug":"论文调研","permalink":"https://klc1006.github.io/tags/%E8%AE%BA%E6%96%87%E8%B0%83%E7%A0%94/"},{"name":"FSP","slug":"FSP","permalink":"https://klc1006.github.io/tags/FSP/"}]}