{"meta":{"title":null,"subtitle":"","description":"","author":"Klc","url":"https://Klc1006.github.io","root":"/"},"pages":[],"posts":[{"title":"【RL】PPO以及更新神经网络RNN","slug":"【RL】PPO","date":"2023-03-15T09:02:53.113Z","updated":"2023-03-16T12:39:57.069Z","comments":true,"path":"2023/03/15/【RL】PPO/","link":"","permalink":"https://klc1006.github.io/2023/03/15/%E3%80%90RL%E3%80%91PPO/","excerpt":"","text":"状态价值函数\\(V_{\\pi}\\)和动作价值函数\\(Q_{\\pi}\\)的关系 状态价值函数:从状态\\(s\\)出发遵循策略\\(\\pi\\)能获得的期望回报 \\[ \\begin{aligned} V_{\\pi}(s)&amp;=\\mathbb E [G_{t}|S_{t}=s]\\\\ &amp;=\\mathbb E [R_{t+1}+\\gamma G_{t+1}|S_{t}=s]\\\\ &amp;=\\mathbb E [R_{t+1}+\\gamma V_{\\pi}(S_{t+1})|S_{t}=s]\\\\ &amp;=\\mathbb E [R_{t+1}|S_{t}=s]+\\gamma \\mathbb E [G_{t+1}|S_{t}=s]\\\\ &amp;=\\mathbb E [R_{t+1}|S_{t}=s]+\\gamma \\mathbb E [V_{\\pi}(S_{t+1})|S_{t}=s] \\end{aligned} \\] 展开理解 \\(G_{t}\\) 这里的\\(G_{t}\\)是指在\\(t\\)时刻即时奖励和所有持久奖励等一切奖励的加权和 引入折扣因子（奖惩因子）\\(\\gamma\\)，表示随着时间越往后回报率越低（对于当前的贡献奖励越低） 通俗地理解为越往后，越会有更多或更重要G_的因素成就更后面的好事，总不能所有好事都百分百归功于最开头选择的这个状态/决策 \\[ \\begin{aligned} G_{t}&amp;=R_{t+1}+\\gamma R_{t+1}+\\gamma^2 R_{t+1}+\\gamma^3 R_{t+1}\\\\ &amp;=R_{t+1}+\\gamma( R_{t+1}+\\gamma R_{t+1}+\\gamma^2 R_{t+1})\\\\ &amp;=R_{t+1}+\\gamma G_{t+1} \\end{aligned} \\] 即时奖励：\\(\\mathbb E [R_{t+1}|S_{t}=s]=R(s)\\) 持久奖励: \\(\\gamma \\mathbb E [V_{\\pi}(S_{t+1})|S_{t}=s]\\) 持久奖励推导：推导第2行到第3行 \\[ \\begin{aligned} \\mathbb E [G_{t+1}|S_{t}=s]&amp;=\\sum G_{t+1}P\\{G_{t+1}|S_{t}=s\\} \\\\ &amp;=\\sum G_{t+1}\\sum_{s&#39;}P\\{ G_{t+1}|S_{t+1}=s&#39;,S_{t}=s\\}P\\{S_{t+1}=s&#39;|S_{t}=s\\}\\\\ &amp;=\\sum_{s&#39;}\\sum G_{t+1}P\\{ G_{t+1}|S_{t+1}=s&#39;,S_{t}=s\\}P\\{S_{t+1}=s&#39;|S_{t}=s\\}\\\\ &amp;=\\sum_{s&#39;}\\mathbb E[ G_{t+1}| S_{t+1}=s&#39;,S_{t}=s]P\\{S_{t+1}=s&#39;|S_{t}=s\\}\\\\ &amp;=\\sum_{s&#39;} V(S_{t+1})P\\{S_{t+1}=s&#39;|S_{t}=s\\}\\\\ &amp;=\\mathbb E[V(S_{t+1})|S_{t}=s] \\end{aligned} \\] 疑问？：\\(\\mathbb E[ G_{t+1}| S_{t+1}=s&#39;,S_{t}=s]?=\\mathbb E[ G_{t+1}| S_{t+1}=s&#39;]\\) 1-&gt;2: 概率公式推导,这里不再赘述 得到贝尔曼方程： \\[ V(s)=R(s)+\\gamma\\sum_{s&#39; \\in S}P(s&#39;|s)V(s&#39;) \\] 注：这里公式做了部分简化 动作价值函数:对当前状态\\(s\\)依据策略\\(\\pi\\)行动作\\(a\\)得到的期望回报 \\[ \\begin{aligned} Q_{\\pi}(s,a)&amp;=\\mathbb E [G_{t}|S_{t}=s,A_{t}=a]\\\\ &amp;=\\mathbb E [R_{t+1}+\\gamma G_{t+1}|S_{t}=s,,A_{t}=a]\\\\ &amp;=\\mathbb E [R_{t+1}+\\gamma Q_{\\pi}(S_{t+1},A_{t+1})|S_{t}=s,,A_{t}=a] \\end{aligned} \\] 此处2-&gt;3推导与\\(V(s)\\)一致 该函数用于选取一个最优动作 两个函数的直接关系如图： img 可视化状态之间的转移以及采取的动作 在使用策略时，状态\\(s\\)的价值等于在该状态下基于策略\\(\\pi\\)采取所有动作的概率与相应的价值相乘再求和的结果 \\[ V_{\\pi}(s)=\\sum_{a\\in A}\\pi(a|s)Q_{\\pi}(s,a) \\] 疑问？注:这里的\\(\\pi\\)指策略的概率函数\\(P_{\\pi}\\) 而使用策略时，在状态\\(s\\)下采取动作\\(a\\)的价值如下（动作价值） \\[ Q_{\\pi}(s,a)=R(s,a)+\\gamma\\sum_{s&#39; \\in S}P(s&#39;|s,a)V_{\\pi}(s&#39;) \\] 注：这里仿照的是\\(V(s)\\)的贝尔曼方程，这里的P是状态转移概率（对应图中） 可以参考以下推导公式 img 根据以上两个式子推导出马尔可夫决策的贝尔曼方程 \\[ \\begin{aligned} V_{\\pi}(s)&amp;=\\sum_{a\\in A}\\pi(a|s)\\Bigg[R(s,a)+\\gamma\\sum_{s&#39; \\in S}P(s&#39;|s,a)V_{\\pi}(s&#39;) \\Bigg]\\\\ Q_{\\pi}(s,a)&amp;=R(s,a)+\\gamma\\sum_{s&#39; \\in S}P(s&#39;|s,a)\\Bigg[\\sum_{a\\in A}\\pi(a|s’)Q_{\\pi}(s&#39;,a)\\Bigg] \\end{aligned} \\] 以上关系推导过程参考以下图片 img 思考： 这里的递推关系其实 与我们想象中的递推关系有点出入\\(dp[i]=f(dp[i+1])\\) 需要呈现\\(dp[i]=f(dp[i-1])\\)的形式？？？ PPO改进历程（策略价值函数改进） 策略梯度 这里我理解的策略应该是动作选择策略，指参数为\\(\\theta\\)的策略\\(\\pi_{\\theta}\\)接收到状态\\(s\\)后，输出一个动作概率分布 可以形式化表达函数为 \\[ a=\\pi_{\\theta}(s) \\] 往后的步骤：在动作概率分布中采样动作，执行动作(形成运动轨迹\\(\\tau\\))，得到奖励\\(r\\)(这里的奖励需要做评价)，跳到下一个状态\\(s&#39;\\) 该算法大量时间耗费在采用工作：当策略\\(\\pi\\)的参数更新后，这些样本不能继续被使用，还要重新使用策略\\(\\pi&#39;\\)与环境互动收集数据 神经网络角度： 这里\\(\\theta\\)是策略的一个参数，我们需要像训练神经网络那样，定义损失函数，通过损失函数梯度优化参数\\(\\theta\\),得到更好的策略 在此我们只需要定义一个目标优化函数（正向传播产生动作，然后动作在环境中产生奖励值，通过奖励值求和产生评价函数），对该函数做梯度上升，同样去优化参数\\(\\theta\\) 运动轨迹 \\[ \\tau=(s_1,a_1,r_1,s_2,a_2,r_2,s_3,a_3,r_3,...,s_t,a_t,r_t) \\] 疑问？：这里需要控制\\(t\\)吗？ 根据以上轨迹，我们可以获得这条轨迹的概率 动作概率分布\\(p_{\\theta}(a_t|s_t)\\) 状态概率分布\\(p(s_{t+1}|s_t,a_t)\\) 轨迹\\(\\tau\\)概率如下 \\[ \\begin{aligned} p_{\\theta}(\\tau)&amp;=p(s_1)p_{\\theta}(a_1|s_1)p(s_2|s_1,a_1)p_{\\theta}(a_2|s_2)p(s_3|s_2,a_2)\\\\ &amp;=p(s_1)\\prod_{t=1}^T p_{\\theta}(a_t|s_t)p(s_{t+1}|s_t,a_t) \\end{aligned} \\] 这里的策略函数可以看作综合评价动作和状态，以一个期望值作为评价标准 策略价值函数：对所有\\(\\tau\\)出现的概率与对应的奖励进行加权最后求和 ​ (看着好像很简单？？) \\[ \\bar{R}_{\\theta}=\\sum_{\\tau}R(\\tau)p_{\\theta}(\\tau)=\\mathbb E_{\\tau~ p_{\\theta}}[R(\\tau)]\\\\ R(\\tau)=\\sum_{t=1}^T r_t \\] 整个期望奖励可视化表示如下： 梯度计算 \\[ \\nabla \\bar{R}_{\\theta}=\\sum_{\\tau} R(\\tau)\\nabla p_{\\theta}(\\tau) \\] 根据一常用的技巧 \\[ \\nabla f(x)=f(x)\\nabla \\log f(x) \\] 进一步推导为 \\[ \\begin{aligned} \\nabla \\bar{R}_{\\theta}&amp;=\\sum_{\\tau} R(\\tau)\\nabla p_{\\theta}(\\tau)\\\\ &amp;=\\sum_{\\tau}R(\\tau)p_{\\theta}(\\tau)\\nabla \\log p_{\\theta}(\\tau)\\\\ &amp;=\\sum_{\\tau}\\Big[R(\\tau)\\nabla \\log p_{\\theta}(\\tau)\\Big] p_{\\theta}(\\tau)\\\\ &amp;=\\mathbb E_{\\tau \\sim p_{\\theta}(\\tau)}[R(\\tau) \\nabla \\log p_{\\theta}(\\tau)] \\end{aligned} \\] MC近似计算 近似计算取平均如下： \\[ \\begin{aligned} \\mathbb E_{\\tau \\sim p_{\\theta}(\\tau)}[R(\\tau) \\nabla \\log p_{\\theta}(\\tau)]&amp;\\approx \\frac{1}{N}\\sum_{n=1}^N R(\\tau^n) \\nabla \\log p_{\\theta}(\\tau^n)\\\\ &amp;=\\frac{1}{N}\\sum_{n=1}^N \\sum_{t=1}^{T_n} R(\\tau^n) \\nabla \\log p_{\\theta}(a_{t}^n|s_{t}^n) \\end{aligned} \\] 1-&gt;2推导 取对数 \\[ \\log p_{\\theta}(\\tau)=\\log (s_1)+\\sum_{t=1}^{T_n}(\\log p(s_{t+1}|s_t,a_t)+\\log p_{\\theta}(a_t|s_t)) \\] 对\\(\\theta\\)求梯度 \\[ \\nabla \\log p_{\\theta}(\\tau)=\\sum_{t=1}^{T_n}\\nabla \\log p_{\\theta}(a_t|s_t) \\] 重要性采样 解决采样花费大量时间的问题 将同策略模式转变成异策略模式 同一个策略采样的数据可以作多次更新，受单一采样数据约束 使用\\(\\theta&#39;\\)采样到的数据训练\\(\\theta\\)，并且可,以反复使用该采样数据，执行多次梯度上升（不需要反复采样） 对梯度加上重要性权重\\(\\frac{p_{\\theta}(\\tau)}{p_{\\theta&#39;}(\\tau)}\\) 梯度公式更新为 $$ \\[\\begin{aligned} \\nabla \\bar{R}_{\\theta}&amp;=\\mathbb E_{\\tau \\sim p_{\\theta}(\\tau)}[R(\\tau) \\nabla \\log p_{\\theta}(\\tau)]\\\\ &amp;=\\sum_{\\tau}\\Big[R(\\tau)\\nabla \\log p_{\\theta}(\\tau)\\Big] p_{\\theta}(\\tau)\\\\ &amp;=\\sum_{\\tau}\\Big[\\frac{p_{\\theta}(\\tau)}{p_{\\theta&#39;}(\\tau)}R(\\tau)\\nabla \\log p_{\\theta}(\\tau)\\Big]p_{\\theta&#39;}(\\tau) \\\\ &amp;=\\mathbb E_{\\tau \\sim p_{\\theta&#39;}(\\tau)}[\\frac{p_{\\theta}(\\tau)}{p_{\\theta&#39;}(\\tau)}R(\\tau) \\nabla \\log p_{\\theta}(\\tau)] \\end{aligned}\\] $$ A2C 加入基准线\\(b\\)（不依赖动作\\(a\\)），避免 所有动作都是正奖励 出现较大的方差 梯度更新 \\[ \\begin{aligned} \\mathbb E_{\\tau \\sim p_{\\theta}(\\tau)}[R(\\tau) \\nabla \\log p_{\\theta}(\\tau)]&amp;\\approx \\frac{1}{N}\\sum_{n=1}^N \\sum_{t=1}^{T_n} R(\\tau^n-b) \\nabla \\log p_{\\theta}(a_{t}^n|s_{t}^n) \\end{aligned} \\] 基准线选择 奖励均值 \\[ b=\\frac{1}{T}\\sum_{t=0}^T R_{t}(\\tau) \\] 状态价值函数 \\[ b=V_{\\pi}(s_{t}) \\] 优势函数定义 \\(A^{\\theta}(s_t,a_t)\\) 正：增加概率 负：减少概率 $A_{}(s,a)=Q_{}(s,a)-V_{}(s) $ 在选择一个动作时，根据该动作相对于特定状态下其他可用动作的执行情况来选择，而不是根据该动作的绝对值(\\(Q\\)函数估计) 仿照上述目标优化函数，更新梯度更新公式 $$ \\[\\begin{aligned} \\nabla \\bar{R}_{\\theta}&amp;=\\mathbb E_{\\tau \\sim p_{\\theta}(\\tau)}[A^{\\theta}(s_t,a_t)\\nabla \\log p_{\\theta}(\\tau)]\\\\ &amp;=\\mathbb E_{\\tau \\sim p_{\\theta&#39;}(\\tau)}[\\frac{p_{\\theta}(s_t,a_t)}{p_{\\theta&#39;}(s_t,a_t)}A^{\\theta&#39;}(s_t,a_t)\\nabla \\log p_{\\theta}(\\tau)]\\\\ &amp;=\\mathbb E_{(s_t,a_t) \\sim p_{\\theta&#39;}}[\\frac{p_{\\theta}(s_t,a_t)}{p_{\\theta&#39;}(s_t,a_t)}A^{\\theta&#39;}(s_t,a_t)\\nabla \\log p_{\\theta}(a_{t}^n |s_t^n)]\\\\ &amp;=\\mathbb E_{(s_t,a_t) \\sim p_{\\theta&#39;}}[\\frac{p_{\\theta}(a_t|s_t)p_{\\theta}(s_t)}{p_{\\theta&#39;}(a_t|s_t)p_{\\theta&#39;}(s_t)}A^{\\theta&#39;}(s_t,a_t)\\nabla \\log p_{\\theta}(a_{t}^n |s_t^n)]\\\\ &amp;=\\mathbb E_{(s_t,a_t) \\sim p_{\\theta&#39;}}[\\frac{p_{\\theta}(a_t|s_t)}{p_{\\theta&#39;}(a_t|s_t)}A^{\\theta&#39;}(s_t,a_t)\\nabla \\log p_{\\theta}(a_{t}^n |s_t^n)]\\\\ \\end{aligned}\\] $$ 这里需要假设\\(p_{\\theta}(s_t)=p_{\\theta&#39;}(s_t)\\),这里\\(s_t\\)概率难以确定，直接忽略，对于图像概率不好处理 对于动作的条件概率是好算的，根据原来的策略概率计算即可 反推回目标优化函数 利用前面的对应公式推导 \\[ J^{\\theta&#39;}(\\theta)==\\mathbb E_{(s_t,a_t) \\sim p_{\\theta&#39;}}[\\frac{p_{\\theta}(a_t|s_t)}{p_{\\theta&#39;}(a_t|s_t)}A^{\\theta&#39;}(s_t,a_t)]\\\\ \\] TRPO 加入KL散度 直观感受 img KL散度=交叉熵-shannon熵 $$ \\[\\begin{aligned} D_{KL}(p||q)&amp;=H(p,q)-H(p)\\\\ &amp;=-\\sum p(x) \\log q(x)+\\sum p(x) \\log p(x)\\\\ &amp;=-\\sum p(x) \\log \\frac{q(x)}{p(x)}\\\\ &amp;=\\sum p(x)\\log \\frac{q(x)}{p(x)} \\end{aligned}\\] $$ KL散度性质： \\(D_{KL} &gt;=0\\) \\[ \\begin{aligned} -D_{KL}(p||q) &amp;=\\sum p(x) \\log \\frac{q(x)}{p(x)}\\\\ &amp; \\le p(x)\\frac{q(x)}{p(x)}\\\\ &amp;=\\log 1 \\\\ &amp;=0 \\end{aligned} \\] 解决分布相差大问题 解决步长难以确定问题 增加KL约束 目标优化问题变为 \\[ J^{\\theta&#39;}_{TRPO}(\\theta)==\\mathbb E_{(s_t,a_t) \\sim p_{\\theta&#39;}}[\\frac{p_{\\theta}(a_t|s_t)}{p_{\\theta&#39;}(a_t|s_t)}A^{\\theta&#39;}(s_t,a_t)],KL(\\theta,\\theta&#39;)&lt;\\delta\\\\ \\] 该约束条件使得两个分布相差尽可能小，从而也可以避免步长过大 加入KL散度约束后，计算难度加大 ppo ppo继承TRPO优点，限制new policy的更新幅度，对较大的步长不太敏感 近端策略优化惩罚 相当于给该问题加入正则化项，要求学习到的\\(\\theta\\)和\\(\\theta&#39;\\)越相似越好 得到PPO优化公式为： \\[ J^{\\theta&#39;}_{PPO}(\\theta)=J^{\\theta&#39;}(\\theta)-\\beta KL(\\theta,\\theta&#39;) \\] \\(\\beta\\)为超参数，作自适应惩罚 需要设置散度最大值\\(KL_{max}\\)，最小值\\(KL_{min}\\),保证惩罚效果 近端策略优化裁剪 简化KL散度，得到目标函数应该为 \\[ J^{\\theta&#39;}_{PPO}(\\theta)\\approx \\sum_{(s_t,a_t)}min(\\frac{p_{\\theta}(a_t|s_t)}{p_{\\theta&#39;}(a_t|s_t)}A^{\\theta&#39;}(s_t,a_t),clip(\\frac{p_{\\theta}(a_t|s_t)}{p_{\\theta&#39;}(a_t|s_t)},1-\\epsilon,1+\\epsilon)A^{\\theta&#39;}(s_t,a_t)) \\] 12345678910111213// ratios即为重要性权重，exp代表求期望，括号里的environment_log_probs代表用于与环境交互的策略ratios = torch.exp(log_probs - environment_log_probs) // 分别用sur_1、sur_2来计算公式的两部分// 第一部分是重要性权重乘以优势函数sur_1 = ratios * advs // 第二部分是具体的裁剪过程sur_2 = torch.clamp(ratios, 1 - clip_eps, 1 + clip_eps) * advs // 最终看谁更小则取谁clip_loss = -torch.min(sur_1,sur_2).mean() 第二部分理解 对概率比进行裁剪，保证两个概率分布尽可能相似 好动作（\\(A&gt;0\\)）：增大\\(p_{\\theta}\\),概率比不大于\\(1+\\epsilon\\) 不是好动作(\\(A&lt;0\\))：减小\\(p_{\\theta}\\),概率比不小于\\(1-\\epsilon\\) 整个式子理解 好动作步长不会太大 不好动作步长不会太小 img \\(A&gt;0,ratio&gt;1+\\epsilon:(1+\\epsilon )·A\\) \\(A&gt;0,ratio&lt;1-\\epsilon:ratio·A\\) \\(A&lt;0,ratio&gt;1+\\epsilon:ratio·A\\) \\(A&lt;0,ratio&lt;1-\\epsilon:(1-\\epsilon )·A\\)","categories":[],"tags":[]},{"title":"【Leetcode】题解笔记","slug":"leetcodet题解笔记","date":"2023-03-07T16:00:00.000Z","updated":"2023-03-09T06:43:50.959Z","comments":true,"path":"2023/03/08/leetcodet题解笔记/","link":"","permalink":"https://klc1006.github.io/2023/03/08/leetcodet%E9%A2%98%E8%A7%A3%E7%AC%94%E8%AE%B0/","excerpt":"31.下一个排列 139.单词拆分","text":"31.下一个排列 139.单词拆分 31.下一个排列 通过从后往前推导，可以发现我们只要找到第一个升序对，并且将左边数字（较小数字）与其右侧中所有数字最小的一个（且大于升序对较小数字）数字交换位置，其余按升序排列即可找到“下一个排列” 算法过程如下： ①从后往前找到第一个升序对(i，j)，满足nums[i]&lt;nums[j](其中有一个隐含前提：j以后的数字是降序的) ②在[j:]之中找到满足nums[i]&lt;nums[k]的最小数nums[k] ③swap(nums[i],nums[k]) ④对i以后的数字做升序排列，即找到下一个排列 ⑤如果①步不满足条件，则说明改数组按降序排列，只要对整个数组做降序排列即找到下一个排列 123456789101112131415161718class Solution &#123;public: void nextPermutation(vector&lt;int&gt;&amp; nums) &#123; for(int i=nums.size()-1;i&gt;0;i--)&#123; if(nums[i]&gt;nums[i-1])&#123; sort(nums.begin()+i,nums.end()); for(int j=i;j&lt;nums.size();j++)&#123; if(nums[j]&gt;nums[i-1])&#123; swap(nums[j],nums[i-1]); return; &#125; &#125; &#125; &#125; sort(nums.begin(),nums.end()); return ; &#125;&#125;; 139.单词拆分 算法核心： 采用哈希表对的子串进行查找，提高查找效率 利用动态规划，保证[0：j]为一完整单词的前提下，检验[j:i]是否为一个完整的单词（利用哈希表查找），规划方程如下： \\[ dp[i]=dp[j] \\and check(s[j:i-1]) \\] 对于初始化条件dp[0]=1(true)(不难思考，空串也是符合条件的) 12345678910111213141516171819class Solution &#123;public: bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123; unordered_set&lt;string&gt; dict; for(int i=0;i&lt;wordDict.size();i++)&#123; dict.insert(wordDict[i]); &#125; vector&lt;int&gt; ans(s.length()+1,0); ans[0]=1; for(int i=0;i&lt;=s.length();i++)&#123; for(int j=0;j&lt;=i;j++)&#123; if(ans[j]&amp;&amp;dict.find(s.substr(j,i-j))!=dict.end())&#123; ans[i]=1; &#125; &#125; &#125; return ans[s.length()]; &#125;&#125;;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://klc1006.github.io/tags/leetcode/"}]},{"title":"面向对象编程 OOP（cpp语言篇）","slug":"cpp","date":"2023-03-06T17:25:59.594Z","updated":"2023-03-08T16:55:47.575Z","comments":true,"path":"2023/03/07/cpp/","link":"","permalink":"https://klc1006.github.io/2023/03/07/cpp/","excerpt":"引言 面向过程设计 导致程序结构不灵活。若高层算法需要修改，那么可能 底层的算法也因此需要修改。 导致代码难以复用 面向对象设计 class是保留字，说明DATE是类名。在{}中列出类的成员。 类的成员包括： 数据成员：一般说来，数据成员是需要隐藏的对象；即外部的程序是不 能直接访问这些数据的，应该通过函数成员来访问这些数据。所以一般 情况下，数据成员通过关键字private声明为私有成员（private member ） 函数成员：通过关键字public声明为公有成员（public member）。外部 程序可以访问共有成员，但无法访问私有成员。 对于类的使用者（即用户代码，简称用户）而言，只需要获得DATE.h ，即可调用类对象的公有函数访问其内部的数据成员。使用者无法直接 访问私有成员，也无需知晓公有函数的内部实现。","text":"引言 面向过程设计 导致程序结构不灵活。若高层算法需要修改，那么可能 底层的算法也因此需要修改。 导致代码难以复用 面向对象设计 class是保留字，说明DATE是类名。在{}中列出类的成员。 类的成员包括： 数据成员：一般说来，数据成员是需要隐藏的对象；即外部的程序是不 能直接访问这些数据的，应该通过函数成员来访问这些数据。所以一般 情况下，数据成员通过关键字private声明为私有成员（private member ） 函数成员：通过关键字public声明为公有成员（public member）。外部 程序可以访问共有成员，但无法访问私有成员。 对于类的使用者（即用户代码，简称用户）而言，只需要获得DATE.h ，即可调用类对象的公有函数访问其内部的数据成员。使用者无法直接 访问私有成员，也无需知晓公有函数的内部实现。 UML Coding 123456789101112131415class DATE // DATE.h----Specification file of class DATE&#123; public: void Set( int, int, int ); int getMonth() const; int getDay() const; int getYear() const; void Print() const; void Increment(); void Decrement(); private: int month; int day; int year;&#125;; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192//DATE.cpp //the implementation of each member function of DATE.#include &quot;DATE.h&quot;#include &lt;iostream&gt;using namespace std;int DaysInMonth( int, int ); void DATE::Set(int newYear, int newMonth,int newDay )&#123; month = newMonth; day = newDay; year = newYear; &#125;int DATE::getMonth() const&#123; return month;&#125;int DATE::getDay() const&#123; return day;&#125;int DATE::getYear() const&#123;return year;&#125;void DATE::Print() const&#123; switch (month) &#123; case 1 : cout &lt;&lt; &quot;January&quot;; break; case 2 : cout &lt;&lt; &quot;February&quot;; break; case 12 : cout &lt;&lt; &quot;December&quot;; &#125; cout &lt;&lt; &#x27; &#x27; &lt;&lt; day &lt;&lt; &quot;, &quot; &lt;&lt; year &lt;&lt; endl &lt;&lt; endl;&#125;void DATE::Increment()&#123; day++; if (day &gt; DaysInMonth(month, year)) &#123; day = 1; month++; if (month &gt; 12) &#123; month = 1; year++; &#125; &#125;&#125;void DATE::Decrement()&#123; day--; if ( day == 0 ) &#123; if( month == 1 ) &#123; day = 31; month = 12; year--; &#125; else &#123; month--; day = DaysInMonth( month, year ); &#125; &#125;&#125;int DaysInMonth( /* in */ int mo, /* in */ int yr )&#123; switch (mo) &#123; case 1: case 3: case 5: case 7: case 8: case 10: case 12: return 31; case 4: case 6: case 9: case 11: return 30; case 2: if ((yr % 4 == 0 &amp;&amp; yr % 100 != 0) ||yr % 400 == 0) return 29; else return 28; &#125;&#125; 123456789101112131415161718192021222324//client.cpp#include &quot;DATE.h&quot;#include &lt;iostream&gt;using namespace std;int main()&#123; DATE date1, date2; //① int tmp; date1.Set( 2020, 7, 1 ); date1.Print(); date1.Increment(); date1.Print(); date2.Set( 1997, 7, 1 ); date2.Print(); date2.Decrement(); date2.Print(); tmp = date1.getYear(); tmp++; date1.Set( tmp, 12, 20 ); date1.Print(); cout &lt;&lt; date1.year; //error? return 0;&#125; 开发平台和编译器 gcc和g++是GNU的c&amp;cpp编译器 gcc/g++执行编译时，需要四步 生成.i文件，预处理【预处理器cpp】 生成文件.s 文件，将预处理后的文件转换成汇编语言【编译器egcs】 生成.o文件，将汇编变为目标代码（机器代码）【汇编器as】 生成可执行程序，连接目标代码【连接器ld】 Namespace 12345678#include&lt; iostream &gt;main()&#123; int a; cin &gt;&gt; a; cout &lt;&lt; a ; return 0;&#125; 经预处理器处理后，扩展为左边的 代码。根据前面所述的标识符作用 范围规则：cin和cout是在名字空间 std内声明的，而std是一个块 （block），因此在其外当然不能直 接使用cin和cout。所以以下代码实 际上有语法错误。 因此才出现 using namespace std;这样的语句来解决这个问题。 123456789101112namespace std&#123; istream cin; ostream cout;&#125;int main()&#123; int a; cin &gt;&gt; a; cout &lt;&lt; a ; return 0;&#125; 3种方式使用Namespace标识符 使用由命名空间、作用域解析运算符::和所需标识符组成的限定名称 1std::cin &gt;&gt; a; 编写using声明 12using std::abs ;cin &gt;&gt; a; 本地或全局编写using指令 12using namespace std ; cin &gt;&gt; a; 用处 命名空间用于防止命名冲突。 命名空间std通常用于覆盖标准C++库的标准C++定义、声明等。 例1 123456789101112namespace mfc &#123; //vendor 1’s namespace int inflag; //vendor 1’s inflag&#125;namespace owl &#123; //vendor 2’s namespace int inflag; //vendor 2’s inflag&#125;mfc::inflag = 3; //mfc’s inflagowl::inflag = -823; //owl’s inflagusing mfc::inflag;inflag = 3;owl::inflag = -823; 例2 12345678910namespace mfc &#123; //vendor 1’s namespace int inflag; //vendor 1’s inflag void g(int);&#125;using mfc::inflag; //using declaration for inflaginflag = 100; //OKg(8); //Error!mfc::g(8); //OK, full nameusing mfc::g; //using declaration for gg(8); //OK 例3 12345678namespace mfc &#123; //vendor 1’s namespaceint inflag; //vendor 1’s inflagvoid g(int);&#125;using namespace mfc;//using directiveinflag = 21; //mfc::inflagg(-66); //mfc::gowl::inflag=341; //full name needed 范围解析运算符（Scope Resolution Operator） 可以使用作用域解析运算符引用隐藏的全局名称:: 1234567int x;void f2( )&#123; int x = 1; // hide global x ::x = 2; // assign to global x x=2; //assign to local x&#125; (but, there is no way to use a hidden local name) I/O cout与输出的实质 12cout &lt;&lt; “the answer is: ” &lt;&lt; 3*4 &lt;&lt; endl; //该语句在屏幕上输出 the answer is 12 计算机对3*4求值得整数值12； &lt;&lt;把字符‘t’、’h’ … ‘s’、’:’、’ ‘放入cout流中； &lt;&lt;把整数值12转化为字符‘1’和‘2’，也放入cout流中 endl产生一个换行符，该字符也被放入cout流中 cout把这些字符送往显示器 image-20230307012016458 cin与输入的实质 1cin &gt;&gt; someInt &gt;&gt; someFloat &gt;&gt; someChar ; 键盘输入的字符一个一个进入输入流cin里面； 一个&gt;&gt;代表一个输入过程。&gt;&gt;从cin中一个接一个获取字符， 这个获取过程在哪里结束取决于变量的数据类型。该获取过 程结束后，&gt;&gt;根据变量的数据类型，把刚才获得的字符序列 转化成跟变量类型一致的数据；然后把这个数据赋给变量。 下一个&gt;&gt;开始。 image-20230307012311466","categories":[],"tags":[{"name":"cpp","slug":"cpp","permalink":"https://klc1006.github.io/tags/cpp/"}]},{"title":"【计算机图形学】Assignment6 Mass Spring Simulation","slug":"【计图】hw6","date":"2023-01-08T16:00:00.000Z","updated":"2023-03-15T08:43:43.379Z","comments":true,"path":"2023/01/09/【计图】hw6/","link":"","permalink":"https://klc1006.github.io/2023/01/09/%E3%80%90%E8%AE%A1%E5%9B%BE%E3%80%91hw6/","excerpt":"","text":"质点弹簧系统是一种拉格朗日视角的物理模拟，把物体看成由一个个质点构成，质点之间通过弹簧相连，从而产生一定程度的弹性形变。质点弹簧系统适用于模拟布料软体、刚体等物理材质。对于物体中的任意两个不同的质点\\(x_i\\)和\\(x_j\\)，从\\(j\\)作用到\\(i\\)的作用力可由以下的胡克定律（Hooke's law）给出： $$ f_{ij}=-k(-l_{ij})() \\[ 其中$k$是弹簧刚度系数（spring stiffness）， $l_{ij}$是质点之间的弹簧静止长度， $\\widehat{x_i-x_j}$是从质点指向质点的单位方向向量（即 $\\widehat{x_i-x_j}=\\frac{x_i-x_j}{||x_i-x_j||}$）。对于质点$x_i$，它受到的作用力就是与之相连的所有弹性力的合力： \\] f_{i}=j^{ji}f{ij} \\[ 求出了合力，再根据牛顿第二定律可求出质点的加速度和位置的变化梯度： \\] =f_i $$ \\[ \\frac{\\partial x_i}{\\partial t}=v_i \\] 上面就是质点弹簧系统的核心公式，比较简单，基本都是高中物理的内容。求出了质点的加速度和速度之后，最简单的方法就是采用下面的显式积分公式来更新每个质点的速度\\(v\\)和位置\\(x\\)，从而生成符合弹簧特性的动画： \\[ v_{t+1}=v_t+\\Delta t \\frac{f_t}{m} \\tag{4} \\] \\[ x_{t+1}=x_t+\\Delta t v_t \\] 亦或者用更为稳定一点的半隐式欧拉积分法（依旧是显式积分）： \\[ v_{t+1}=v_t+\\Delta t \\frac{f_t}{m} \\tag{5} \\] \\[ x_{t+1}=x_t+\\Delta t v_{t+1} \\] 公式(4)和(5)的区别仅在于更新\\(x_{t+1}\\)时是用\\(v_{t}\\)还是\\(v_{t+1}\\)，其中是时间步长。综上所述，一个简单的质点弹簧模型求解步骤为： 计算每个质点受到的弹簧合力，使用公式(1)和公式(2)； 根据公式(4)（或(5)）更新质点的速度矢量\\(v_{t+1}=v_{t}+\\Delta t \\frac{f_t}{m}\\)； 碰撞检测和处理，作业框架里面就是简单地对窗口边界做一个判断和处理； 根据公式(4)（或(5)）更新质点的位置矢量\\(x_{t+1}=x_{t}+\\Delta v_t\\)。 Task 1 用前面的公式即显式积分法来实现质点弹簧系统的动画仿真。你需要填充代码的地方在Utils.cpp 文件的simulate()函数，如下所示。其中dt 是时间步长，gravity 是重力加速度。你需要先计算每个质点的合力（用前面的公式和），然后用合力更新速度值，最后更新质点的位置矢量。实现好之后，尝试然后按下g 键查看动画效果（或者点击鼠标生成更多的质点），贴出你的效果，并简述你是怎么做的。 思路： 按照两个公式对速度和位置进行更新 计算合力\\(f_{ij}=-k(\\sqrt{x_i-x_j}-l_{ij})(\\widehat{x_i-xj})\\)、$f_{i}=j^{ji}f{ij} $ \\(\\sqrt{x_i-x_j}\\)用代码表示为glm::length(m_x[i]-m_x[j]) \\(\\widehat{x_i-xj}\\)用代码表示为glm::normalize(m_x[i]-m_x[j]) 更新速度\\(v_{t+1}=v_t+\\Delta t \\frac{f_t}{m}\\) m_v[i]+=dt*(force/m_particleMass); 更新后，m_v表示\\(v_{t+1}\\) 更新位置\\(x_{t+1}=x_t+\\Delta t v_t\\) m_x[i]+=temp[i]*dt; 这里使用temp(\\(v_{t}\\))保存了未更新前的m_v(\\(v_t\\)) 123456789101112131415161718192021222324252627282930313233 ... // TODO: for each particle i, calculate the force f, and then update the m_v[i] std::vector&lt;glm::vec2&gt; temp=m_v; for (unsigned int i = 0; i &lt; m_numParticles; ++i) &#123; // Gravity force glm::vec2 force = gravity * m_particleMass; // You should use m_restLength[i][j], m_stiffness, m_x, dt, and m_particleMass herein // glm::vec2 f_i=glm::vec2(0.0f,0.0f); for (unsigned int j = 0; j &lt; m_numParticles; ++j) &#123; glm::vec2 f_ij=glm::vec2(0.0f,0.0f); if(m_restLength[i][j]!=0) f_ij=-m_stiffness*(glm::length(m_x[i]-m_x[j])-m_restLength[i][j])*glm::normalize(m_x[i]-m_x[j]); force+=f_ij; &#125; //Update the m_v[i] m_v[i]+=dt*(force/m_particleMass); &#125; ... // Todo: update the position m_x[i] using m_v[i] // Note: you should use the time step dt for (unsigned int i = 1; i &lt; m_numParticles; ++i) &#123; //方法一： m_x[i]+=temp[i]*dt; &#125;&#125; 实验结果 尚未用阻尼对速度进行衰减处理，因此实现的动画效果会一直动荡的比较厉害 image-20230109162032623 Task 2 用前面的公式（5）即半隐式积分法来实现质点弹簧系统的动画仿真。填充代码的地方与Task1一致，这里不再赘述。简述你是怎么做的。 按照两个公式对速度和位置进行更新 计算合力\\(f_{ij}=-k(\\sqrt{x_i-x_j}-l_{ij})(\\widehat{x_i-xj})\\)、$f_{i}=j^{ji}f{ij} $ \\(\\sqrt{x_i-x_j}\\)用代码表示为glm::length(m_x[i]-m_x[j]) \\(\\widehat{x_i-xj}\\)用代码表示为glm::normalize(m_x[i]-m_x[j]) 更新速度\\(v_{t+1}=v_t+\\Delta t \\frac{f_t}{m}\\) m_v[i]+=dt*(force/m_particleMass); 更新后，m_v表示\\(v_{t+1}\\) 更新位置\\(x_{t+1}=x_t+\\Delta t v_{t+1}\\)(唯一不同之处) m_x[i]+=m_v[i]*dt; 12345678910 ... // Todo: update the position m_x[i] using m_v[i] // Note: you should use the time step dt for (unsigned int i = 1; i &lt; m_numParticles; ++i) &#123; //半隐式欧拉积分法 m_x[i]+=m_v[i]*dt; &#125;&#125; 实验结果 情况与task1大致相同，由于没有加入衰减效果，弹簧永远不会停止。 image-20230109162112916 Task 3 对质点的速度\\(v\\)按照给定的阻尼系数进行衰减，以实现更贴近物理真实的弹簧效果。 实现了前两个Task之后，弹簧的效果看起来有种不正常的跳动和动荡。现实中的弹簧不会永远跳动，因为动能会因摩擦而减小。为了模拟这种效果，我们用以下的衰减公式对速度进行衰减处理： \\[ v=v·e^{-\\Delta·\\mu} \\] 其中\\(\\mu\\)是阻尼系数，在Simulator类中存储为m_damping。上述的公式使得速度以指数的方式衰减。请你在simulate 函数的最后一步（更新质点位置之前），用上述的公式更新质点的速度，使得质点的速度以一定的程度进行衰减。 在更新质点位置之前，对速度作衰减处理 对于每一个质点作衰减m_v[i] *= glm::exp(-dt*m_damping);​ 12345//衰减for (unsigned int i = 0; i &lt; m_numParticles; ++i)&#123; m_v[i] *= glm::exp(-dt*m_damping);&#125; 实验结果 物体最终呈现出”下垂“的静止状态 image-20230109162213426 Task 4 尝试修改Simulator 的m_stiffness 系数运行动画仿真，看看效果有什么不同，仔细体会公式中的弹簧刚度系数的物理意义。 更改弹簧刚度系数如下： 123// float m_stiffness = 8000;float m_stiffness = 1000;// float m_stiffness = 10000000; m_stiffness = 1000： image-20230109161913688 m_stiffness = 10000000： image-20230109161920140 弹簧刚度系数\\(k\\)越小，弹簧（细绳）之间的弹力越小，容易被拉长，表现出“松弛感”。 反之，弹簧刚度系数\\(k\\)越大，弹簧（细绳）之间的弹力越大，不容易被拉长，表现吃很明显的“紧绷感”。","categories":[],"tags":[]},{"title":"【计算机图形学】Assignment5 Bezier Curve","slug":"【计图】hw5","date":"2022-12-24T16:00:00.000Z","updated":"2023-03-15T08:43:53.528Z","comments":true,"path":"2022/12/25/【计图】hw5/","link":"","permalink":"https://klc1006.github.io/2022/12/25/%E3%80%90%E8%AE%A1%E5%9B%BE%E3%80%91hw5/","excerpt":"","text":"Task 1 Bézier曲线本质上是由调和函数根据控制点插值生成，其参数方程如下： \\[ Q(t)=\\sum_{i=0}^nP_iB_{i,n}(t),t\\in[0,1] \\] 控制点记为\\(P_i,i=0,...,n\\)，一共有\\(n+1\\)个控制顶点。上式是一个n次多项式，一共n+1项，每个控制点对应一项。多项式系数\\(B_{i,n}(t)\\)是Bernstein基函数，其数学公式为： \\[ B_{i,n}(t)=\\frac{n!}{i!(n-i)!}t^i(1-t)^{n-i},i=0,1,...,n \\] 实现代码时需要将Q（t）定义为Point2D 对象 1234567891011121314Point2D BezierCurve::implementTask1(const std::vector&lt;Point2D&gt; &amp;points, const double &amp;t) const&#123; //Task1: implement Bezier curve generation algorithm accroding to the definition int n=points.size()-1; Point2D Q_t(0,0); double B_t=std::pow(1-t,n); Q_t=points[0]*B_t; for(int i=1;i&lt;=n;i++)&#123; B_t *= ((n - i + 1) * t) / (i * (1 - t)); Q_t+=points[i]*B_t; &#125; return Q_t;&#125; Task 2 根据作业文档中de Casteljau算法 由(n+1)个控制点\\(P_i(i=0,1,...,n)\\)定义的n次Bezier曲线\\(P_0^n\\)可被定义为分别由前后n个控制点定义的两条（n-1）次的Bezier曲线 \\(P_0^{n-1}\\)和\\(P_1^{n-1}\\)的线性组合为 \\[ P_0^{n}=(1-t)P_0^{n-1}+tP_1^{n-1},t\\in[0,1] \\] 得到Bezier曲线递推公式如下 \\[ P_i^k=\\begin{cases} P_i,k=0 \\\\ (1-t)P_i^{k-1}+tP_{i+1}^{k-1},k=1,2,...,n \\space i=0,1,..,n-k \\end{cases} \\] de Casteljau算法的核心伪代码可以描述如下： 考虑一个为控制点序列的Bézier曲线，首先将相邻的点连接起来形成线段； 用的比例划分每个线段，用线性插值法找到分割点； 对所有的线段执行上述操作，得到的分割点作为新的控制点序列，新序列的数量会减少一个； 如果新的序列只包含一个点，则返回该点，终止迭代过程。否则，使用新的控制点序列并转到步骤1，如此迭代下去。 代码实现如下 12345678910111213Point2D BezierCurve::implementTask2(const std::vector&lt;Point2D&gt; &amp;points, const double &amp;t) const&#123; //Task2: implement de Casteljau algorithm for Bezier curve // Note: you should use Point2D::lerp(). if(points.size()==1) return points[0]; std::vector&lt;Point2D&gt; a; for(int i=0;i&lt;points.size()-1;i++)&#123; auto p=points[i]*(1.0f-t) + points[i+1]*t ; a.push_back(p); &#125; return implementTask2(a,t);&#125; Task 3 Bezier曲线理解： 该曲线采用化直为曲的思想，通过比例限制，就能够在平面上画出一定曲率的曲线，虽然在绘制过程中，难以控制曲线曲率，但是达到了绘制平滑曲线的效果。 该曲线由二次（三个控制点）推广到n-1次（n个控制点），在实现的时候我们只需要采取降阶的思想，在t移动的过程中，找出对应的曲线上的点，绘制连续点即可。 优点：具有一定的灵活性，即不再受曲线需要经过所有的点这一限制； 缺点：一是数学计算很麻烦，二是不便对曲线进行局部修改，三是多边形边数较多时，多边形对曲线的控制程度减弱","categories":[],"tags":[]},{"title":"【计算机图形学】Assignment4 Ray Tracing","slug":"【计图】hw4","date":"2022-12-04T16:00:00.000Z","updated":"2023-03-15T08:44:06.058Z","comments":true,"path":"2022/12/05/【计图】hw4/","link":"","permalink":"https://klc1006.github.io/2022/12/05/%E3%80%90%E8%AE%A1%E5%9B%BE%E3%80%91hw4/","excerpt":"","text":"task 1 阅读《Ray Tracing in One Weekend》的Chapter 4 ，完成射线类和简单的摄像机构建，并渲染一个渐变的蓝色天空背景图。贴出效果图，简述你遇到的问题以及是如何解决的。 定义光线ray类 123456789101112131415161718192021#ifndef RAY_H#define RAY_H#include &quot;vec3.h&quot;class ray &#123; public: ray() &#123;&#125; ray(const point3&amp; origin, const vec3&amp; direction) : orig(origin), dir(direction) &#123;&#125; point3 origin() const &#123; return orig; &#125; vec3 direction() const &#123; return dir; &#125; point3 at(double t) const &#123; return orig + t*dir; &#125; public: point3 orig; vec3 dir;&#125;;#endif 定义光线追踪函数 12345color ray_color(const ray&amp; r) &#123; vec3 unit_direction = unit_vector(r.direction()); auto t = 0.5*(unit_direction.y() + 1.0); return (1.0-t)*color(1.0, 1.0, 1.0) + t*color(0.5, 0.7, 1.0);&#125; 该函数实现关于y轴上（画布从高到低）线性渐变 经过scaling操作后，光线会落在单位范围内（-1&lt;y&lt;1）,实现水平方线上没有梯度，而在垂直方向上实现渐变梯度 利用渐变特性，返回一个线性插值函数，参数为t，其中（0&lt;=t&lt;=1）当t线性变化时，返回的垂直方向上的背景颜色也是有梯度变化（渐变）的,公式如下： \\[ BlendedValue=(1-t)·startValue+t·endValue \\] task 2 阅读《Ray Tracing in One Weekend》的Chapter 5 、Chapter 6 和Chapter 7 ，为场景添加并渲染一个简单的球形物体。贴出效果图，简述你遇到的问题以及是如何解决的。 Chapter 5 画一个球状物体 image-20221204161855240 限定一个以\\((C_x,C_y,C_z)\\)为中心，以\\(R\\)为半径的球体，对于空间内的一个点\\(P(x,y,x)\\)我们会有以下公式 \\[ (P-C)·(P-C)=(x-C_x)^2+(y-C_y)^2+(z-C_z)^2=R \\] 而在上一个任务中我们定义光线在画布中的点应该为\\(P(t)=A+tB\\)，带入后得到以下公式 \\[ (A+tB-C)·(A+tB-C)=R^2 \\] 也就是 \\[ t^2b·b+2tb·(A-C)+(A-C)·(A-C)-R^2=0 \\] 通过计算判别式，我们可以判断光线是否落在空间的球体上，从而有下列代码 12345678bool hit_sphere(const point3&amp; center, double radius, const ray&amp; r) &#123; vec3 oc = r.origin() - center; auto a = dot(r.direction(), r.direction()); auto b = 2.0 * dot(oc, r.direction()); auto c = dot(oc, oc) - radius*radius; auto discriminant = b*b - 4*a*c; return (discriminant &gt; 0);&#125; 如果落在球体上，那么返回rgb（1，0，0）(红色)，呈现出上述效果图 到目前为止，我们只是简单呈现了一个球体形状，没有加上阴影和反射光线，而且改代码粗糙在于，如果降球体空间定在z=+1位置上，画布上同样呈现出一个球体形状（这样显然是不合理的，你不可能看见处在你身后的东西），在接下来的步骤中会进一步细化 Chapter 6 利用法线进行shading image-20221205101856946 假定物体始终维持再摄像机前面 我们使用color map对发现进行着色 在这里，我们假设法线为单位向量，每各组件介于-1到1之间使得将每个分量映射到0到1之间，从而可以将xyz空间映射到rgb空间 我们不仅需要知道光线是否命中球体而且也要知道命中点 实现如下： 1234567891011121314151617181920212223double hit_sphere(const point3&amp; center, double radius, const ray&amp; r) &#123; vec3 oc = r.origin() - center; auto a = dot(r.direction(), r.direction()); auto b = 2.0 * dot(oc, r.direction()); auto c = dot(oc, oc) - radius*radius; auto discriminant = b*b - 4*a*c; if (discriminant &lt; 0) &#123; return -1.0; &#125; else &#123; return (-b - sqrt(discriminant) ) / (2.0*a); &#125;&#125;color ray_color(const ray&amp; r) &#123; auto t = hit_sphere(point3(0,0,-1), 0.5, r); if (t &gt; 0.0) &#123; vec3 N = unit_vector(r.at(t) - vec3(0,0,-1)); return 0.5*color(N.x()+1, N.y()+1, N.z()+1); &#125; vec3 unit_direction = unit_vector(r.direction()); t = 0.5*(unit_direction.y() + 1.0); return (1.0-t)*color(1.0, 1.0, 1.0) + t*color(0.5, 0.7, 1.0);&#125; 错误尝试： image-20221205101954928 该图像，相当于在空间内，对每个点都找了法向量，而不是球面上的法向量 封装hittable类 123456789101112131415#ifndef HITTABLE_H#define HITTABLE_H#include &quot;ray.h&quot;struct hit_record &#123; point3 p; vec3 normal; double t;&#125;;class hittable &#123;public: virtual bool hit(const ray&amp; r, double t_min, double t_max, hit_record&amp; rec) const = 0;&#125;;#endif 封装球体类 1234567891011121314151617181920212223242526272829303132333435363738394041#ifndef SPHERE_H#define SPHERE_H#include &quot;hittable.h&quot;#include &quot;vec3.h&quot;class sphere : public hittable &#123;public:sphere() &#123;&#125;sphere(point3 cen, double r) : center(cen), radius(r) &#123;&#125;;virtual bool hit(const ray&amp; r, double t_min, double t_max, hit_record&amp; rec) constoverride;public:point3 center;double radius;&#125;;bool sphere::hit(const ray&amp; r, double t_min, double t_max, hit_record&amp; rec)const &#123; vec3 oc = r.origin() - center; auto a = r.direction().length_squared(); auto half_b = dot(oc, r.direction()); auto c = oc.length_squared() - radius*radius; auto discriminant = half_b*half_b - a*c; if (discriminant &lt; 0) return false; auto sqrtd = sqrt(discriminant); // Find the nearest root that lies in the acceptable range. auto root = (-half_b - sqrtd) / a; if (root &lt; t_min || t_max &lt; root) &#123; root = (-half_b + sqrtd) / a; if (root &lt; t_min || t_max &lt; root) return false; &#125; rec.t = root; rec.p = r.at(rec.t); rec.normal = (rec.p - center) / radius; return true;&#125;#endif 比较光线和表面法向量，分析光线从表面外射入，还是从表面内射出（点乘） 点乘大于0，从表面内射出 点乘小于零，从表面外射入 同时需要保存与光线相反的法向量 12345678910bool front_face;if (dot(ray_direction, outward_normal) &gt; 0.0) &#123; // ray is inside the sphere normal = -outward_normal; front_face = false;&#125; else &#123; // ray is outside the sphere normal = outward_normal; front_face = true;&#125; 在这里我们可以在hit_record struct.设定front_face,从而限定，该点位置的法向量始终保持与光想相反的方向。 1234567891011struct hit_record &#123; point3 p; vec3 normal; double t; bool front_face; inline void set_face_normal(const ray&amp; r, const vec3&amp; outward_normal) &#123; front_face = dot(r.direction(), outward_normal) &lt; 0; normal = front_face ? outward_normal :-outward_normal; &#125;&#125;; 接下来，我们需要重新设计一个类，hittable_list类存储可击中的点 1234567891011121314151617181920212223242526272829303132333435363738#ifndef HITTABLE_LIST_H#define HITTABLE_LIST_H#include &quot;hittable.h&quot;#include &lt;memory&gt;#include &lt;vector&gt;using std::shared_ptr;using std::make_shared;class hittable_list : public hittable &#123; public: hittable_list() &#123;&#125; hittable_list(shared_ptr&lt;hittable&gt; object) &#123; add(object); &#125; void clear() &#123; objects.clear(); &#125; void add(shared_ptr&lt;hittable&gt; object) &#123; objects.push_back(object); &#125; virtual bool hit( const ray&amp; r, double t_min, double t_max, hit_record&amp; rec) const override; public: std::vector&lt;shared_ptr&lt;hittable&gt;&gt; objects;&#125;;bool hittable_list::hit(const ray&amp; r, double t_min, double t_max, hit_record&amp;rec) const &#123; hit_record temp_rec; bool hit_anything = false; auto closest_so_far = t_max; for (const auto&amp; object : objects) &#123; if (object-&gt;hit(r, t_min, closest_so_far, temp_rec)) &#123; hit_anything = true; closest_so_far = temp_rec.t; rec = temp_rec; &#125; &#125; return hit_anything;&#125;#endif 接下来，就可以自行定义数学公式上精确度，以及定义默认值，设计rtweekend.h 12345678910111213141516171819202122232425#ifndef RTWEEKEND_H#define RTWEEKEND_H#include &lt;cmath&gt;#include &lt;limits&gt;#include &lt;memory&gt;// Usingsusing std::shared_ptr;using std::make_shared;using std::sqrt;// Constantsconst double infinity = std::numeric_limits&lt;double&gt;::infinity();const double pi = 3.1415926535897932385;// Utility Functionsinline double degrees_to_radians(double degrees) &#123; return degrees * pi / 180.0;&#125;// Common Headers#include &quot;ray.h&quot;#include &quot;vec3.h&quot;#endif image-20221205104248486 Chapter 7 抗锯齿（边缘平滑） （光线采样取平均）对于给定的像素，我们在该像素中有几个样本，并通过每个像素发送光线样本。然后对这些光线的颜色进行平均： img 核心代码如下： 12345678910111213141516void write_color(std::ostream &amp;out, color pixel_color, int samples_per_pixel) &#123; auto r = pixel_color.x(); auto g = pixel_color.y(); auto b = pixel_color.z(); // Divide the color by the number of samples. auto scale = 1.0 / samples_per_pixel; r *= scale; g *= scale; b *= scale; // Write the translated [0,255] value of each color component. out &lt;&lt; static_cast&lt;int&gt;(256 * clamp(r, 0.0, 0.999)) &lt;&lt; &#x27; &#x27; &lt;&lt; static_cast&lt;int&gt;(256 * clamp(g, 0.0, 0.999)) &lt;&lt; &#x27; &#x27; &lt;&lt; static_cast&lt;int&gt;(256 * clamp(b, 0.0, 0.999)) &lt;&lt; &#x27;\\n&#x27;;&#125; 创建摄像机类 创建一个相机类来管理我们的虚拟相机和场景拼接的相关任务，以下类使用前面的轴对齐相机实现了一个简单的相机： 123456789101112131415161718192021222324252627#ifndef CAMERA_H#define CAMERA_H#include &quot;rtweekend.h&quot;class camera &#123; public: camera() &#123; auto aspect_ratio = 16.0 / 9.0; auto viewport_height = 2.0; auto viewport_width = aspect_ratio * viewport_height; auto focal_length = 1.0; origin = point3(0, 0, 0); horizontal = vec3(viewport_width, 0.0, 0.0); vertical = vec3(0.0, viewport_height, 0.0); lower_left_corner = origin - horizontal/2 - vertical/2 - vec3(0, 0, focal_length); &#125; ray get_ray(double u, double v) const &#123; return ray(origin, lower_left_corner + u*horizontal + v*vertical - origin); &#125; private: point3 origin; point3 lower_left_corner; vec3 horizontal; vec3 vertical;&#125;;#endif 原图像 抗锯齿 可以看到抗锯齿有明显的改善 task 3 阅读《Ray Tracing in One Weekend》的Chapter 8 、Chapter 9 和Chapter 10 ，为场景中的球形物体添加漫反射材质、金属材质和电解质材质，并渲染相应的材质效果图。贴出效果图，简述你遇到的问题以及是如何解决的。 Chapter 8 漫反射材质 考虑漫反射具有随机性，假定球面上的点是P，P点法向量为n，我们可以找到两个球体中心点（P+n）（P-n） 以图中所示为例，光线从外面设想球体表面，在以同侧球体中心在（P+n），半径为|n|的范围随机选取点S 返回（S-P）作为反射光线 image-20221205111528853 我们需要一种方法来在单位半径的球体中选择一个随机点。我们将使用通常最简单的算法：rejection method。首先，在单位立方体中选择一个随机点，其中x、y和z的范围均为−1到+1。如果该点在球体之外，拒绝此点，重试。 123456789class vec3 &#123; public: ... inline static vec3 random() &#123; return vec3(random_double(), random_double(), random_double()); &#125; inline static vec3 random(double min, double max) &#123; return vec3(random_double(min,max), random_double(min,max),random_double(min,max));&#125; 1234567vec3 random_in_unit_sphere() &#123; while (true) &#123; auto p = vec3::random(-1,1); if (p.length_squared() &gt;= 1) continue; return p; &#125;&#125; 对ray_color函数更新，同时我们要限制最大深度递归，以防击不中任何东西 123456789101112131415color ray_color(const ray&amp; r, const hittable&amp; world, int depth) &#123; hit_record rec; // If we&#x27;ve exceeded the ray bounce limit, no more light is gathered. if (depth &lt;= 0) return color(0,0,0); if (world.hit(r, 0, infinity, rec)) &#123; point3 target = rec.p + rec.normal + random_in_unit_sphere(); return 0.5 * ray_color(ray(rec.p, target - rec.p), world, depth-1); &#125; vec3 unit_direction = unit_vector(r.direction()); auto t = 0.5*(unit_direction.y() + 1.0); return (1.0-t)*color(1.0, 1.0, 1.0) + t*color(0.5, 0.7, 1.0);&#125; 得到效果图如下： image-20221205113149536 由效果图我们可以看到物体非常暗，这是因为球体每次反弹只吸收一半的能量，因此它们是50%的反射器，我们将颜色提高到幂，或者在我们的简单情况下，它只是平方根的形式，更改如下代码 1234567891011121314151617void write_color(std::ostream &amp;out, color pixel_color, int samples_per_pixel) &#123; auto r = pixel_color.x(); auto g = pixel_color.y(); auto b = pixel_color.z(); // Divide the color by the number of samples and gamma-correct for gamma=2.0. auto scale = 1.0 / samples_per_pixel; r = sqrt(scale * r); g = sqrt(scale * g); b = sqrt(scale * b); // Write the translated [0,255] value of each color component. out &lt;&lt; static_cast&lt;int&gt;(256 * clamp(r, 0.0, 0.999)) &lt;&lt; &#x27; &#x27; &lt;&lt; static_cast&lt;int&gt;(256 * clamp(g, 0.0, 0.999)) &lt;&lt; &#x27; &#x27; &lt;&lt; static_cast&lt;int&gt;(256 * clamp(b, 0.0, 0.999)) &lt;&lt; &#x27;\\n&#x27;;&#125; 进而图像变为浅灰色（其实目前图像跟期望还有一定差距，后续会做修改） image-20221205113720875 还有一个微妙的错误。一些反射光线击中了它们反射的物体，而不是精确地t=0，而是在t = −0.0000001或t = 0.0000001或球体相交给我们的任何浮点近似。因此，我们需要忽略非常接近零的命中： 1if (world.hit(r, 0.001, infinity, rec)) &#123; 更改之后的效果如下： image-20221205114355452 由此可以看到明显的漫反射和阴影效果 真实朗伯反射： 相较于简单的漫反射，真实朗伯反射选取圆上一个点S，最后返回反射光线 image-20221205114601665 补充函数： 123456inline vec3 random_in_unit_sphere() &#123;...&#125;vec3 random_unit_vector() &#123; return unit_vector(random_in_unit_sphere());&#125; 更改ray_color（）函数 1234if (world.hit(r, 0.001, infinity, rec)) &#123; point3 target = rec.p + rec.normal + random_unit_vector(); return 0.5 * ray_color(ray(rec.p, target - rec.p), world, depth-1);&#125; 效果图如下： image-20221205114904887 两种反射的区别： 更改后阴影不太明显 更换后，两个球体的外观都较亮 其他反射 一种更直观的方法是，对远离撞击点的所有角度都具有统一的散射方向，而不依赖于与法线的角度。许多第一批光线跟踪论文使用了这种漫反射方法（在采用朗伯漫反射之前）。 12345678vec3 random_in_hemisphere(const vec3&amp; normal) &#123; vec3 in_unit_sphere = random_in_unit_sphere(); if (dot(in_unit_sphere, normal) &gt; 0.0) // In the same hemisphere as the normal return in_unit_sphere; else return -in_unit_sphere;&#125; 效果图如下： image-20221205115929288 Chapter 9 金属材质： 让不同的物体有不同的材质，考虑两件事: 产生散射光线（或者说它吸收了入射光线）。 如果散射，说明光线应该衰减多少。 以下给出抽象材料类 1234567891011#ifndef MATERIAL_H#define MATERIAL_H#include &quot;rtweekend.h&quot;struct hit_record;class material &#123; public: virtual bool scatter( const ray&amp; r_in, const hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered) const = 0;&#125;;#endif 对于我们已经拥有的朗伯（漫反射）情况，它可以总是散射并通过其反射率衰减，或者它可以不衰减地散射但吸收一部分光线，或者它可能是这些策略的混合。对于朗伯材料，我们得到了这个简单的类 如果我们生成的随机单位向量正好与法向量相反，则两者相加为零，这将导致零散射方向向量。这会导致以后出现糟糕的情况（无限和NaN），因此我们需要在传递条件之前拦截它。 创建一个新的向量方法vec3:：nearzero（），如果向量在所有维度上都非常接近于零，则返回true 123456789class vec3 &#123; ... bool near_zero() const &#123; // Return true if the vector is close to zero in all dimensions. const auto s = 1e-8; return (fabs(e[0]) &lt; s) &amp;&amp; (fabs(e[1]) &lt; s) &amp;&amp; (fabs(e[2]) &lt; s); &#125; ...&#125;; 123456789101112131415161718192021class lambertian : public material &#123; public: lambertian(const color&amp; a) : albedo(a) &#123;&#125; virtual bool scatter( const ray&amp; r_in, const hit_record&amp; rec, color&amp; attenuation, ray&amp;scattered ) const override &#123; auto scatter_direction = rec.normal + random_unit_vector(); // Catch degenerate scatter direction if (scatter_direction.near_zero()) scatter_direction = rec.normal; scattered = ray(rec.p, scatter_direction); attenuation = albedo; return true; &#125; public: color albedo;&#125;; 镜面反射： image-20221205152318066 设计镜面反射函数 123vec3 reflect(const vec3&amp; v, const vec3&amp; n) &#123; return v - 2*dot(v,n)*n;&#125; 使用上述镜面反射函数，设计金属类 1234567891011121314151617class metal : public material &#123; public: metal(const color&amp; a) : albedo(a) &#123;&#125; virtual bool scatter( const ray&amp; r_in, const hit_record&amp; rec, color&amp; attenuation, ray&amp;scattered ) const override &#123; vec3 reflected = reflect(unit_vector(r_in.direction()), rec.normal); scattered = ray(rec.p, reflected); attenuation = albedo; return (dot(scattered.direction(), rec.normal) &gt; 0); &#125; public: color albedo;&#125;; 效果图： image-20221205152919070 模糊反射： 使用新的小球，随机化反射方向终点 球体越大，反射越模糊。 可以添加一个模糊性参数，即球体的半径（因此零不是扰动） 问题在于对于 big spheres和 grazing rays，会造成表面以下散射 image-20221205153024316 此时，我们更新metal类 1234567891011121314151617class metal : public material &#123; public: metal(const color&amp; a, double f) : albedo(a), fuzz(f &lt; 1 ? f : 1) &#123;&#125; virtual bool scatter( const ray&amp; r_in, const hit_record&amp; rec, color&amp; attenuation, ray&amp;scattered ) const override &#123; vec3 reflected = reflect(unit_vector(r_in.direction()), rec.normal); scattered = ray(rec.p, reflected + fuzz*random_in_unit_sphere()); attenuation = albedo; return (dot(scattered.direction(), rec.normal) &gt; 0); &#125; public: color albedo; double fuzz;&#125;; 效果图： Chapter 10 电解质材料： 水、玻璃和钻石等透明材料是电介质。当光线照射到它们时，它会分裂为反射光线和折射（透射）光线。我们将通过在反射或折射之间随机选择，并且每次交互仅生成一条散射光线来处理这一问题。 斯内尔定律（折射定律） \\[ \\eta ·\\sin\\theta=\\eta&#39;· \\sin\\theta&#39; \\] \\(\\eta\\)是折射率，其中air = 1.0, glass = 1.3–1.7, diamond =2.4 假设折射光线设为\\(R&#39;\\)和折射侧的法向量\\(n&#39;\\)，根据向量分量，有 \\[ R&#39;=R&#39;_⊥+R&#39;_{||} \\] 其中\\(R&#39;_⊥\\)为垂直于\\(n&#39;\\)的分量，\\(R&#39;_{||}\\)为平行于\\(n&#39;\\)的分量，利用折射定律解出 \\[ R&#39;_⊥=\\frac{\\eta}{\\eta&#39;}(R+\\cos\\theta n) \\] \\[ R&#39;_{||}=-\\sqrt{1-|R&#39;_⊥|^2} n \\] 我们限制\\(R\\)和\\(n\\)是单位向量，有 \\[ \\cos\\theta=-R·n \\] 有： \\[ R&#39;_⊥=\\frac{\\eta}{\\eta&#39;}(R+(-R·n) n) \\] 设计函数，计算\\(R&#39;\\) 123456vec3 refract(const vec3&amp; uv, const vec3&amp; n, double etai_over_etat) &#123; auto cos_theta = fmin(dot(-uv, n), 1.0); vec3 r_out_perp = etai_over_etat * (uv + cos_theta*n); vec3 r_out_parallel = -sqrt(fabs(1.0 - r_out_perp.length_squared())) * n; return r_out_perp + r_out_parallel;&#125; 设计电解质类: 123456789101112131415161718192021class dielectric : public material &#123; public: dielectric(double index_of_refraction) : ir(index_of_refraction) &#123;&#125; virtual bool scatter( const ray&amp; r_in, const hit_record&amp; rec, color&amp; attenuation, ray&amp; scattered ) const override &#123; attenuation = color(1.0, 1.0, 1.0); double refraction_ratio = rec.front_face ? (1.0/ir) : ir; vec3 unit_direction = unit_vector(r_in.direction()); vec3 refracted = refract(unit_direction, rec.normal, refraction_ratio); scattered = ray(rec.p, refracted); return true; &#125; public: double ir; // Index of Refraction&#125;; 效果图： image-20221205155754441 但是以上效果还有数学上的错误 当选取\\(\\eta=1.5\\)和\\(\\eta’=1\\)时，有可能造成 \\[ \\sin \\theta&#39;=\\frac{1.5}{1.0}·\\sin\\theta&gt;1.0 \\] 所以在代码中我们做一下限制： 123456789double cos_theta = fmin(dot(-unit_direction, rec.normal), 1.0);double sin_theta = sqrt(1.0 - cos_theta*cos_theta); if (refraction_ratio * sin_theta &gt; 1.0) &#123; // Must Reflect ... &#125; else &#123; // Can Refract ...&#125; 效果图如下： image-20221205155835974 Schlick 近似： 真正的玻璃具有随角度变化的反射率——以陡峭的角度看窗户，它就变成了镜子。这有一个非常丑陋的方程式，但几乎每个人都使用克里斯托夫·施里克（Christophe Schlick）的一个廉价而精确的多项式近似 1234567891011121314151617 if (cannot_refract || reflectance(cos_theta, refraction_ratio) &gt; random_double()) direction = reflect(unit_direction, rec.normal); else direction = refract(unit_direction, rec.normal,refraction_ratio); scattered = ray(rec.p, direction); return true; &#125;public: double ir; // Index of Refractionprivate: static double reflectance(double cosine, double ref_idx) &#123; // Use Schlick&#x27;s approximation for reflectance. auto r0 = (1-ref_idx) / (1+ref_idx); r0 = r0*r0; return r0 + (1-r0)*pow((1 - cosine),5); &#125; 效果图： image-20221205161352791 task 4 阅读《Ray Tracing in One Weekend》的Chapter 11 和Chapter 12 ，实现摄像机的聚焦模糊效果。贴出效果图，简述你遇到的问题以及是如何解决的。 Chapter 11 可定位摄像机 image-20221205170036810 修改摄像机类 123456789101112131415161718192021222324252627282930313233class camera &#123; public: camera( point3 lookfrom, point3 lookat, vec3 vup, double vfov, // vertical field-of-view in degrees double aspect_ratio ) &#123; auto theta = degrees_to_radians(vfov); auto h = tan(theta/2); auto viewport_height = 2.0 * h; auto viewport_width = aspect_ratio * viewport_height; auto w = unit_vector(lookfrom - lookat); auto u = unit_vector(cross(vup, w)); auto v = cross(w, u); origin = lookfrom; horizontal = viewport_width * u; vertical = viewport_height * v; lower_left_corner = origin - horizontal/2 - vertical/2 - w; &#125; ray get_ray(double s, double t) const &#123; return ray(origin, lower_left_corner + s*horizontal + t*vertical - origin); &#125; private: point3 origin; point3 lower_left_corner; vec3 horizontal; vec3 vertical;&#125;; image-20221205170431974 改变视角 1camera cam(point3(-2,2,1), point3(0,0,-1), vec3(0,1,0), 20, aspect_ratio); 效果图： image-20221205170446897 Chapter 12 散焦模糊 通常情况下，所有场景光线都源于观察点。为了实现散焦模糊，生成源自以观察点为中心的磁盘内部的随机场景光线。这个半径越大，散焦模糊越大。你可以把我们的原装相机想象成半径为零的散焦盘（完全没有模糊），因此所有光线都起源于盘中心 12345vec3 random_in_unit_disk() &#123;while (true) &#123;auto p = vec3(random_double(-1,1), random_double(-1,1), 0);if (p.length_squared() &gt;= 1) continue;return p; 1234567891011121314151617181920212223242526272829303132333435363738394041424344class camera &#123; public: camera( point3 lookfrom, point3 lookat, vec3 vup, double vfov, // vertical field-of-view in degrees double aspect_ratio, double aperture, double focus_dist ) &#123; auto theta = degrees_to_radians(vfov); auto h = tan(theta/2); auto viewport_height = 2.0 * h; auto viewport_width = aspect_ratio * viewport_height; w = unit_vector(lookfrom - lookat); u = unit_vector(cross(vup, w)); v = cross(w, u); origin = lookfrom; horizontal = focus_dist * viewport_width * u; vertical = focus_dist * viewport_height * v; lower_left_corner = origin - horizontal/2 - vertical/2 - focus_dist*w; lens_radius = aperture / 2; &#125; ray get_ray(double s, double t) const &#123; vec3 rd = lens_radius * random_in_unit_disk(); vec3 offset = u * rd.x() + v * rd.y(); return ray( origin + offset, lower_left_corner + s*horizontal + t*vertical - origin - offset ); &#125; private: point3 origin; point3 lower_left_corner; vec3 horizontal; vec3 vertical; vec3 u, v, w; double lens_radius;&#125;; 使用大光圈（放大图像） 1234567point3 lookfrom(3,3,2);point3 lookat(0,0,-1);vec3 vup(0,1,0);auto dist_to_focus = (lookfrom-lookat).length();auto aperture = 2.0;camera cam(lookfrom, lookat, vup, 20, aspect_ratio, aperture, dist_to_focus); 效果图： image-20221205171904859 task 5 阅读《Ray Tracing in One Weekend》的Chapter 13 ，渲染一张炫酷真实的图片。贴出效果图，简述你遇到的问题以及是如何解决的。 image-20221205172357629 最后，我们直接在场景中生成很多随机球体，加入随机场景函数如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344hittable_list random_scene() &#123; hittable_list world; auto ground_material = make_shared&lt;lambertian&gt;(color(0.5, 0.5, 0.5)); world.add(make_shared&lt;sphere&gt;(point3(0,-1000,0), 1000, ground_material)); for (int a = -11; a &lt; 11; a++) &#123; for (int b = -11; b &lt; 11; b++) &#123; auto choose_mat = random_double(); point3 center(a + 0.9*random_double(), 0.2, b +0.9*random_double()); if ((center - point3(4, 0.2, 0)).length() &gt; 0.9) &#123; shared_ptr&lt;material&gt; sphere_material; if (choose_mat &lt; 0.8) &#123; // diffuse auto albedo = color::random() * color::random(); sphere_material = make_shared&lt;lambertian&gt;(albedo); world.add(make_shared&lt;sphere&gt;(center, 0.2, sphere_material)); &#125; else if (choose_mat &lt; 0.95) &#123; // metal auto albedo = color::random(0.5, 1); auto fuzz = random_double(0, 0.5); sphere_material = make_shared&lt;metal&gt;(albedo, fuzz); world.add(make_shared&lt;sphere&gt;(center, 0.2,sphere_material)); &#125; else &#123; // glass sphere_material = make_shared&lt;dielectric&gt;(1.5); world.add(make_shared&lt;sphere&gt;(center, 0.2,sphere_material)); &#125; &#125; &#125; &#125; auto material1 = make_shared&lt;dielectric&gt;(1.5); world.add(make_shared&lt;sphere&gt;(point3(0, 1, 0), 1.0, material1)); auto material2 = make_shared&lt;lambertian&gt;(color(0.4, 0.2, 0.1)); world.add(make_shared&lt;sphere&gt;(point3(-4, 1, 0), 1.0, material2)); auto material3 = make_shared&lt;metal&gt;(color(0.7, 0.6, 0.5), 0.0); world.add(make_shared&lt;sphere&gt;(point3(4, 1, 0), 1.0, material3)); return world;&#125; 修改主函数 12345678910111213141516171819202122232425int main() &#123; // Image const auto aspect_ratio = 3.0 / 2.0; const int image_width = 1200; const int image_height = static_cast&lt;int&gt;(image_width / aspect_ratio); const int samples_per_pixel = 500; const int max_depth = 50; // World auto world = random_scene(); // Camera point3 lookfrom(13,2,3); point3 lookat(0,0,0); vec3 vup(0,1,0); auto dist_to_focus = 10.0; auto aperture = 0.1; camera cam(lookfrom, lookat, vup, 20, aspect_ratio, aperture, dist_to_focus); // Render std::cout &lt;&lt; &quot;P3\\n&quot; &lt;&lt; image_width &lt;&lt; &#x27; &#x27; &lt;&lt; image_height &lt;&lt; &quot;\\n255\\n&quot;; for (int j = image_height-1; j &gt;= 0; --j) &#123; ...&#125; image-20221205174319831 如效果图所示，玻璃球并没有真正的阴影，这使得它们看起来像是漂浮的 那是因为玻璃球下的大球体上的一个点仍然有很多光线照射到它，因为天空被重新排列而不是被阻挡。使得玻璃球没有阴影 task 6 阅读《Ray Tracing The Next Week》的Chapter 3 ，为场景物体构建一颗BVH树（Bounding Volume Hierarchies，包围体层次结构），加速追踪的射线与场景的求交计算过程。对比有无BVH树的渲染时间，简述你遇到的问题以及是如何解决的。 一般来说，场景加速结构分为两类， 按空间划分的（比如四叉树，八叉树,KD-Tree）等结构 以BVH为代表的按物体划分的加速结构了 BVH：通过一个二叉查找树结构，存储场景中的物体，一般会和包围盒结合在一起使用。只要一条光线与父节点做判断，判定结果是不穿过父节点，则所有的子节点都可以在此次采样中被剔除。 以书上的图来举例：比如光线和紫色的包围盒做检测，判定是不会穿过紫色包围盒，则红色和蓝色的包围盒全部都不用做检测了。 在这里插入图片描述 我们使用的包围盒是AABB包围盒，直观来说，就是直接在物体外面套一个刚好能装下这个物体的盒子。 而判断是否与包围盒相交的算法我们使用的是堆叠法 在这里插入图片描述 由于我们的光线具有唯一的表达式 p(t) = a + tb（a为起点，b为方向向量），所以你只需要分别求出和蓝色平面与绿色平面相交的t值。然后检查这个t值有没有重叠，有的话就代表有相交。同样的，这个方法可以推广至三维。 BVH树的构造过程如下（参考博客）： 首先BVH是按照物体的划分方式，在三维空间中，我们有三个轴可以选取。由于BVH是二叉查找树结构，我们需要每一次都对随机选取的轴进行按轴排序，然后计算出中点，进行进一步的递归分割。 这里递归分割的终止条件就是看每一次分割之后剩下多少物体。如果剩下的物体数量&lt;=2，那么就终止分割，如果剩下的物体数量&gt;2，那么就让左右子树指针指向一个新的BVH_NODE，并且对应调用bvh_node的构造函数 上述分割结束之后，此时构造应该来到了最底层，即左右指针指向的是基本图元。那么，我们又从最底层开始逐渐网上调用BouddingBox来构造包围盒。 在最底层的基本图元上，不同的类有对应的包围盒方法（代码里面写的很清楚，如果是个球体就用正方体包围起来）在上升过程中，会在递归的本层构造刚好能覆盖左右子树的包围盒。（在递归代码中，left_box和right_box会等于下一层的BoudingBox，然后本层的BoudingBox等于在这两个盒子之上多加一个） 递归结束，整个BVH树也就构建好了 在完成了BVH树的部署之后，就可以在场景的最后返回 1return static_cast&lt;hittable_list&gt;(make_shared&lt;bvh_node&gt;(world,0,1)); 使用了一次强制转换，而且是两个子类，hittable_list和bvh_node之间的转换。所以这个地方应该是将最后一个bvh_node（即根节点）推入了hittable_list的队列里面。 这样不用和场景中的每一个物体去求交，而是和相交的包围盒里面的物体去求交，会加速不少。 时间所需对比 非BVH树 BVH树 可以看到非BVH树用时1390s而BVH树只需要320s Task 7 跟着提供的教程实现了一个光线追踪渲染器，谈谈你对基于光线追踪渲染的理解以及你的困惑、感想和收获，当然也欢迎同学们提出宝贵的作业意见反馈。 理解：通过一步一步建立一个光线追踪渲染器，可以发现该渲染器并不是一蹴而就的。其中需要从初步色彩渲染开始，再到确定一个需要渲染的物体，需要建立一定的几何空间，通过光线命中函数，进而对物体进行渲染。在渲染的过程中，为了使得效果图更加真实，我们需要对物体做漫反射，阴影，金属反射（镜面反射），折射效果，在实现效果的过程中，我们需要明确摄像机，目标物体，在世界空间中相对位置，通过数学上的空间线性变换，确定光线路径（实际上就是呈现色彩效果），在构建BVH树之后，我发现渲染速度明显加快了，速度甚至提升为原来的4倍，在图形学方面，我觉得不仅需要还原物体的真实性，而且也要提高渲染的效率。所以通过运用所学习的算法（BVH树），对物体进行划分，只要一条光线与父节点做判断，判定结果是不穿过父节点，则所有的子节点都可以在此次采样中被剔除，相当于做了一个剪枝，减少递归（遍历次数），从而提高渲染效率，但是这以增大了空间复杂度。 困难：在实验过程中，出现的许多头文件冲突的情况，为此，需要理清楚每个头文件的引用次序结构，从而消除报错。 感想收获：最大的收获其实就是获得了一个不错的光线追踪渲染器模板，但是这个模板还不够成熟，因为还有许多更高效率的算法，能够减少渲染时间，同时可以发现，这份代码的逻辑结构相当不错，很容易理清光线追踪渲染逻辑。","categories":[],"tags":[]},{"title":"【计算机图形学】Assignment3 Lighting Texturing","slug":"【计图】hw3 ","date":"2022-11-28T16:00:00.000Z","updated":"2023-03-15T08:44:12.985Z","comments":true,"path":"2022/11/29/【计图】hw3 /","link":"","permalink":"https://klc1006.github.io/2022/11/29/%E3%80%90%E8%AE%A1%E5%9B%BE%E3%80%91hw3%20/","excerpt":"","text":"task 1 最邻近采样算法 设i+u, j+v(i, j为正整数， u, v为大于零小于1的小数，下同)为待求象素坐标，则待求象素灰 度的值 f(i+u, j+v) 如下图所示： t 若我们在A区域插入像素，该像素值与（i，j）的值相同，同理若是在B区域插入像素，这该像素值与（i+1,j）的值相同。 该算法实际上就是对输入的uv坐标作四舍五入，在算法之前我们需要将纹理坐标uv 从$[0,1] ×[0,1] \\(映射到\\)[0,width-1] ×[0,height-1] $ 函数texture.readPixel(25,35,r,g,b,a)可以读取 坐标为(25, 35)的像素值 12345678910111213141516171819glm::vec4 TRTexture2DSampler::textureSampling_nearest(const TRTexture2D &amp;texture, glm::vec2 uv)&#123; unsigned char r = 255, g = 255, b = 255, a = 255; //Task1: Implement nearest sampling algorithm for texture sampling // Note: You should use texture.readPixel() to read the pixel, and for instance, // use texture.readPixel(25,35,r,g,b,a) to read the pixel in (25, 35). // But before that, you need to map uv from [0,1]*[0,1] to [0,width-1]*[0,height-1]. &#123; //四舍五入 int u=(int)(uv.x*(texture.getWidth()-1)+0.5); int v=(int)(uv.y*(texture.getHeight()-1)+0.5); //也可以使用round()函数 texture.readPixel(u,v,r,g,b,a); &#125; constexpr float denom = 1.0f / 255.0f; return glm::vec4(r, g, b, a) * denom;&#125; 实验效果 image-20221109203853373 如图仅仅做到显示纹理效果 task 2 进入摄像机的光线分为三个部分，每个部分使用一种方法来计算它的贡献度，这三个部分分别是环境光(Ambient)、漫反射(Diffuse)和高光反射(Specular)。 衰减 随着光线传播距离的增长逐渐削减光的强度通常叫做衰减(Attenuation)。随距离减少光强度的一种方式是使用一个线性方程。这样的方程能够随着距离的增长线性地减少光的强度，从而让远处的物体更暗。然而，这样的线性方程通常会看起来比较假。在现实世界中，灯在近处通常会非常亮，但随着距离的增加光源的亮度一开始会下降非常快，但在远处时剩余的光强度就会下降的非常缓慢了。所以，我们需要一个不同的公式来减少光的强度。 下面这个公式根据片段距光源的距离计算了衰减值，之后我们会将它乘以光的强度向量： image-20221109204346815 在这里dd代表了片段距光源的距离。接下来为了计算衰减值，我们定义3个（可配置的）项：常数项Kc、一次项Kl和二次项Kq。 常数项通常保持为1.0，它的主要作用是保证分母永远不会比1小，否则的话在某些距离上它反而会增加强度，这肯定不是我们想要的效果。 一次项会与距离值相乘，以线性的方式减少强度。 二次项会与距离的平方相乘，让光源以二次递减的方式减少强度。二次项在距离比较小的时候影响会比一次项小很多，但当距离值比较大的时候它就会比一次项更大了。 衰减效果如下 img 环境光(Ambient) 环境光也称间接光，是光线经过周围环境表面多次反射后形成的，利用它可以描述一块区域的亮度，在光照模型中，通常用一个常量来表示。 漫反射(Diffuse) 当光线照射到一个点时，该光线会被均匀的反射到各个方向，这种反射称为漫反射。也就是说，在漫反射中，视角的位置是不重要的，因为反射是完全随机的，因此可以认为漫反射光在任何反射方向上的分布都是一样的，如下图所示 img 影响漫反射光照强度的因素 入射光线与法线的夹角(入射光线角度) 入射光线自身的强度 入射光线与法线的夹角 img 假设有一块很小的区域dA。当法线向量n与光照向量L平行时，区域dA受到的光线照射最多。随着n和L之间的夹角θ逐渐增大，区域dA*受到的光线照射量会越来越少 （因为很多光线都无法照射到dA表面上了）。冬天的时候我们觉得很冷，夏天又非常热，主要也是太阳光线与地面形成的夹角变化造成的。 兰伯特余弦定律(Lambert Consine Law)中指出，漫反射的大小取决于表面法线和光线的夹角，当夹角越大时，漫反射分量越小，当夹角接近90度时，我们认为漫反射几乎为零。 img 也就是说，反射光线的强度与表面法线和光源方向之间夹角的余弦值成正比。当表面法线与光线的夹角大于90度，它们的余弦值小于0，这没有实际意义，因此将其置为0，可以用下面的公式表示 \\[ f(θ)=max(0,cosθ)=max(0,L•n) \\] L•n就是求L在n上的投影，下面是该函数的图像表示 img 入射光线强度 灯光的强度会随着距离的增加而衰减，这是显而易见的。假设我们有一个光源，在距离它单位1的圆上(图中最内圈)每一个点接收到光的强度是I。那么根据能量守恒定律，且不考虑衰减，在距离光源r位置的圆上每个点接收到光的强度就是\\(I/r^2\\)。 img 得出漫反射的公式 \\[ L_d=k_d(I/r2)max(0,n·L) \\] 高光反射(Specular) 高光反射也称为镜面反射，若物体表面很光滑，当平行入射的光线射到这个物体表面时，仍会平行地向一个方向反射出来。 下图中一根入射光线l，照射在光滑的平面上，会沿着R方向反射，由于平面并非完全光滑，所以反射光的方向并非只有R一个点，而是R周边的一小块区域，只要眼睛(摄像机)在R附近都可以看得到，越靠近R反射光照强度越大。我们可以得出一条结论：高光反射和观察角度有关。 img phong模型中认为，高光反射的强度与反射光线*R*和观察角度*v*之间夹角的余弦值成正比。计算它的强度，相当于是求向量v在R上的投影。怎么求R呢？ 设l与n之间的夹角为θ，将m与l的顶部相连，并且m垂直n，向量p的绝对值|p|是l在n上的投影 根据一些已有的知识容易得出 \\[ R=2m−l \\] 现在变成了怎么计算m \\[ m=l−p \\] 因为|p|是l在n上的投影 \\[ p=|p|·\\frac{n}{|n|} \\] \\[ |p|=|l|cosθ \\] \\[ cosθ=\\frac{l·n}{|l|·|n|} \\] 结合上面三个公式可得： \\[ p=|l|\\frac{l·n}{|l|·|n|}·\\frac{n}{|n|}=\\frac{l·n}{|n|^2}·n \\] 因为n是单位向量，所以|n|=1，现在已经具备求出投影R的条件了 \\[ R=l−2(l·n)·n \\] 完整的高光反射公式可以表示为： \\[ L_s=k_s(I/r^2)max(0,cosα)^p=k_s(I/r^2)max(0,v·R)^p \\] 其中ks是高光反射系数，I/r2是当前点接受的光照强度。 注意到两个向量作标准化后，点乘就是两个向量夹角的余弦值 代码实现 12345678910111213141516171819float distance=glm::tlength(light.lightPos - fragPos);attenuation=1.0 / (light.attenuation.x + light.attenuation.y * distance + light.attenuation.z * (distance * distance));//ambientambient=amb_color*light.lightColor;//diffusefloat diff=glm::max(glm::dot(normal,lightDir),0.0f);diffuse=diff*dif_color*light.lightColor*m_kd;//specularfloat specularStrength=0.5f;//reflectDirglm::vec3 reflectDir=glm::reflect(-lightDir,normal);float spec =glm::pow(glm::max(glm::dot(viewDir,reflectDir),0.0f),m_shininess);//task 3//halfwayDir//glm::vec3 halfwayDir=glm::normalize(lightDir+viewDir);//float spec =glm::pow(glm::max(glm::dot(normal,halfwayDir),0.0f),m_shininess);//specular=spec*spe_color*light.lightColor; 实验效果 环境光 image-20221109203349372 漫反射 image-20221109203445778 环境光+漫反射 image-20221109204101905 高光反射 image-20221109203506520 最终效果 image-20221109203523561 task 3 实现Blinn-Phong光照模型 计算反射光线R虽然不是很难，但还是有点繁琐，有没有其他方法计算呢？Blinn提出了一个简单的修改方法来得到类似的效果，通过对向量l和向量v取平均然后归一化得到一个新的向量h，其中h被称为半程向量(bisector)，使用h与法线n点乘来计算高光，这样就可以避免计算R了。 被称为半程向量(bisector)，使用h与法线n点乘来计算高光，这样就可以避免计算R了。 \\[ h=\\frac{l+v}{|l|+|v|} \\] 使用半程向量计算的公式和之前类似，不过计算的时候简单了一些，具体公式如下。 \\[ L_s=k_s(I/r^2)max(0,cosα)^p=k_s(I/r^2)max(0,n·h)^p \\] 代码实现 将高光反射作更改 12345678//reflectDir//glm::vec3 reflectDir=glm::reflect(-lightDir,normal);//float spec =glm::pow(glm::max(glm::dot(viewDir,reflectDir),0.0f),m_shininess);//task 3//halfwayDirglm::vec3 halfwayDir=glm::normalize(lightDir+viewDir);float spec =glm::pow(glm::max(glm::dot(normal,halfwayDir),0.0f),m_shininess);specular=spec*spe_color*light.lightColor; 实验结果 实验效果基本相当，仅仅改善了计算方式，并且使得计算更加合理 image-20221109203523561 task 4 在这里插入图片描述 如图所示，我们需要求P点的像素值。我们已知了Q11、Q21、Q12、Q22、P的坐标。也知道Q11、Q21、Q12、Q22的像素值。所以先用关于X的单线性插值去分别计算R1、R2的像素值 在这里插入图片描述 在右边的等式中的字母f(Q11)、f(Q12)、f(Q21)、f(Q22)、x1、x2、x都是已知的，求出的f(x,y1)与f(x,y2）即为R1、R2的像素值。 再使用关于y方向的单线性插值计算P点的像素值 得出： 在这里插入图片描述 在右边的等式中的字母y1、y2、y都是已知的，f(x,y1)与f(x,y2）即为上一个式子中求出的R1、R2像素值。 **注意：在算法之前我们需要将纹理坐标uv 从$[0,1] ×[0,1] \\(映射到**\\)[0,width-1] ×[0,height-1] $ 12345678910111213141516171819202122232425262728293031323334353637383940//线性插值计算公式glm::vec4 cal(float x,float x2,float x1,glm::vec4 &amp;I1,glm::vec4 &amp;I2)&#123; glm::vec4 I=((x2-x)*I1+(x-x1)*I2)/(x2-x1); return I;&#125; glm::vec4 TRTexture2DSampler::textureSampling_bilinear(const TRTexture2D &amp;texture, glm::vec2 uv)&#123; //Note: Delete this line when you try to implement Task 4. // return textureSampling_nearest(texture, uv); unsigned char r4 = 255, g4 = 255, b4 = 255, a4 = 255; unsigned char r1 = 255, g1 = 255, b1 = 255, a1 = 255; unsigned char r2 = 255, g2 = 255, b2 = 255, a2 = 255; unsigned char r3 = 255, g3 = 255, b3 = 255, a3 = 255; // float x=uv.x*(texture.getWidth()-1); float y=uv.y*(texture.getHeight()-1); int x1=floor(uv.x*(texture.getWidth()-1)); int y1=floor(uv.y*(texture.getHeight()-1)); // x1=uv.x*(texture.getWidth()-1); // y1=uv.y*(texture.getHeight()-1); //读出最邻近的四个顶点 texture.readPixel(x1,y1,r1,g1,b1,a1); texture.readPixel(x1+1,y1+1,r2,g2,b2,a2); texture.readPixel(x1,y1+1,r3,g3,b3,a3); texture.readPixel(x1+1,y1,r4,g4,b4,a4); //作线性线性插值计算 glm::vec4 I1=cal(x,x1+1,x1,glm::vec4(r4,g4,b4,a4),glm::vec4(r1,g1,b1,a1)); glm::vec4 I2=cal(x,x1+1,x1,glm::vec4(r3,g3,b3,a3),glm::vec4(r2,g2,b2,a2)); glm::vec4 I=cal(y,y1+1,y1,I1,I2); constexpr float denom = 1.0f / 255.0f; return I* denom; //Task4: Implement bilinear sampling algorithm for texture sampling // Note: You should use texture.readPixel() to read the pixel, and for instance, // use texture.readPixel(25,35,r,g,b,a) to read the pixel in (25, 35).&#125; 实验结果 双线性插值 image-20221109202220065 最邻近采样 image-20221109202245850 可以看到双线性插值明显改善颗粒感，因为它有效在像素上作加权平滑操作 task 5 简单实现聚光灯 OpenGL中聚光是用一个世界空间位置、一个方向和一个切光角(Cutoff Angle)来表示的，切光角指定了聚光的半径（译注：是圆锥的半径不是距光源距离那个半径）。对于每个片段，我们会计算片段是否位于聚光的切光方向之间（也就是在锥形内），如果是的话，我们就会相应地照亮片段。 img LightDir：从片段指向光源的向量。 SpotDir：聚光所指向的方向（这里我们直接设定SpotDir=viewDir）。 Phiϕ：指定了聚光半径的切光角。落在这个角度之外的物体都不会被这个聚光所照亮。 Thetaθ：LightDir向量和SpotDir向量之间的夹角。在聚光内部的话θ值应该比ϕ值小 123456789101112131415161718192021222324252627float cutoff=glm::cos(glm::radians(12.5f));float theta=glm::dot(lightDir,glm::normalize(viewDir)); //ambientambient=amb_color*light.lightColor;if(theta&gt;cutoff)&#123; //diffuse float diff=glm::max(glm::dot(normal,lightDir),0.0f); diffuse=diff*dif_color*light.lightColor*m_kd; //specular float specularStrength=0.5f; //reflectDir // glm::vec3 reflectDir=glm::reflect(-lightDir,normal); // float spec =glm::pow(glm::max(glm::dot(viewDir,reflectDir),0.0f),m_shininess); //halfwayDir glm::vec3 halfwayDir=glm::normalize(lightDir+viewDir); float spec =glm::pow(glm::max(glm::dot(normal,halfwayDir),0.0f),m_shininess); specular=spec*spe_color*light.lightColor;fragColor.x += (ambient.x + diffuse.x + specular.x) * attenuation;fragColor.y += (ambient.y + diffuse.y + specular.y) * attenuation;fragColor.z += (ambient.z + diffuse.z + specular.z) * attenuation; &#125;else&#123; fragColor+=glm::vec4(ambient* attenuation,0); &#125; 实验效果 image-20221109201250867 做平滑处理后，聚光的边界消失 image-20221109201259652","categories":[],"tags":[]},{"title":"【计算机图形学】Assignment2_Rasterization_ZBuffering","slug":"【计图】hw2","date":"2022-10-25T16:00:00.000Z","updated":"2023-03-15T08:44:20.570Z","comments":true,"path":"2022/10/26/【计图】hw2/","link":"","permalink":"https://klc1006.github.io/2022/10/26/%E3%80%90%E8%AE%A1%E5%9B%BE%E3%80%91hw2/","excerpt":"","text":"Task1 实现Bresenham直线光栅化算法（你应该要用到线性插值函数VertexData::lerp（ ）参考链 接。 该函数在TRShaderPipeline.cpp 文件中，其中的from 和to 参数分别代表直线的起点和终点， screen_width 和screen_height 是窗口的宽高，超出窗口的点应该被丢弃。rasterized_points 存 放光栅化插值得到的点。 我们需要做的任务实际上就是描绘一个直线线段，首先我们定义两个点（x1，y1）（x2，y2），得到以下数学符号标记 \\[ \\Delta x=x_1-x_0 &gt;0,\\Delta y=y_1-y_0&gt;0,m=\\frac{\\Delta y}{\\Delta x} \\] 其中m为斜率 我假设第i此迭代获得的点是（xi，yi），那么第i+1次迭代获取的点可能是（xi+1，yi）或者（xi+1，yi+1），实际上，我们需要选取的是距离直线线段在该y轴上的交点最近的点。 image-20221026104524096 image-20221026104652240 根据以上图示，我们需要计算d_upper 和d_lower以确定选取那个点，所以取值如下 \\[ d_{upper}=\\bar{y_i}+1-\\bar{y}_{i+1}=\\bar{y}_i+1-m\\bar{x}_{i+1}-B \\] \\[ d_{upper}=\\bar{y_i}-\\bar{y}_{i+1}=m\\bar{x}_{i+1}+B-\\bar{y}_i \\] 当d_lower-d_upper&gt;0时，取右上方点 当d_lower-d_upper&lt;0时，取左上方点 \\[ d_{lower}-d_{upper}=2m(\\bar{x}_i+1)-2\\bar{y}_{i}+2B-1 \\] 为了进一步简化判断，我们将斜率等式两边同时乘上deltaX&gt;0,正负号不变 定义以下等式 \\[ p_i=\\Delta x \\cdot(d_{lower}-d_{upper})=2\\Delta y\\cdot x_i-2\\Delta x\\cdot\\bar{y}_i+c \\] \\[ c=(2B-1)\\Delta x+2\\Delta y \\] 使用p_i作为选取的标准，进一步简化 \\[ p_{i+1}-p_{i}=2\\Delta y-2\\Delta x(\\bar{y}_{i+1}-\\bar{y}_i) \\] 这样我们使用p_i来判断，选取点 \\[ 若p_i\\leq0,选择右边的点,此时 \\bar{y}_{i+1}=\\bar{y}_i,p_{i+1}=p_{i}+2\\Delta y \\] \\[ 若p_i\\geq0,选择右上角的点,此时 \\bar{y}_{i+1}=\\bar{y}_i+1,p_{i+1}=p_{i}+2\\Delta y-2\\Delta x \\] 按照上述逻辑，写出完善代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283void TRShaderPipeline::rasterize_wire_aux( const VertexData &amp;from, const VertexData &amp;to, const unsigned int &amp;screen_width, const unsigned int &amp;screen_height, std::vector&lt;VertexData&gt; &amp;rasterized_points)&#123; //Task1: Implement Bresenham line rasterization // Note: You shold use VertexData::lerp(from, to, weight) for interpolation, // interpolated points should be pushed back to rasterized_points. // Interpolated points shold be discarded if they are outside the window. // from.spos and to.spos are the screen space vertices. //For instance: rasterized_points.push_back(from); //rasterized_points.push_back(to); int dx = to.spos.x - from.spos.x; int dy = to.spos.y - from.spos.y; int stepX = 1, stepY = 1; //judge sign if (dx &lt; 0) &#123; stepX = -1; dx = -dx; &#125; if (dy) &#123; stepY = -1; dy = -dy; &#125; int d2x = 2 * dx, d2y = 2 * dy; int d2y_minus_d2x = d2y - d2x; int sx = from.spos.x; int sy = from.spos.y; VertexData temp; if (dy &lt;=dx) &#123; int flag = d2y - d2x; for (int i = 0; i &lt;= dx; i++) &#123; //interpolation temp = VertexData::lerp(from, to, static_cast&lt;double&gt;(i) / dx); // temp.lerp(from, to, static_cast&lt;double&gt;(i) / dx); //add to rasterized if(temp.spos.x&lt;screen_width&amp;&amp;temp.spos.x&gt;0&amp;&amp;temp.spos.y&lt;screen_width&amp;&amp;temp.spos.y&gt;0) rasterized_points.push_back(temp); sx += stepX; if (flag &lt;= 0) &#123; flag += d2y; &#125; else &#123; sy += stepY; flag += d2y_minus_d2x; &#125; &#125; &#125; else &#123; int flag = d2x - d2y; for (int i = 0; i &lt;= dy; i++) &#123; //interpolation temp = VertexData::lerp(from, to, static_cast&lt;double&gt;(i) / dy); temp.lerp(from, to, static_cast&lt;double&gt;(i) / dy); //add to rasterized if(temp.spos.x&lt;screen_width&amp;&amp;temp.spos.x&gt;0&amp;&amp;temp.spos.y&lt;screen_width&amp;&amp;temp.spos.y&gt;0) rasterized_points.push_back(temp); sy += stepY; if (flag &lt;= 0) &#123; flag += d2x; &#125; else &#123; sx += stepX; flag -= d2y_minus_d2x; &#125; &#125; &#125; rasterized_points.push_back(to);&#125; 实验效果 image-20221026201517448 Task2 实现简单的齐次空间裁剪，简述你是怎么做的。 该函数在TRRenderer.cpp 文件中，输入的v0 、v1 和v2 是三角形的三个顶点，其中的v0.cpos 、v1.cpos 和v2.cpos 分别存储在齐次裁剪空间的顶点坐标（注意这是个四维齐次坐标）。如果顶点坐标在可见的视锥体之内的话，那么x 、y 、z 的取值应该在[-w,w] 之间，而w 应该在[near,far]之间。（ near 和far 是视锥体的近平面和远平面） 按照以上算法描述，完善代码 1234567891011121314151617181920212223std::vector&lt;TRShaderPipeline::VertexData&gt; TRRenderer::cliping( const TRShaderPipeline::VertexData &amp;v0, const TRShaderPipeline::VertexData &amp;v1, const TRShaderPipeline::VertexData &amp;v2) const&#123; //Clipping in the homogeneous clipping space //Task2: Implement simple vertex clipping // Note: If one of the vertices is inside the [-w,w]^3 space (and w should be in [near, far]), // just return &#123;v0, v1, v2&#125;. Otherwise, return &#123;&#125; // Please Use v0.cpos, v1.cpos, v2.cpos // m_frustum_near_far.x -&gt; near plane // m_frustum_near_far.y -&gt; far plane if(v0.cpos.x&lt;v0.cpos.w&amp;&amp;v0.cpos.x&gt;-v0.cpos.w &amp;&amp; v0.cpos.y&lt;v0.cpos.w&amp;&amp;v0.cpos.y&gt;-v0.cpos.w &amp;&amp; v0.cpos.z&lt;v0.cpos.w&amp;&amp;v0.cpos.z&gt;-v0.cpos.w &amp;&amp; near&lt;v0.cpos.w&amp;&amp;far&gt;v0.cpos.w ) return &#123; v0, v1, v2 &#125;; if(v1.cpos.x&lt;v1.cpos.w&amp;&amp;v1.cpos.x&gt;-v1.cpos.w &amp;&amp; v1.cpos.y&lt;v1.cpos.w&amp;&amp;v1.cpos.y&gt;-v1.cpos.w &amp;&amp; v1.cpos.z&lt;v1.cpos.w&amp;&amp;v1.cpos.z&gt;-v1.cpos.w &amp;&amp; near&lt;v1.cpos.w&amp;&amp;far&gt;v1.cpos.w ) return &#123; v0, v1, v2 &#125;; if(v2.cpos.x&lt;v2.cpos.w&amp;&amp;v2.cpos.x&gt;-v2.cpos.w &amp;&amp; v2.cpos.y&lt;v2.cpos.w&amp;&amp;v2.cpos.y&gt;-v2.cpos.w &amp;&amp; v2.cpos.z&lt;v2.cpos.w&amp;&amp;v2.cpos.z&gt;-v2.cpos.w &amp;&amp; near&lt;v2.cpos.w&amp;&amp;far&gt;v2.cpos.w ) return &#123; v0, v1, v2 &#125;; return &#123;&#125;;&#125; 实验效果 image-20221026201714339 Task3 我们将在ndc空间做三角形的背向面剔除，以逆时针环绕顺序为正面。在ndc空间，三角形的顶点坐标的x 、y 和z 取值在[-1,1] 之间，摄像机在坐标原点(0,0,0) 处，朝向(0,0,-1) 方向（右手坐标系）。我们可以通过叉乘得到三角形的法线朝向，然后与视线方向进行点乘，根据点乘结果大于0 还是小于0 来判断三角形此时是否是正面朝向还是背面朝向，如果背面朝向，则应该直接剔除，不进行光栅化等后续的处理，这就是背向面剔除的基本原理。你要填充的函数在TRRenderer.cpp 文件中，如下所示，其中传入的参数为ndc空间下的三角形顶点坐 标。 思路： 算法过程其实很简单，通过计算v0，v1，v2的三角形平面的法向朝向，通过法向朝向判断正向还是背向，在这里只需要与视角方向点乘即可判断。 完善代码 1234567891011121314151617181920bool TRRenderer::isTowardBackFace(const glm::vec4 &amp;v0, const glm::vec4 &amp;v1, const glm::vec4 &amp;v2) const&#123; //Back face culling in the ndc space // Task3: Implement the back face culling // Note: Return true if it&#x27;s a back-face, otherwise return false. glm::vec3 view= glm::vec3(0,0,-1); glm::vec4 l1=v1-v0; glm::vec4 l2=v2-v1; glm::vec3 line1=glm::vec3(l1.x,l1.y,l1.z); glm::vec3 line2=glm::vec3(l2.x,l2.y,l2.z); glm::vec3 normal=glm::normalize(glm::cross(line1,line2)); //点乘大于0，返回true ，属于背向 if(glm::dot(normal,view)&gt;0) return true; else //点乘大于0，返回false ，属于正向 return false;&#125; 实验效果 image-20221026201903315 Task4 实现基于Edge-function的三角形填充算法。 基于Edge-function的三角形填充算法首先计算三角形的包围盒，然后遍历包围盒内的像素点，判断该像素点是否在三角形内部，这就是它的基本原理 包围盒 image-20221026131518843 如图遍历三角形的三个顶点，计算三角形的包围盒。得到包围盒后在去遍历包围盒的像素点。 边缘函数 假设三角形的边缘可以看作是将2D平面（图像的平面）一分为二的线。 Pineda方法的原理是找到一个称为边缘函数的函数。 当我们测试该点在哪条线的哪一侧（图2中的点P）时，该函数将返回负数。 在该行的左边，当正点在该行的右边时为正数； 在该点正好在该行上时为零 image-20221026124654170 将以上原理拓展到三角形的三个边缘，如果现在将相同的方法应用于其他两个边（v1-v2和v2-v0），则可以清楚地看到存在一个区域（白色三角形），其中所有点均为正。如果P实际上是像素中心的一个点，则可以使用此方法查找像素是否与三角形重叠。如果在这一点上，我们发现边缘函数为所有三个边缘返回正数，则像素包含在三角形中（或可能位于其边缘之一上），如下图所示 image-20221026124847420 这里的顺序一定要是顺时针(如果为逆时针，则内部为负数)，Pinada使用的函数也恰好是线性的，这意味着可以递增地计算它 综上定义以下边函数（以v0 v1为例） \\[ E_{01}=(P.x-V_0.x)*(V_1.y-V_0.y)-(P.y-V_0.y)*(V_1.x-V_0.x) \\] 该函数值和点P有如下关系： E(P) &gt; 0 ，P在右侧 E(P) = 0 ，P在线上 E(P) &lt; 0 ，P在左侧 该公式实际上是向量V0P和向量V0P的叉积，即一个平行四边形面积，该面积公式可运用到以下重心坐标的参数计算。 重心坐标 我们知道，可以运用以下公式表示三角形内任意一个点 \\[ P=\\lambda_0*V_0+\\lambda_1*V_1+\\lambda_2*V_2 \\] 其中 \\[ \\lambda_0+\\lambda_1+\\lambda_2=1 \\] 假设您在三角形的每个顶点上定义了一种颜色。假设V0为红色，V1为绿色，V2为蓝色。如下图： image-20221026130304108 根据的到的重心系数向量，就可以，给三角形内部渲染，公式定义为 \\[ C_P=\\lambda_0*C_{V_0}+\\lambda_1*C_{V_1}+\\lambda_2*C_{V_2} \\] 所以在这里，我们关键需要求出重心系数向量 image-20221026130659752 根据面积得知 \\[ S_{\\triangle V_0 V_1 V_2}=S_{\\triangle V_0 V_1 P}+S_{\\triangle V_1 V_2 P} +S_{\\triangle V_2 V_0 P} \\] 根据上面得知的边缘函数，计算面积 \\[ S_{\\triangle V_0 V_1 P}=\\frac{1}{2}E_{01}(P)\\\\ S_{\\triangle V_1 V_2 P}=\\frac{1}{2}E_{12}(P) \\\\ S_{\\triangle V_2 V_0 P}=\\frac{1}{2}E_{20}(P) \\] 用边缘函数求解重心坐标 \\[ \\lambda_0=\\frac{S_{\\triangle V_1 V_2 P}} {S_{\\triangle V_0 V_1 V_2}}\\\\ \\lambda_1=\\frac{S_{\\triangle V_2 V_0 P}} {S_{\\triangle V_0 V_1 V_2}}\\\\ \\lambda_2=\\frac{S_{\\triangle V_0 V_1 P}} {S_{\\triangle V_0 V_1 V_2}}\\\\ \\] 按照上述的算法描述，完善代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566float edgeFunction( glm::vec2 &amp;a, glm::vec2 &amp;b, glm::vec2 &amp;c)&#123; return (c.x-a.x)*(b.y-a.y)-(c.y-a.y)*(b.x-a.x);&#125;void TRShaderPipeline::rasterize_fill_edge_function( const VertexData &amp;v0, const VertexData &amp;v1, const VertexData &amp;v2, const unsigned int &amp;screen_width, const unsigned int &amp;screene_height, std::vector&lt;VertexData&gt; &amp;rasterized_points)&#123; //Edge-function rasterization algorithm //Task4: Implement edge-function triangle rassterization algorithm // Note: You should use VertexData::barycentricLerp(v0, v1, v2, w) for interpolation, // interpolated points should be pushed back to rasterized_points. // Interpolated points shold be discarded if they are outside the window. // v0.spos, v1.spos and v2.spos are the screen space vertices. //For instance: rasterized_points.push_back(v0); rasterized_points.push_back(v1); rasterized_points.push_back(v2); VertexData temp; //set the max and min double minX,maxX,minY,maxY; minX=maxX=v0.spos.x; minY=maxY=v0.spos.y; minX=std::min(minX,(double)v1.spos.x); maxX=std::max(maxX,(double)v1.spos.x); minY=std::min(minY,(double)v1.spos.y); maxY=std::max(maxY,(double)v1.spos.y); minX=std::min(minX,(double)v2.spos.x); maxX=std::max(maxX,(double)v2.spos.x); minY=std::min(minY,(double)v2.spos.y); maxY=std::max(maxY,(double)v2.spos.y); float area=edgeFunction(glm::vec2(v0.spos.x,v0.spos.y),glm::vec2(v1.spos.x,v1.spos.y),glm::vec2(v2.spos.x,v2.spos.y)); for(double ix=minX;ix&lt;=maxX;ix++)&#123; for(double iy=minY;iy&lt;=maxY;iy++)&#123; float d=0.5f; float x=ix+d; float y=iy+d; glm::vec2 p=glm::vec2(x,y); float w0=edgeFunction(glm::vec2(v1.spos.x,v1.spos.y),glm::vec2(v2.spos.x,v2.spos.y),p); float w1=edgeFunction(glm::vec2(v2.spos.x,v2.spos.y),glm::vec2(v0.spos.x,v0.spos.y),p); float w2=edgeFunction(glm::vec2(v0.spos.x,v0.spos.y),glm::vec2(v1.spos.x,v1.spos.y),p); glm::vec3 w=glm::vec3(w0,w1,w2); if(w.x&gt;=0 &amp;&amp; w.y&gt;=0 &amp;&amp; w.z&gt;=0)&#123; w.x=w.x/area; w.y=w.y/area; w.z=w.z/area; if(temp.spos.x&lt;screen_width&amp;&amp;temp.spos.x&gt;0&amp;&amp;temp.spos.y&lt;screen_width&amp;&amp;temp.spos.y&gt;0) temp=VertexData::barycentricLerp(v0,v1,v2,w); rasterized_points.push_back(temp); &#125; &#125; &#125;&#125;; 实验效果 image-20221026202333319 Task5 Task5、实现深度测试，这里只需编写一行代码即可。 为了体现正确的三维前后遮挡关系，我们实现的帧缓冲包含了一个深度缓冲，用于存储当前场景中最近物体的深度值，前后的。三角形的三个顶点经过一系列变换之后，其z 存储了深度信息，取值为[-1,1] ，越大则越远。经过光栅化的线性插值，每个片元都有一个深度值，存储在cpos.z 中。在着色阶段，我们可以用当前片元的cpos.z 与当前深度缓冲的深度值进行比较，如果发现深度缓冲的取值更小（即更近），则应该直接不进行着色器并写入到帧缓冲。 根据以上算法描述，完善代码（实际上只要添加一个if语句即可） 1234567891011121314151617181920//Fragment shader &amp; Depth testing&#123; for (auto &amp;points : rasterized_points) &#123; //Task5: Implement depth testing here // Note: You should use m_backBuffer-&gt;readDepth() and points.spos to read the depth in buffer // points.cpos.z is the depth of curr fragment &#123; //Perspective correction after rasterization TRShaderPipeline::VertexData::aftPrespCorrection(points); glm::vec4 fragColor; if(m_backBuffer-&gt;readDepth(points.spos.x,points.spos.y) &gt;= points.cpos.z)&#123; m_shader_handler-&gt;fragmentShader(points, fragColor); m_backBuffer-&gt;writeColor(points.spos.x, points.spos.y, fragColor); m_backBuffer-&gt;writeDepth(points.spos.x, points.spos.y, points.cpos.z); &#125; &#125; &#125;&#125; 实验效果 image-20221026202422456 Task6 实现了直线光栅化、三角形填充光栅化、齐次空间简单裁剪、背面剔除之后，谈谈你遇到的问题、困难和体会。 本次实验中，比较简单的的两个实验应该是齐次空间简单裁剪、背面剔除这两个实验都是按部就班地实现算法即可，基本没有难度。 本实验中比较难的是直线光栅化、三角形填充光栅化，最难的应该是三角形光栅化。 直线光栅化遇到的困难主要是如何选取像素位置，通过阅读理论材料，按照最近原则，我们选取的应该是更贴近y坐标一侧的像素，从而得到frac，利用线性插值的到选取像素点的具体位置 最难的应该就是三角形光栅化，首先我们要理解好边缘函数，通过边缘函数edgeFunction，我们不仅可以确定包围盒中的点是否在三角形内，还可以面积公式（edgeFunction相当于求出同等比例面积（平行四边面积）），进而可以确定w向量，在利用该w向量，对颜色按照一定的比重进行渲染。 Task7 Task7、实现更为精细的齐次空间三角形裁剪（提高题，选做）。参考链接 在Task2中，只要有一个三角形在可见的范围内，我们就直接返回全部顶点。但实际上我们应该做更加精细的裁剪，把超出范围的给裁剪掉。这里涉及到稍微复杂一点的裁剪算法，如果你有兴趣、有能力，我们鼓励你尝试实现更精细的裁剪算法。 点与面的关系判断 image-20221026132508869 由图我们可以做一个总结 \\[ 如果（Q-P）·\\vec{n}&gt;0,则点Q在裁剪平面外侧\\\\ 如果（Q-P）·\\vec{n}=0,则点Q在裁剪平面上\\\\ 如果（Q-P）·\\vec{n}&lt;0,则点Q在裁剪平内侧 \\] 线与面的关系判断和求交点 如上图，任取一条线段有两个顶点Q1和Q2,设 \\[ d_1=(Q_1-P)·\\vec{n},d_2=(Q_2-P)·\\vec{n}, \\] 不难得到： 1 如果d1&gt;0,d2&gt;0，则边Q1Q2完全处于裁剪平面外侧 2 如果d1&lt;0,d2&lt;0，则边Q1Q2完全处于裁剪平面内侧 3 如果d1∗d2&lt;0，则边Q1Q2与裁剪平面相交与点I 求交点 交点坐标 \\[ I=Q_1+t(Q_2-Q_1) \\] 我们使用task1提到的的插值函数VertexData::lerp（ ）即可 以w=x平面为例，计算t \\[ w_1+t(w_2-w_1)=x_1+t(x_2-x_1)\\\\ t=\\frac{w_1-x_1}{(w_1-x_1)-(w_2-x_2)} \\] 以w=-x平面为例，计算t \\[ w_1+t(w_2-w_1)=-x_1-t(x_2-x_1)\\\\ t=\\frac{w_1+x_1}{(w_1+x_1)-(w_2+x_2)} \\] 除了对w=y,w=−y,w=x,w=−x,w=z,w=−z裁剪之外，一般还会在之前再增加一个w=1e−5平面的裁剪(只要是一个极小数即可，并不一定要是1e-5)，该举措的目的是只保留下w&gt;1e−5的点，防止裁剪之后的透视除法阶段出现除0错误 最重要的其实就是std::vector&lt;TRShaderPipeline::VertexData返回平面交点坐标和在空间范围内的顶点 代码完善 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125//对w进行裁剪，将拥有较小的w的顶点线性插值到w = 1e-5平面上std::vector&lt;TRShaderPipeline::VertexData&gt; clip_with_plane_w( std::vector&lt;TRShaderPipeline::VertexData&gt;&amp; input)&#123; std::vector&lt;TRShaderPipeline::VertexData&gt; output; int vertex_num = input.size(); int prev_index; int curr_index; //遍历所有顶点 for (int i=0; i&lt;vertex_num; ++i) &#123; curr_index=i; //这里只对input集合内部做循环裁剪 prev_index=(i-1+vertex_num)%vertex_num; //每次考察pre_vertex和curr_vertex两个顶点组成的边 TRShaderPipeline::VertexData pre_vertex = input[prev_index]; TRShaderPipeline::VertexData curr_vertex = input[curr_index]; //若顶点的w小于1e-5则d = -1 int d1 = (pre_vertex.cpos.w &lt; 1e-5) ? -1 : 1; int d2 = (curr_vertex.cpos.w &lt; 1e-5) ? -1 : 1; //若一个顶点在平面内，一个在平面外，则需要进行线性插值 if (d1 * d2 &lt; 0) &#123; //m1表示该对应平面的轴坐标，原坐标点乘转换向量即可把对应轴的坐标取出来 float t = (1e-5f - pre_vertex.cpos.w) / (pre_vertex.cpos.w - curr_vertex.cpos.w); TRShaderPipeline::VertexData new_vertex = TRShaderPipeline::VertexData::lerp(pre_vertex, curr_vertex, t); output.push_back(new_vertex); &#125; //若curr_vertex在平面内，则添加到顶点集 if (d2 &lt; 0) &#123; output.push_back(curr_vertex); &#125; &#125; return output;&#125;//对轴进行裁剪，axis为指定的轴：//0 - x轴；1 - y轴；2 - z轴std::vector&lt;TRShaderPipeline::VertexData&gt; clip_with_plane_axis( const int axis, std::vector&lt;TRShaderPipeline::VertexData&gt;&amp; input )&#123; std::vector&lt;TRShaderPipeline::VertexData&gt; output; int vertex_num = input.size(); int prev_index, curr_index; for (int i = 0; i &lt; vertex_num; ++i) &#123; curr_index = i; //这里只对input集合内部做循环裁剪 prev_index = (i - 1 + vertex_num) % vertex_num; //取出的两个点,尝试判断是否需要裁剪 TRShaderPipeline::VertexData pre_vertex = input[prev_index]; TRShaderPipeline::VertexData curr_vertex = input[curr_index]; int d1, d2; //简化d的正负判断,不适用法向量点乘,直接判断坐标关系 d1 = (pre_vertex.cpos[axis] &lt;= pre_vertex.cpos.w) ? -1 : 1; d2 = (curr_vertex.cpos[axis] &lt;= curr_vertex.cpos.w) ? -1 : 1; //若一个顶点在视椎体内，一个在视椎体外，则需要进行线性插值 if (d1 * d2 &lt; 0) &#123; float w1_minus_axis1 = pre_vertex.cpos.w - pre_vertex.cpos[axis]; float w2_minus_axis2 = curr_vertex.cpos.w - curr_vertex.cpos[axis]; float t = w1_minus_axis1 / (w1_minus_axis1 - w2_minus_axis2); TRShaderPipeline::VertexData new_vertex = TRShaderPipeline::VertexData::lerp(pre_vertex, curr_vertex, t); output.push_back(new_vertex); &#125; //顶点在视椎体内，加入顶点集 if (d2 &lt; 0) &#123; output.push_back(curr_vertex); &#125; &#125; vertex_num = output.size(); std::vector&lt;TRShaderPipeline::VertexData&gt; output2; //对w = -axis平面进行裁剪 for (int i = 0; i &lt; vertex_num; ++i) &#123; curr_index = i; prev_index = (i - 1 + vertex_num) % vertex_num; TRShaderPipeline::VertexData pre_vertex = output[prev_index]; TRShaderPipeline::VertexData curr_vertex = output[curr_index]; int d1, d2; d1 = (pre_vertex.cpos[axis] &gt;= -pre_vertex.cpos.w) ? -1 : 1; d2 = (curr_vertex.cpos[axis] &gt;= -curr_vertex.cpos.w) ? -1 : 1; if (d1 * d2 &lt; 0) &#123; //由于负平面计算公式不同,这里需要做一些变化 float w1_plus_m1 = pre_vertex.cpos.w + pre_vertex.cpos[axis]; float w2_plus_m2 = curr_vertex.cpos.w + curr_vertex.cpos[axis]; float t = w1_plus_m1 / (w1_plus_m1 - w2_plus_m2); TRShaderPipeline::VertexData new_vertex = TRShaderPipeline::VertexData::lerp(pre_vertex, curr_vertex, t); output2.push_back(new_vertex); &#125; if (d2 &lt; 0) &#123; output2.push_back(curr_vertex); &#125; &#125; return output2;&#125;std::vector&lt;TRShaderPipeline::VertexData&gt; TRRenderer::cliping( const TRShaderPipeline::VertexData&amp; v0, const TRShaderPipeline::VertexData&amp; v1, const TRShaderPipeline::VertexData&amp; v2) const&#123; std::vector&lt;TRShaderPipeline::VertexData&gt; list1&#123; v0, v1, v2 &#125;; std::vector&lt;TRShaderPipeline::VertexData&gt; outlist1 = clip_with_plane_w(list1); std::vector&lt;TRShaderPipeline::VertexData&gt; list2 = clip_with_plane_axis(0, list1); std::vector&lt;TRShaderPipeline::VertexData&gt; list3 = clip_with_plane_axis(1, list2); std::vector&lt;TRShaderPipeline::VertexData&gt; list4 = clip_with_plane_axis(2, list3); return list4;&#125; 实验效果 image-20221026202801309 如图，有明显的边缘裁剪痕迹 附录： 一些失败的代码（可以不用看了） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168bool VertexsInside(const TRShaderPipeline::VertexData &amp;v0,int near,int far) &#123; return v0.cpos.x/v0.cpos.w&lt;=1&amp;&amp;v0.cpos.x/v0.cpos.w&gt;=-1 &amp;&amp; v0.cpos.y/v0.cpos.w&lt;=1&amp;&amp;v0.cpos.y/v0.cpos.w&gt;=-1 &amp;&amp; v0.cpos.z/v0.cpos.w&lt;=1&amp;&amp;v0.cpos.z/v0.cpos.z&gt;=-1 ;&#125;//针对一个面float d_x_p(const TRShaderPipeline::VertexData &amp;Q)&#123; if(Q.cpos.x/Q.cpos.w&lt;=1)&#123; return -1; &#125;else&#123; return 1; &#125;&#125;float d_x_n(const TRShaderPipeline::VertexData &amp;Q)&#123; if(Q.cpos.x/Q.cpos.w&gt;=-1)&#123; return -1; &#125;else&#123; return 1; &#125;&#125;float d_y_p(const TRShaderPipeline::VertexData &amp;Q)&#123; if(Q.cpos.y/Q.cpos.w&lt;=1)&#123; return -1; &#125;else&#123; return 1; &#125;&#125;float d_y_n(const TRShaderPipeline::VertexData &amp;Q)&#123; if(Q.cpos.y/Q.cpos.w&gt;=-1)&#123; return -1; &#125;else&#123; return 1; &#125;&#125;float d_z_p(const TRShaderPipeline::VertexData &amp;Q)&#123; if(Q.cpos.z/Q.cpos.w&lt;=1)&#123; return -1; &#125;else&#123; return 1; &#125;&#125;float d_z_n(const TRShaderPipeline::VertexData &amp;Q)&#123; if(Q.cpos.y/Q.cpos.w&gt;=-1)&#123; return -1; &#125;else&#123; return 1; &#125;&#125;float d(const TRShaderPipeline::VertexData &amp;Q,glm::vec4 &amp;P,glm::vec4 &amp;n,int flag)&#123; if(flag==1)&#123; return d_x_p(Q); &#125; if(flag==2)&#123; return d_x_n(Q); &#125; if(flag==3)&#123; return d_y_p(Q); &#125; if(flag==4)&#123; return d_y_n(Q); &#125; if(flag==5)&#123; return d_z_p(Q); &#125; if(flag==6)&#123; return d_z_n(Q); &#125;&#125;void insert( const TRShaderPipeline::VertexData &amp;v0, std::vector&lt;TRShaderPipeline::VertexData&gt; &amp;result)&#123; // std::vector&lt;TRShaderPipeline::VertexData&gt;::iterator t; // t=find(result.begin(),result.end(),v0); // if(t==result.end())&#123; result.push_back(v0); // &#125;&#125;void clipping( glm::vec4 &amp;v_0, glm::vec4 &amp;v_1, const TRShaderPipeline::VertexData &amp;v0, const TRShaderPipeline::VertexData &amp;v1, glm::vec4 &amp;point1, glm::vec4 &amp;x_p, std::vector&lt;TRShaderPipeline::VertexData&gt; &amp;result, int flag, int near, int far)&#123; float d1=0; float d2=0; float t=0; d1=-d(v0,point1,x_p,flag); d2=-d(v1,point1,x_p,flag); // if(d1&lt;0&amp;&amp;d2&lt;0)&#123; // insert(v0,result); // insert(v1,result); // &#125; if(d1*d2&lt;0)&#123; if(flag==1) t=(v0.cpos.w-v0.cpos.x)/((v0.cpos.w-v0.cpos.x)-(v1.cpos.w-v1.cpos.x)); if(flag==2) t=(-v0.cpos.w-v0.cpos.x)/(-(v0.cpos.w+v0.cpos.x)+(v1.cpos.w+v1.cpos.x)); if(flag==3) t=(v0.cpos.w-v0.cpos.y)/((v0.cpos.w-v0.cpos.y)-(v1.cpos.w-v1.cpos.y)); if(flag==4) t=(-v0.cpos.w-v0.cpos.y)/(-(v0.cpos.w+v0.cpos.y)+(v1.cpos.w+v1.cpos.y)); if(flag==5) t=(v0.cpos.w-v0.cpos.z)/((v0.cpos.w-v0.cpos.z)-(v1.cpos.w-v1.cpos.z)); if(flag==6) t=(-v0.cpos.w-v0.cpos.z)/(-(v0.cpos.w+v0.cpos.z)+(v1.cpos.w+v1.cpos.z)); TRShaderPipeline::VertexData I; // I=plus(v0,product(t,minus(v1,v0))); I=TRShaderPipeline::VertexData::lerp(v0,v1,t); //判断在正方体内部 if(VertexsInside(I,near,far))&#123; insert(I,result); &#125; // if(d1&lt;0)&#123; // insert(v0,result); // &#125; // if(d2&lt;0)&#123; // insert(v1,result); // &#125; &#125;&#125;void clip_with_plane( const TRShaderPipeline::VertexData &amp;v0, const TRShaderPipeline::VertexData &amp;v1, std::vector&lt;TRShaderPipeline::VertexData&gt; &amp;result, int near, int far )&#123; glm::vec4 v_0 =v0.cpos; glm::vec4 v_1 =v1.cpos; //没用 glm::vec4 point1=glm::vec4(1,1,1,1);//x=w,y=w,z=w glm::vec4 point2=glm::vec4(-1,-1,-1,1);//x=-w,y=-w,z=-w //法向量有问题 //Xaxis glm::vec4 x_p=glm::vec4(1,0,0,-1); clipping(v_0,v_1,v0,v1,point1,x_p,result,1,near,far); glm::vec4 x_n=glm::vec4(-1,0,0,-1); clipping(v_0,v_1,v0,v1,point2,x_n,result,2,near,far); //Yaxis glm::vec4 y_p=glm::vec4(0,1,0,-1); clipping(v_0,v_1,v0,v1,point1,y_p,result,3,near,far);cpp glm::vec4 y_n=glm::vec4(0,-1,0,-1); clipping(v_0,v_1,v0,v1,point2,y_n,result,4,near,far); //Zaxis glm::vec4 z_p=glm::vec4(0,0,1,-1); clipping(v_0,v_1,v0,v1,point1,z_p,result,5,near,far); glm::vec4 z_n=glm::vec4(0,0,-1,-1); clipping(v_0,v_1,v0,v1,point2,z_n,result,6,near,far);&#125;","categories":[],"tags":[]},{"title":"【计算机图形学】Assignment1 3D Transformation","slug":"【计图】hw1","date":"2022-10-08T16:00:00.000Z","updated":"2023-03-15T08:50:54.969Z","comments":true,"path":"2022/10/09/【计图】hw1/","link":"","permalink":"https://klc1006.github.io/2022/10/09/%E3%80%90%E8%AE%A1%E5%9B%BE%E3%80%91hw1/","excerpt":"","text":"Task 1 实现观察矩阵（View Matrix）的计算，如下所示，该函数在TRRenderer.cpp 文件中。 实验原理 该实验实际上是需要我们实现glm::lookAt函数 ①整体平移，将摄像机平移至世界坐标系原点， ②将顶点从世界坐标系变换至摄像机坐标系。 参数解释：camera摄像机的位置，target摄像机目标点，worldup世界空间的上向量 具体步骤： 根据这些参数确定摄像机坐标系的三个轴向量 注意：变换到视图空间中时摄像机是朝向视图空间的−Z方向的，所以求视图空间中的Z轴时是摄像机的位置减去目标点的位置 \\[ Z=normalize(camera-target) \\] \\[ X=normalize(cross(up,Z)) \\] \\[ Y=normalize(cross(Z,X)) \\] 至此，我们求出了视图空间的三条轴向量，再加上摄像机的位置我们就可以求出将世界坐标变换到与视图坐标重合的矩阵 计算变换矩阵M=T⋅R，其中T是平移到摄像机位置camera的变换矩阵，R是旋转到摄像机坐标轴方向的旋转矩阵 \\[ M=T\\cdot R= \\left[\\begin{matrix} 1 &amp; 0 &amp; 0&amp;camera_x\\\\ 0&amp; 1 &amp; 0&amp;camera_y\\\\ 0 &amp; 0 &amp; 1&amp;camera_z\\\\ 0&amp;0&amp;0&amp;1 \\end{matrix}\\right] \\cdot \\left[\\begin{matrix} X_x&amp;Y_x&amp; Z_x&amp;0\\\\ X_y&amp;Y_y&amp;Z_y&amp;0\\\\ X_z&amp;Y_z&amp;Z_z&amp;0\\\\ 0&amp;0&amp;0&amp;1 \\end{matrix}\\right] \\] 矩阵M仅仅是将世界坐标轴变换到摄像机坐标轴 当我们向前移动摄像机的时候，可以看成是摄像机不动，而物体朝着与摄像机朝向相反的方向移动。当我们向右旋转摄像机时，相当于摄像机不动而物体朝着摄像机的左边移动 计算机图形学中的虚拟3D摄像机实际上是通过物体的移动来实现的，所以我们要构造的视图矩阵是公式中的逆矩阵。 \\[ viewMatrix=M^\\mathrm{-1}=(T\\cdot R)^\\mathrm{-1}=R^\\mathrm{-1} \\cdot T^\\mathrm{-1}=\\left[\\begin{matrix} 1 &amp; 0 &amp; 0&amp;camera_x\\\\ 0&amp; 1 &amp; 0&amp;camera_y\\\\ 0 &amp; 0 &amp; 1&amp;camera_z\\\\ 0&amp;0&amp;0&amp;1 \\end{matrix}\\right]^\\mathrm{-1} \\cdot \\left[\\begin{matrix} X_x&amp;Y_x&amp; Z_x&amp;0\\\\ X_y&amp;Y_y&amp;Z_y&amp;0\\\\ X_z&amp;Y_z&amp;Z_z&amp;0\\\\ 0&amp;0&amp;0&amp;1 \\end{matrix}\\right]^\\mathrm{-1} \\] 其中 \\[ T^\\mathrm{-1}= \\left[\\begin{matrix} 1 &amp; 0 &amp; 0&amp;camera_x\\\\ 0&amp; 1 &amp; 0&amp;camera_y\\\\ 0 &amp; 0 &amp; 1&amp;camera_z\\\\ 0&amp;0&amp;0&amp;1 \\end{matrix}\\right]^\\mathrm{-1} =\\left[\\begin{matrix} 1 &amp; 0 &amp; 0&amp;-camera_x\\\\ 0&amp; 1 &amp; 0&amp;-camera_y\\\\ 0 &amp; 0 &amp; 1&amp;-camera_z\\\\ 0&amp;0&amp;0&amp;1 \\end{matrix}\\right] \\] \\[ R^\\mathrm{-1}=\\left[\\begin{matrix} X_x&amp;Y_x&amp; Z_x&amp;0\\\\ X_y&amp;Y_y&amp;Z_y&amp;0\\\\ X_z&amp;Y_z&amp;Z_z&amp;0\\\\ 0&amp;0&amp;0&amp;1 \\end{matrix}\\right]^\\mathrm{-1}= \\left[\\begin{matrix} X_x&amp;X_y&amp; X_z&amp;0\\\\ Y_x&amp;Y_y&amp;Y_z&amp;0\\\\ Z_x&amp;Z_y&amp;Z_z&amp;0\\\\ 0&amp;0&amp;0&amp;1 \\end{matrix}\\right] \\] 最后我们得到的视图矩阵为 \\[ viewMatrix=\\left[\\begin{matrix} X_x&amp;X_y&amp; X_z&amp;0\\\\ Y_x&amp;Y_y&amp;Y_z&amp;0\\\\ Z_x&amp;Z_y&amp;Z_z&amp;0\\\\ 0&amp;0&amp;0&amp;1 \\end{matrix}\\right] \\cdot \\left[\\begin{matrix} 1 &amp; 0 &amp; 0&amp;-camera_x\\\\ 0&amp; 1 &amp; 0&amp;-camera_y\\\\ 0 &amp; 0 &amp; 1&amp;-camera_z\\\\ 0&amp;0&amp;0&amp;1 \\end{matrix}\\right]= \\left[\\begin{matrix} X_x&amp;X_y&amp; X_z&amp;-X\\cdot camera\\\\ Y_x&amp;Y_y&amp;Y_z&amp;-Y\\cdot camera\\\\ Z_x&amp;Z_y&amp;Z_z&amp;-Z\\cdot camera\\\\ 0&amp;0&amp;0&amp;1 \\end{matrix}\\right] \\] 代码实现 1234567891011121314151617181920212223242526272829303132glm::mat4 TRRenderer::calcViewMatrix(glm::vec3 camera, glm::vec3 target, glm::vec3 worldUp)&#123; //Setup view matrix (world space -&gt; camera space) glm::mat4 vMat = glm::mat4(1.0f); //计算出摄像机坐标轴方向 //经过叉乘方向认证，对应方向均正确 glm::vec3 cameraDirection = glm::normalize(camera - target); //此处与上述原理略有不同，规定摄像机向右方向为X轴正方向 glm::vec3 cameraRight = glm::normalize(glm::cross(cameraDirection, worldUp)); glm::vec3 cameraUp = glm::normalize(glm::cross(cameraDirection, cameraRight)); //填写视图矩阵对应元素 vMat[0][0] = cameraRight.x; vMat[1][0] = cameraRight.y; vMat[2][0] = cameraRight.z; vMat[3][0] = -glm::dot(camera, cameraRight); vMat[0][1] = cameraUp.x; vMat[1][1] = cameraUp.y; vMat[2][1] = cameraUp.z; vMat[3][1] = -glm::dot(camera, cameraUp); vMat[0][2] = cameraDirection.x; vMat[1][2] = cameraDirection.y; vMat[2][2] = cameraDirection.z; vMat[3][2] = -glm::dot(camera, cameraDirection); //Task 1: Implement the calculation of view matrix, and then set it to vMat // Note: You can use any glm function (such as glm::normalize, glm::cross, glm::dot) except glm::lookAt //glm::transpose(vMat); return vMat;&#125; Task 2 实现透视投影矩阵（Project Matrix）的计算，如下所示，该函数在TRRenderer.cpp 文件中。 实验原理 一个视锥体我们目前用六个参数表示：left,right，bottom，top，near，far，简写为l、r、b、t、n和f，即视锥体的六个面。我们的目标就是将视图空间中在视锥体内的点变换到标准化设备坐标中的立方体内。即x轴方向从[l,r]映射到[−1,1]，y轴方向从[b,t]映射到[−1,1]，z轴方向从[−n,−f]映射到[−1,1]. img 透视投影视锥和标准化设备坐标 img 从-Y方向看去的视锥横截面 img 从-X方向看去的视锥横截面 根据相似性原理，有 \\[ \\frac{x_p}{x_e}=\\frac{-n}{z_e} \\Rightarrow x_p=\\frac{-n \\cdot x_e}{z_e}=\\frac{n \\cdot x_e}{-z_e} \\] \\[ \\frac{y_p}{y_e}=\\frac{-n}{z_e} \\Rightarrow y_p=\\frac{-n \\cdot y_e}{z_e}=\\frac{n \\cdot y_e}{-z_e} \\] 分母都是一个−ze，这与我们将裁剪空间中的顶点做透视除法相对应，透视投影然后做透视除法如下公式 \\[ \\left(\\begin{matrix} x_{clip}\\\\ y_{clip}\\\\ z_{clip}\\\\ w_{clip} \\end{matrix}\\right) =M_{projection} \\cdot \\left(\\begin{matrix} x_{eye}\\\\ y_{eye}\\\\ z_{eye}\\\\ w_{eye} \\end{matrix}\\right) \\] $$ ( \\[\\begin{matrix} x_{ndc}\\\\ y_{ndc}\\\\ z_{ndc}\\\\ \\end{matrix}\\] ) ( \\[\\begin{matrix} x_{eye}/w_{clip}\\\\ y_{eye}/w_{clip}\\\\ z_{eye}/w_{clip}\\\\ \\end{matrix}\\] ) $$ 为了便于构建矩阵（xe和ye均与−ze相除，不好构建矩阵），我们令裁剪空间中的wclip为-ze，将除以−ze的这一步挪到了透视除法去做。故目前的透视矩阵就变为： \\[ \\left(\\begin{matrix} x_{clip}\\\\ y_{clip}\\\\ z_{clip}\\\\ w_{clip} \\end{matrix}\\right) = \\left(\\begin{matrix} ·&amp;·&amp;·&amp;·\\\\ ·&amp;·&amp;·&amp;·\\\\ ·&amp;·&amp;·&amp;·\\\\ 0&amp;0&amp;-1&amp;0 \\end{matrix}\\right) \\cdot \\left(\\begin{matrix} x_{eye}\\\\ y_{eye}\\\\ z_{eye}\\\\ w_{eye} \\end{matrix}\\right) \\] 其中”..”均表示未知。得到在近平面的xp和yp之后，我们还要将xp映射到[−1,1]范围，同理yp也是。以xp为例，我们知道其值域为[l,r]。为了将xp其映射到[−1,1]，我们首先将其映射到[0,1]，不难得到如下式子： \\[ \\frac{x_p-l}{r-l}\\in[0,1] \\] 对上式乘2减1有 \\[ x_n=2\\frac{x_p-l}{r-l}-1=\\frac{2x_p}{r-l}-\\frac{r+l}{r-l} \\in[-1,1] \\] 同理yp到yn的映射 \\[ y_n=2\\frac{y_p-b}{t-b}-1=\\frac{2x_p}{t-b}-\\frac{t+b}{t-b} \\in[-1,1] \\] 将xp和yp带入以上公式 \\[ x_n=\\underbrace{(\\frac{2n}{r-l} \\cdot x_e+\\frac{r+l}{r-l} \\cdot z_e)}_{x_c}/-z_e \\] \\[ y_n=\\underbrace{(\\frac{2n}{t-b} \\cdot y_e+\\frac{t+b}{t-b} \\cdot z_e)}_{y_c}/-z_e \\] 初步填充投影矩阵 \\[ \\left(\\begin{matrix} x_{clip}\\\\ y_{clip}\\\\ z_{clip}\\\\ w_{clip} \\end{matrix}\\right) = \\left(\\begin{matrix} \\frac{2n}{r-l} &amp;0&amp;\\frac{r+l}{r-l}&amp;0\\\\ 0&amp;\\frac{2n}{t-b} &amp;\\frac{t+b}{t-b}&amp;0\\\\ 0&amp;0&amp;A&amp;B\\\\ 0&amp;0&amp;-1&amp;0 \\end{matrix}\\right) \\cdot \\left(\\begin{matrix} x_{eye}\\\\ y_{eye}\\\\ z_{eye}\\\\ w_{eye} \\end{matrix}\\right) \\] 因为我们知道z的投影与xe和ye无关，只与ze、we有关，故可以假设投影矩阵的第三行如上式所示，A和B就是我们假设的要求解的未知表达式 在视图空间中的we是等于11的，wc即前面提到的−ze，从而有： \\[ z_n=z_c/w_c=\\frac{Az_e+Bw_e}{-z_e}=\\frac{Az_e+B}{-z_e} \\] 考虑：在−n处的z值被映射到−1，在−f处的z值被映射到1，将(zn,ze)=(−1,−n)和((zn,ze)=(1,−f)带入式子 \\[ \\left\\{ \\begin{array}{c} \\frac{-An+B}{n}=-1\\\\ \\frac{-Af+B}{n}=1 \\end{array} \\right. \\Rightarrow \\left\\{ \\begin{array}{c} A=-\\frac{f+n}{f-n}\\\\ B=-\\frac{2fn}{f-n} \\end{array} \\right. \\] 所以有 \\[ z_n=\\underbrace{(-\\frac{f+n}{f-n} \\cdot z_e+-\\frac{2fn}{f-n} \\cdot z_e)}_{z_c}/-z_e \\] 最终我们得到得透视投影矩阵为 \\[ M_{projection}= \\left(\\begin{matrix} \\frac{2n}{r-l} &amp;0&amp;\\frac{r+l}{r-l}&amp;0\\\\ 0&amp;\\frac{2n}{t-b} &amp;\\frac{t+b}{t-b}&amp;0\\\\ 0&amp;0&amp;-\\frac{f+n}{f-n}&amp;-\\frac{2fn}{f-n}\\\\ 0&amp;0&amp;-1&amp;0 \\end{matrix}\\right) \\] 在视图空间中的视锥体通常都是关于x轴和y轴对称的，从而有r=−l、t=−b，将其简化成如下形式： \\[ M_{projection}= \\left(\\begin{matrix} \\frac{2n}{r-l} &amp;0&amp;0&amp;0\\\\ 0&amp;\\frac{2n}{t-b} &amp;0&amp;0\\\\ 0&amp;0&amp;-\\frac{f+n}{f-n}&amp;-\\frac{2fn}{f-n}\\\\ 0&amp;0&amp;-1&amp;0 \\end{matrix}\\right) \\] 注意到r−l=width即近平面宽度，t−b=height即近平面的高度，可以根据fovy和aspect得出width和height \\[ r-l=width=2*near*aspect*tan(fovy/2) \\] \\[ t-b=height=2*near*tan(fovy/2) \\] 在视锥体中的顶点(xe,ye,ze),(xe,ye,ze)被投影到锥体的近平面，近平面上的点我们记为(xp,yp,−n),(xp,yp,−n),由相似性，有 \\[ M_{projection}=\\left(\\begin{matrix} {1}\\over {aspect*tan(fovy/2)}&amp;0&amp; 0&amp;0\\\\ 0&amp;{1}\\over {tan(fovy/2)}&amp;0&amp;0\\\\ 0&amp;0&amp;-\\frac{(f+n)}{f-n}&amp;-\\frac{2fn} {f-n}\\\\ 0&amp;0&amp;-1&amp;0 \\end{matrix}\\right) \\] 代码实现 1234567891011121314151617glm::mat4 TRRenderer::calcPerspProjectMatrix(float fovy, float aspect, float near, float far)&#123; //Setup perspective matrix (camera space -&gt; clip space) glm::mat4 pMat = glm::mat4(1.0f); //Task 2: Implement the calculation of perspective matrix, and then set it to pMat // Note: You can use any math function (such as std::tan) except glm::perspective //根据上述原理，填入矩阵元素 pMat[0][0] = 1.0f / (std::tan(fovy / 2.0f) * aspect); pMat[1][1] = 1.0f / std::tan(fovy / 2.0f); pMat[2][2] = -(near + far) / (far - near); pMat[2][3] = 1.0f; pMat[3][2] = -(2.0f * far * near) / (far - near); pMat[3][3] = 0.0f; return pMat;&#125; 实验结果及分析 Task3 实现视口变换矩阵（Viewport Matrix）的计算，如下所示，该函数在TRRenderer.cpp 文件 中。 实验原理 视口变换 首先，我们定义窗口的左下角（sx，sy）为（0，0），ns和 fs指定远近剪裁平面到屏幕坐标的映射关系。ns=-1，fs=1，使用的线性映射关系如下 \\[ (-1,s_x),(1,s_x+w_s) \\] \\[ (-1,s_y),(1,s_y+h_s) \\] \\[ (-1,n_s),(1,f_s) \\] 可以求出线性映射函数如下 \\[ x_s = \\frac{w_s}{2} x_n +s_x+\\frac{w_s}{2} \\] \\[ y_s = \\frac{h_s}{2} y_n +s_y+\\frac{h_s}{2} \\] \\[ z_s = \\frac{f_s-n_s}{2} z_n +s_y+\\frac{n_s+f_s}{2} \\] 由上述式子得到视口变换矩阵 \\[ viewPort=\\left(\\begin{matrix} {w}\\over {2}&amp;0&amp; 0&amp;{w}\\over {2}\\\\ 0&amp;{-h}\\over {2}&amp;0&amp;{h}\\over {2}\\\\ 0&amp;0&amp;{(f-n)}\\over {2}&amp;{(f+n)}\\over {2}\\\\ 0&amp;0&amp;0&amp;1 \\end{matrix}\\right) \\] 在这里，我们把窗口变换看作，把世界坐标空间变换到窗口坐标空间，其中包括对空间，在x，y，z轴方向上作scaler 和 平移变换 代码实现 1234567891011121314151617181920glm::mat4 TRRenderer::calcViewPortMatrix(int width, int height)&#123; //Setup viewport matrix (ndc space -&gt; screen space) glm::mat4 vpMat = glm::mat4(1.0f); //默认规定 float far = 1.0f; float near = -1.0f; //根据上述原理，填入矩阵元素 vpMat[0][0] = width / 2; vpMat[1][1] = -height / 2; vpMat[2][2] = (far-near)/2; vpMat[3][0] = width / 2; vpMat[3][1] = height / 2; vpMat[3][2] = (far+near)/2; vpMat[3][3] = 1.0f; //Task 3: Implement the calculation of viewport matrix, and then set it to vpMat return vpMat;&#125; 实验结果及分析 完成task1，2，3 后，窗口会有动画展示如图 image-20221012203336941 Task4 程序默认物体绕着\\(y\\)轴不停地旋转，请你在main.cpp 文件中稍微修改一下代码，使得物体 分别绕\\(x\\)轴和\\(z\\)轴旋转。贴出你的结果。 实验原理 model_mat = glm::rotate(model_mat, (float)deltaTime * 0.001f, glm::vec3(0, 1, 0));函数是使得图像在y轴方向上作旋转操作。 在x轴上作旋转：设置glm::vec3(1, 0, 0) 在z轴上作旋转：设置glm::vec3(0, 0, 1) 代码实现 12345678//Rotation&#123; //Task 4: Make the model rotate around x axis and z axis, respectively model_mat = glm::rotate(model_mat, (float)deltaTime * 0.001f, glm::vec3(0, 1, 0)); //model_mat = glm::rotate(model_mat, (float)deltaTime * 0.001f, glm::vec3(1, 0, 0)); //model_mat = glm::rotate(model_mat, (float)deltaTime * 0.001f, glm::vec3(0, 0, 1));&#125; 实验结果及分析 在x轴上旋转 image-20221012204231523 在z轴上旋转 Task5 仔细体会使物体随着时间的推进不断绕\\(y\\)轴旋转的代码，现在要你用glm::scale 函数实现物体不停地放大、缩小、放大的循环动画，物体先放大至\\(2.0\\)倍、然后缩小至原来的大小，然后再放大至\\(2.0\\)，依次循环下去，要求缩放速度适中，不要太快也不要太慢。贴出你的效果，说说你是怎么实现的。（请注释掉前面的旋转代码） 实验原理 在这个实验中，需要对物体实现不停地放大、缩小、放大的循环动画，自然可以想到使用glm::scale()函数对物体作周期性的scalar操作，我们可以根据时间设置周期函数1.5+0.5sin(total_time),使得scalar系数在[1,2]之间周期性地变化。 代码实现 12345678910 static float total_time = 0;...//Scale &#123; //Task 5: Implement the scale up and down animation using glm::scale function model_mat = glm::scale(glm::mat4(1.0f), glm::vec3(1.5+0.5*sin(total_time))); total_time += (float)deltaTime * 0.01f; &#125; 实验结果及分析 图像画面会在1倍和2倍之间循环放大缩小 Task6 现在要求你实现正交投影矩阵的计算，如下所示，该函数在TRRenderer.cpp 文件中。 实验原理 正交投影只需做简单的线性映射就行了。只需将x轴方向从[l,r]映射到[−1,1]，y轴方向从[b,t]映射到[−1,1]，z轴方向从[−n,−f]映射到[−1,1]，而这个映射的过程很简单，先映射到[0,1]，再映射到[0,2]，最后映射到[−1,1]. \\[ M_{projection}=\\left(\\begin{matrix} {2}\\over {r-l}&amp;0&amp; 0&amp;{-(r+l)}\\over {r-l}\\\\ 0&amp;{2}\\over {t-b}&amp;0&amp;{-(t+b)}\\over {t-b}\\\\ 0&amp;0&amp;-{2}\\over {f-n}&amp;-{(f+n)}\\over {f-n}\\\\ 0&amp;0&amp;0&amp;1 \\end{matrix}\\right) \\] 代码实现 1234567891011121314glm::mat4 TRRenderer::calcOrthoProjectMatrix(float left, float right, float bottom, float top, float near, float far)&#123; //Setup orthogonal matrix (camera space -&gt; homogeneous space) glm::mat4 pMat = glm::mat4(1.0f); //Task 6: Implement the calculation of orthogonal projection, and then set it to pMat pMat[0][0]=2/(right-left); pMat[1][1]=2/(top-bottom); pMat[2][2]=-2 / (far - near); pMat[3][0]=-(right + left) / (right - left); pMat[3][1]=-(top + bottom) / (top - bottom); pMat[3][2]=-(far + near) / (far - near); return pMat;&#125; 实验结果及分析 image-20221012204631385 正交投影呈现的图像方方正正，缺少立体效果 Task7 实现了正交投影计算后，在main.cpp 的如下代码中，分别尝试调用透视投影和正交投影函数，通过滚动鼠标的滚轮来拉近或拉远摄像机的位置，仔细体会这两种投影的差别。 尝试结果 如视频所示 透视投影 在滚动鼠标滚轮时会有明显的远近缩进放大，有明显的立体感，3D还原效果更好 正交投影 在滚动鼠标滚轮时没有明显的变化，当过度缩进时，物体会逐渐消失在画面之中，可以理解为距离过远，不在窗口范围内 Task8 完成上述的编程实践之后，请你思考并回答以下问题： （1）请简述正交投影和透视投影的区别。 区别在于：透视图有很强的立体空间的表现力而正交视图能准确表达物体在空间中的位置和状态 原因为： 透视图是把立体三维空间的形象按照人眼的视觉习惯表现在二维平面上的构成画面。它具有消失感、距离感、相同大小的形体呈现出有规律的变化等一系列的透视特性，能逼真地反映形体的空间形象。 正交视图则是不考虑物体的透视效果，只是将物体所在三维空间的点一一对应到二维视图平面上的成像。按实际比例显示，没有透视变形。 透视投影 （2）从物体局部空间的顶点的顶点到最终的屏幕空间上的顶点，需要经历哪几个空间的坐标系？ 一个顶点在最终被转化为片段之前需要经历的所有不同状态——五个坐标系统 局部空间/物体空间 世界空间 观察空间/视觉空间 裁剪空间 屏幕空间 流程如下 img 裁剪空间下的顶点的\\(w\\)值是哪个空间坐标下的\\(z\\)值？它有什么空间意义？ 裁剪空间顶点坐标w 分量就是视角空间下的深度值，将其除以远裁面就是0-1 的深度值。 远裁剪面的距离可以通过内置的_ProjectionParams.z 变量来获取。 意义：该顶点的w值可用于获取顶点的深度值，因为离观察者越远的顶点坐标w分量越大。 （3）经过投影变换之后，几何顶点的坐标值是被直接变换到了NDC坐标（即\\(xyz\\)的值全部都在 \\([-1,1]\\)范围内）吗？ 经过“透视除法”之后，坐标x, y, z的取值会归一化到范围在[-1. 1]之间的数，这个坐标也称作标准化设备坐标(NDC, Normalized Device Coordinate)，而“透视除法”后超出NDC坐标范围的点将被裁剪掉，然后再转换到屏幕上窗口中的坐标到屏幕空间(Screen Space)中。 透视除法（Perspective Division）是什么？ 对W ，VP变换后点(x, y, z, w)变为(x/w, y/w, z/w, 1) 为什么要有这么一个过程？ 完成透视除法后才到NDC坐标有[-1, 1]的与参数无关的范围。 使用透视除法，可以理解为将一个三维坐标点(x, y, z)表示成一个等价的四维齐次坐标(x, y, z, w)，其中我们需要保证w=1，以保证后续矩阵运算的正确性。","categories":[],"tags":[]},{"title":"【AI Course】PDDL解决规划问题","slug":"AI Course 12","date":"2022-06-08T16:00:00.000Z","updated":"2023-03-09T03:06:38.556Z","comments":true,"path":"2022/06/09/AI Course 12/","link":"","permalink":"https://klc1006.github.io/2022/06/09/AI%20Course%2012/","excerpt":"中山大学计算机学院 人工智能实验报告（十二） (2022春季实验报告) 课程名称:Artificial Intelligence 教学班级 专业方向 学号 姓名 计科1班 计算机科学与技术 20337013 陈梁坤 一、实验题目 使用pddl补充完整两个问题，分别为blocks问题和puzzle问题","text":"中山大学计算机学院 人工智能实验报告（十二） (2022春季实验报告) 课程名称:Artificial Intelligence 教学班级 专业方向 学号 姓名 计科1班 计算机科学与技术 20337013 陈梁坤 一、实验题目 使用pddl补充完整两个问题，分别为blocks问题和puzzle问题 二、实验内容 算法原理 PDDL：Planning Domain Deﬁnition Language 规划领域定义语言，是一种解决人工智能规划问题的比较前沿的方法。PDDL常用于解决智能规划问题，例如机器人将一个屋子的球搬运到另一间屋子里，通过合理的组织流程建造一间房子等。PDDL的规划任务（planning task）由五部分组成。 Objects（对象） Things in the world that interest us. Predicates（谓词） Properties of objects that we are interested in; can be true or false. Initial state（初始状态） The state of the world that we start in. Goal speciﬁcation（目标规范） Things that we want to be true. Actions/Operators（操作/运算符） Ways of changing the state of the world. PDDL指定的规划任务分为两个文件，domain 文件和 problem 文件。 A domain file（域文件） for predicates and actions. A problem file（问题文件） for objects, initial state and goal specification. Domain Files 域文件定义如下： 123456(define (domain &lt;domain name&gt;) &lt;PDDL code for predicates&gt; &lt;PDDL code for first action&gt; [...] &lt;PDDL code for last action&gt;) Problem Files 问题文件定义如下： 123456(define (problem &lt;problem name&gt;) (:domain &lt;domain name&gt;) &lt;PDDL code for objects&gt; &lt;PDDL code for initial state&gt; &lt;PDDL code for goal specification&gt;) 关键代码展示 blocks问题 123456789(define (problem prob) (:domain blocks) (:objects A B C D E F - physob) (:init (clear A)(on A B)(on B C)(ontable C) (ontable D) (ontable F)(on E D)(clear E)(clear F)) (:goal (and (clear F) (on F A) (on A C) (ontable C)(clear E) (on E B) (on B D) (ontable D)) ) ) 12345678910111213141516171819202122(define (domain blocks) (:requirements :strips :typing:equality :universal-preconditions :conditional-effects) (:types physob) (:predicates (ontable ?x - physob) (clear ?x - physob) (on ?x ?y - physob) ) (:action move :parameters (?x - physob ?y - physob ?z - physob) :precondition(and (clear ?x) (clear ?y) (not(on ?x ?y)) (or (ontable ?x) (on ?x ?z) )) :effect( and (not(clear ?y)) (on ?x ?y) (when(ontable ?x) (not(ontable ?x)) ) (when(on ?x ?z) (and (not(on ?x ?z))(clear ?z))) ) ) (:action moveToTable :parameters (?x - physob ?y - physob) :precondition(and (clear ?x) (not(ontable ?x)) (on ?x ?y)) :effect( and (ontable ?x ) (clear ?y) (not (on ?x ?y))) ) ) 动作move 参数三个积木：x,y,z precondition:积木x顶部为空，积木y顶部为空，积木x不在积木y上，积木x在桌面上或者积木x在积木y上 effect：积木y顶部不为空，积木x在积木y上 如果积木x原来在桌子上，添加积木x不在桌子上 如果积木原来在积木z上，添加积木x不在积木y上 积木z顶部为空 动作moveToTable 参数两个积木x，y precondition：积木x顶部为空，积木x不在桌子上，积木x在积木y上 effect：添加积木x在桌子上，积木y的顶部为空 积木x不在积木上 puzzle问题 初始状态 image-20220613190231563 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859(define (problem prob) (:domain puzzle) (:objects n1 n2 n3 n4 n5 n6 n7 n8 n0 - num l11 l12 l13 l21 l22 l23 l31 l32 l33 - loc) (:init (at n1 l11) (at n2 l12) (at n3 l13) (at n7 l21) (at n8 l22) (at n0 l23) (at n6 l31) (at n4 l32) (at n5 l33) (adjacent l11 l12) (adjacent l11 l21) (adjacent l12 l11) (adjacent l12 l13) (adjacent l12 l22) (adjacent l13 l12) (adjacent l13 l23) (adjacent l21 l11) (adjacent l21 l22) (adjacent l21 l31) (adjacent l22 l12) (adjacent l22 l23) (adjacent l22 l32) (adjacent l22 l21) (adjacent l23 l13) (adjacent l23 l13) (adjacent l23 l13) (adjacent l31 l21) (adjacent l31 l32) (adjacent l32 l31) (adjacent l32 l22) (adjacent l32 l33) (adjacent l33 l23) (adjacent l33 l32) ) (:goal (and(at n1 l11) (at n2 l12) (at n3 l13) (at n4 l21) (at n5 l22) (at n6 l23) (at n7 l31) (at n8 l32) (at n0 l33) ) )) 12345678910111213(define (domain puzzle) (:requirements :strips :equality:typing) (:types num loc) (:predicates (:action slide :parameters (?x - num ?y - loc ?z - loc ) :precondition (and (at n0 ?y) (at ?x ?z) (adjacent ?y ?z)) :effect (and (not(at n0 ?y)) (not(at ?x ?z)) (at n0 ?z) (at ?x ?y)) )) 动作slide 参数x：num，y:loc，z：loc 实现逻辑：将数字x从位置z转移至位置y precondition：位置y为空，数字x在位置z上，位置y和位置z相邻 effect：添加位置y不为空，数字x不在位置z，位置z为空，数字x在位置y 三、实验结果及分析 实验结果展示实例 blocks 实验结果 image-20220613193258535 验证步骤 根据上述步骤做下面积木移动动作 image-20220615154456087 image-20220615154503641 image-20220615154517215 image-20220615154531814 image-20220615154626567 image-20220615154646212 image-20220615154653872 image-20220615154703004 image-20220615154710335 image-20220615154716996 该规划器能够得到正确的步骤，使得积木由初始状态，变为目标状态，但但是规划出来的步骤仍然存在冗余项，该规划步骤不是最小步骤。 puzzle 实验结果 image-20220613193053867 步骤验证 验证程序： 1234567891011121314151617puzzle=[[1,2,3],[7,8,0],[6,4,5]]step=[]with open(&quot;step&quot;,&#x27;r&#x27;) as file: lines=file.readlines()[:] for data in lines: data=data.split() step.append([data[2],data[3]])cnt=0for item in step: cnt+=1 print(&quot;\\nstep&quot;,cnt) puzzle[int(item[0][1])-1][int(item[0][2])-1], puzzle[int(item[1][1])-1][int(item[1][2])-1] = puzzle[int(item[1][1])-1][int(item[1][2])-1] ,puzzle[int(item[0][1])-1][int(item[0][2])-1] for i in range(len(puzzle)): for j in range(len(puzzle[i])): print(puzzle[i][j],end=&quot; &quot;) print() 验证结果： image-20220613192822353 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154step 11 2 07 8 36 4 5step 21 0 27 8 36 4 5step 31 8 27 0 36 4 5step 41 8 27 4 36 0 5step 51 8 27 4 30 6 5step 61 8 20 4 37 6 5step 71 8 24 0 37 6 5 step 81 8 24 3 07 6 5step 91 8 04 3 27 6 5step 101 0 84 3 27 6 5step 111 3 84 0 27 6 5step 121 3 84 2 07 6 5step 131 3 04 2 87 6 5step 141 0 34 2 87 6 5step 151 2 34 0 87 6 5 step 161 2 34 6 87 0 5step 171 2 34 6 87 5 0step 181 2 34 6 07 5 8step 191 2 04 6 37 5 8step 201 0 24 6 37 5 8step 211 6 24 0 37 5 8step 221 6 24 3 07 5 8step 231 6 04 3 27 5 8step 241 0 64 3 27 5 8step 251 3 64 0 2 7 5 8step 261 3 64 2 07 5 8step 271 3 04 2 67 5 8step 281 0 34 2 67 5 8step 291 2 34 0 67 5 8step 301 2 34 5 67 0 8step 311 2 34 5 67 8 0 按照规划器给出的步骤，成功将8-puzzle还原，需要31步，该规划步骤仍然存在许多冗余步骤，不是最小步骤。","categories":[],"tags":[{"name":"PDDL","slug":"PDDL","permalink":"https://klc1006.github.io/tags/PDDL/"},{"name":"规划问题","slug":"规划问题","permalink":"https://klc1006.github.io/tags/%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98/"}]},{"title":"【AI Course】KNN完成情感分类标签","slug":"AI Course 8","date":"2022-05-18T16:00:00.000Z","updated":"2023-03-08T16:59:00.946Z","comments":true,"path":"2022/05/19/AI Course 8/","link":"","permalink":"https://klc1006.github.io/2022/05/19/AI%20Course%208/","excerpt":"中山大学计算机学院 人工智能实验报告（八） (2022春季实验报告) 课程名称:Artificial Intelligence 教学班级 专业方向 学号 姓名 计科1班 计算机科学与技术 20337013 陈梁坤 一、实验题目 在给定文本数据集完成文本情感分类训练，在测试集完成测试，计算准确率。 要求 文本的特征可以使用TF或TF-IDF（也可以使用sklearn库提取特征） 利用k-NN完成对测试集的分类，并计算准确率 需要提交简要报告+代码 加分项： 距离度量 算法效率优化","text":"中山大学计算机学院 人工智能实验报告（八） (2022春季实验报告) 课程名称:Artificial Intelligence 教学班级 专业方向 学号 姓名 计科1班 计算机科学与技术 20337013 陈梁坤 一、实验题目 在给定文本数据集完成文本情感分类训练，在测试集完成测试，计算准确率。 要求 文本的特征可以使用TF或TF-IDF（也可以使用sklearn库提取特征） 利用k-NN完成对测试集的分类，并计算准确率 需要提交简要报告+代码 加分项： 距离度量 算法效率优化 二、实验内容 算法原理 概念：KNN（K Near Neighbor）：k个最近的邻居，即每个样本都可以用它最接近的k个邻居来代表。 image-20220518170654848 最近邻 (k-Nearest Neighbors， KNN) 算法是一种分类算法， 1968年由 Cover和 Hart 提出， 应用场景有字符识别、 文本分类、 图像识别等领域。 该算法的思想是： 一个样本与数据集中的k个样本最相似， 如果这k个样本中的大多数属于某一个类别， 则该样本也属于这个类别。 距离度量 当p=2时，就是欧氏距离（对应L2范数） 最常见的两点之间或多点之间的距离表示法，又称之为欧几里得度量，它定义于欧几里得空间中。n维空间中两个点x1(x11,x12,…,x1n)与 x2(x21,x22,…,x2n)间的欧氏距离 欧氏距离 L2范数： image-20220518172512266 •余弦相似度： image-20220519101722620 余弦值作为衡量两个个体间差异的大小的度量 为正且值越大，表示两个文本差距越小，为负代表差距越大， K值的选择 一、近似误差与估计误差： 近似误差：对现有训练集的训练误差，关注训练集，如果近似误差过小可能会出现过拟合的现象，对现有的训练集能有很好的预测，但是对未知的测试样本将会出现较大偏差的预测。模型本身不是最接近最佳模型。 估计误差：可以理解为对测试集的测试误差，关注测试集，估计误差小说明对未知数据的预测能力好，模型本身最接近最佳模型。 二、K值确定标准： K值过小：k值小，特征空间被划分为更多子空间（模型的项越多），整体模型变复杂，容易发生过拟合，k值越小，选择的范围就比较小，训练的时候命中率较高，近似误差小，而用test的时候就容易出错，估计误差大，容易过拟合。 K值=N：无论输入实例是什么，都将简单的预测他属于训练实例中最多的类。 关键代码展示 训练代码 123456789101112131415161718192021def train_data(train_set): with open(&quot;train.txt&quot;,&#x27;r&#x27;) as file: lines=file.readlines()[1:] #读取第二行到最倒数第一行 for sntn in lines: sntn=sntn.split() sntn[1]=int(sntn[1]) #修改字符为整型 dict=&#123;&#125; #建立空字典 for i in range(3,len(sntn)): #从第三个单词开始遍历句子（有效单词） if(not(sntn[i] in mark)): #加入训练集合 mark[sntn[i]]=0 word.append(sntn[i]) #便于标记训练集句子和测试集句子的单词数量 temp=sentence(sntn,len(sntn)-3,&#123;&#125;) #建立句子类，存入到训练集和train_set train_set.append(temp) for i in range(len(train_set)): #遍历训练集合train_set,计算每个句子的单词频数 dict=copy(mark) for j in range(3,len(train_set[i].sentence)): dict[train_set[i].sentence[j]]+=1 train_set[i].dict=copy(dict) 测试代码 123456789101112131415161718def test_data(test_set): with open(&quot;test.txt&quot;,&#x27;r&#x27;) as file: lines=file.readlines()[1:] #读取第二行到最倒数第一行 for sntn in lines: sntn=sntn.split() sntn[1]=int(sntn[1]) #修改字符为整型 dict=&#123;&#125; #建立空字典 temp=sentence(sntn,len(sntn)-3,dict) #建立句子类，存入到测试集和test_set test_set.append(temp) for i in range(len(test_set)): #遍历训练集合train_set,计算每个句子的单词频数 dict=copy(mark) for j in range(3,len(test_set[i].sentence)): if(test_set[i].sentence[j] in dict): dict[test_set[i].sentence[j]]+=1 #采用TF策略，计算某个单词在该句子计算的频数 test_set[i].dict=copy(dict) KNN核心算法 12345678910111213141516171819202122232425262728293031res=[]def KNN(train_set,test_set,K): emo_possible=train_set[0].sentence[1] #设置默认心情 min=999999999 sum=0 #记录正确数 for i in range(len(test_set)): #遍历测试句子 min=999999999 emo=[0,0,0,0,0,0,0] #记录距离较短的前K个预测 qp=[] #记录预测心情，以及对应的距离 max=-1 for k in range(len(train_set)): #测试句子与训练句子一一比对 dist=0 for j in range(len(word)): #计算测试句子与训练句子的距离（欧氏距离） dist+=abs(test_set[i].dict[word[j]]-train_set[k].dict[word[j]]) dist=dist**0.5 qp.append([dist,train_set[k].sentence[1]]) #记录预测心情，以及对应的距离 qp.sort() #按距离从小到大排队 for k in range(int(K)): #记录距离较短的前K个预测 emo[qp[k][1]]+=1 #记录预测心情出现的频数 for k in range(1,7): #选择预测频数心情作为最终预测心情 if(emo[k]&gt;max): max=emo[k] emo_possible=k res.append(emo_possible) #记录最终预测心情 if(res[i]==test_set[i].sentence[1]): sum+=1 #如果预测正确，sum++ print(sum/len(test_set)) #答应正确率 另设计：采用sklearn和余弦相似度 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778def cosine_distance(x, y): #计算余弦相似度 xnorm = np.linalg.norm(x) ynorm = np.linalg.norm(y) #计算模长 if xnorm == 0: return 0 return 1.0 - np.dot(x,y) / (xnorm * ynorm) #计算相似度def euclidean_distance(x, y): return np.linalg.norm(x - y) #计算欧式距离def testing(train,test, k): label = [] train_data = [] test_data=[] #处理训练文件数据 with open(train_file) as train: for each in train: if each == &quot;documentId emotion words\\n&quot;: continue temp = each.split(&#x27; &#x27;, 3) label.append(int(temp[1])) #标记句子心情 train_data.append(temp[3].replace(&#x27;\\n&#x27;, &#x27;&#x27;)) #从temp[3]开始读入训练句子 #处理测试文件数据 label2=[] with open(test_file) as test: for each in test: if each == &quot;documentId emotion words\\n&quot;: continue temp = each.split(&#x27; &#x27;, 3) label2.append(int(temp[1])) test_data.append(temp[3].replace(&#x27;\\n&#x27;, &#x27;&#x27;)) #使用sklearn的CountVectorizer处理文本，生成词库和词语出现次数的矩阵 lenth = int(len(train_data) ) length=int(len(test_data) ) # test_data = train_data[lenth:] train_label = label[0:lenth] ans = label2[:] #标记心情 tfidf = TfidfVectorizer() tfidf.token_pattern = r&quot;(?u)\\b\\w+\\b&quot; tfidf_train = tfidf.fit_transform(train_data[0:lenth]) tfidf_vec = tfidf_train.toarray() #使用sklearn的KNeighborsClassifier进行分类 knn = KNeighborsClassifier(n_neighbors = k, metric=&quot;cosine&quot;) knn.fit(tfidf_vec, train_label) tfidf_test = tfidf.transform(test_data) test_vec = tfidf_test.toarray() predict_label = knn.predict(test_vec) # print(&quot;Sklearn&#x27;s result:&quot;,predict_label.tolist()) print(&quot;Sklearn&#x27;s accuracy:&quot;, metrics.accuracy_score(ans, predict_label))#########以上是调用sklearn进行学习测试######### test_vec = tfidf_test.toarray() #自己进行测试 all = len(test_data) correct = 0 my_label = [] for i, text in enumerate(test_vec): emo_count = [0, 0, 0, 0, 0, 0] dis = [] for each in tfidf_vec: #逐句计算余弦相似度 dis.append(cosine_distance(text, each)) temp = sorted(enumerate(dis), key=lambda x:x[1]) sortdis = [x[0] for x in temp] #按距离从小到大进行排序 for j in range(k): emo_count[train_label[sortdis[j]] - 1] += 1 max_data = max(emo_count)#选择前K个中的众数作为预测的心情 my_label.append(emo_count.index(max_data) + 1) if (emo_count.index(max_data) + 1) == ans[i]: #检测预测是否正确，若正确correct++ correct += 1 print(&quot;My accuracy:&quot;, correct / all)#####以上借用sklearn数据特征，使用自定义的距离公式（余弦相似度）进行学习测试###### 优化改进 距离计算&amp;算法效率 123456789for k in range(len(train_set)): same_word=0 for j in range(3,len(test_set[i].sentence)): if(not(test_set[i].sentence[j] in mark)): continue if(test_set[i].sentence[j] in train_set[k].dict): same_word+=1 temp=len(train_set[k].dict)+len(test_set[i].dict)-2*same_word dist=(len(train_set[k].dict)+len(test_set[i].dict)-2*same_word)**0.5 采用one hot 策略，简化计算公式 对比 改进前 改进后 改进后的计算相较于之前的算法要加快许多而且准确度也较高，原因是将遍历单词计算频数，简化为一个公式 dist=(len(train_set[k].dict)+len(test_set[i].dict)-2*same_word)**0.5 测试句子与训练句子做对比，找出相同的单词，那么这些单词在计算欧式距离时抵消 相反，那些不相同的单词将纳入计算训练句子和测试句子的考量 三、实验结果及分析 实验结果展示实例 自行设计的数据结构 image-20220519082210038 第一列显示预测的心情 ，第二列显示预测的心情，第三列显示预测结果。 可以看到预测是joy的句子占大多数，原因是训练句子里面joy的比例较大，使得训练集某些句子产生聚集，使得预测句子产生误差。 测试句子的正确率为36.9%，设置的K=34 使用sklearn库 image-20220519101233681 sklearn库测试句子的正确率为37.4%，设置的K=34 自行设计的距离计算（余弦相似度）测试句子的正确率为36.1%，设置的K=34","categories":[],"tags":[{"name":"KNN","slug":"KNN","permalink":"https://klc1006.github.io/tags/KNN/"},{"name":"分类","slug":"分类","permalink":"https://klc1006.github.io/tags/%E5%88%86%E7%B1%BB/"}]},{"title":"【AI Course】朴素贝叶斯","slug":"AI Course 7 203","date":"2022-05-06T16:00:00.000Z","updated":"2023-03-08T16:59:06.635Z","comments":true,"path":"2022/05/07/AI Course 7 203/","link":"","permalink":"https://klc1006.github.io/2022/05/07/AI%20Course%207%20203/","excerpt":"中山大学计算机学院 人工智能实验报告（七） (2022春季实验报告) 课程名称:Artificial Intelligence 教学班级 专业方向 学号 姓名 计科1班 计算机科学与技术 20337013 陈梁坤 一、实验题目 在给定文本数据集完成文本情感分类训练，在测试集完成测试，计算准确率。 思考：在前面的文本分类算法中，如果测试文本中的单词没有在训练文本中出现会造成什么结果？ 会影响到后验概率的计算结果，使分类产生偏差。解决这一问题的方法是采用贝叶斯估计。具体地，方法为： image-20220511210520596 式中 λ≥0。等价于在随机变量各个取值的频数上赋予一个正数 λ≥0。当 λ=0 时就是极大似然估计。尝取 λ=1，这时称为拉普拉斯平滑 (Laplacian smoothing)。 要求使用拉普拉斯平滑技巧提高准确率","text":"中山大学计算机学院 人工智能实验报告（七） (2022春季实验报告) 课程名称:Artificial Intelligence 教学班级 专业方向 学号 姓名 计科1班 计算机科学与技术 20337013 陈梁坤 一、实验题目 在给定文本数据集完成文本情感分类训练，在测试集完成测试，计算准确率。 思考：在前面的文本分类算法中，如果测试文本中的单词没有在训练文本中出现会造成什么结果？ 会影响到后验概率的计算结果，使分类产生偏差。解决这一问题的方法是采用贝叶斯估计。具体地，方法为： image-20220511210520596 式中 λ≥0。等价于在随机变量各个取值的频数上赋予一个正数 λ≥0。当 λ=0 时就是极大似然估计。尝取 λ=1，这时称为拉普拉斯平滑 (Laplacian smoothing)。 要求使用拉普拉斯平滑技巧提高准确率 二、实验内容 算法原理 朴素贝叶斯法 思想：朴素贝叶斯假设，又称条件独立性假设 做法：根据贝叶斯定理来估计每个类别的后验概率。 朴素贝叶斯法的目标是找到 image-20220511202930293 image-20220511205602180 image-20220511205530600 image-20220511205640632 关键代码展示 训练数据集 123456789101112131415161718192021222324252627282930emotion=[0,0,0,0,0,0,0]#记录整个训练数据集不同的情感的频数total=[0,0,0,0,0,0,0] #记录每种情感的中不同单词的个数mark=&#123;&#125;dict=[]def trainNB(train_set): global total words=&#123;&#125; with open(&quot;train.txt&quot;,&#x27;r&#x27;) as file: lines=file.readlines()[1:]#读取第二行到最倒数第一行 for sentence in lines: sentence=sentence.split() # sentence[0]：句子编号 sentence[1]：情绪编号 sentence[2]:情绪 sentence[1]=int(sentence[1]) #将情绪变换转成int便于判断 emotion[sentence[1]]+=1 #记录整个训练数据集不同的情感的频数 train_set.append(sentence) #用train_set记录整个训练数据集 for i in range(1,7):# d=&#123;&#125; #记录某一情绪之下，某一个单词出现的频数 for j in range(len(train_set)): #编译整个训练数据集 if(train_set[j][1]==i): for k in range(3,len(train_set[j])): # mark[train_set[j][k]]=0 #记录整个训练数据集的不同单词的个数，总数用于拉普拉斯平滑技巧 total[i]+=1 #记录每一种情感的不同单词的个数 if(train_set[j][k] in d): #单词加入字典便于查找 d[train_set[j][k]]+=1 else: d[train_set[j][k]]=1 dict.append(d #记录每一种情绪的单词频数表 测试数据集 123456789101112131415161718192021222324252627282930313233v=[]#记录测试的出的情感集合def testNB(train_set,test_set): with open(&quot;test.txt&quot;,&#x27;r&#x27;) as file: lines=file.readlines()[1:]#读取第二行到最倒数第一行 for sentence in lines: sentence=sentence.split() sentence[1]=int(sentence[1]) test_set.append(sentence)#读取测试数据集的句子 emo_prossible=1 #标记当前最优可能的情感 max_prob=-1 #最大可能概率 curr_prob=1 #记录档当前情感的概率 correct=0 #记录测试正确的数目 for i in range(len(test_set)): #遍历测试集合，取出句子逐一比对 emo_prossible=1 #初始化当前最优可能的情感 max_prob=-1 #初始化最优可能的情感的概率 for j in range(len(dict)): curr_prob=1 #初始化当前的情感的概率 for k in range(3, len(test_set[i])): #取出测试句子中的每个单词 if(test_set[i][k] in dict[j]): #采用拉普拉斯平滑计算概率 curr_prob*= (dict[j][test_set[i][k]]+alpha)/(total[j+1]+len(mark)*alpha) elif(test_set[i][k] in mark): #如果从测试句子的单词不在当前训练语句里面，采用拉普拉斯平滑避免概率为0 curr_prob*=(alpha)/(total[j+1]+len(mark)*alpha) #设置参数为1 curr_prob*=emotion[j+1]/len(train_set) if(curr_prob&gt;max_prob): #更新最优可能情感的信息 max_prob=curr_prob emo_prossible=j+1 v.append(emo_prossible) #将每句估计的情感保存 if(emo_prossible==test_set[i][1]): correct+=1 #记录正确估计情感的频数 print(correct/len(test_set)) #输出正确率 对比输出 12345678def result_comparison(test_set): print(&quot;assessment fact&quot;) for i in range(len(test_set)): if(v[i]==test_set[i][1]): print(emo[v[i]],test_set[i][2],&quot; &quot;,end=&quot;&quot;) print(&quot;correct&quot;) else: print(emo[v[i]],test_set[i][2]) 三、实验结果及分析 实验结果展示实例 不使用拉普拉斯平滑 设置alpha=0 image-20220511210146496 输出结果 第一列是估计的情感，第二列是实际情感，如果估计正确输出correct 最后一行显示该估计算法的正确率 可以看到当不用拉普拉斯平滑时，正确率只有23.4% 使用拉普拉斯平滑 image-20220511201955088 输出结果 第一列是估计的情感，第二列是实际情感，如果估计正确输出correct 最后一行显示该估计算法的正确率 可以看到当使用拉普拉斯平滑后正确率提高到了38.4%","categories":[],"tags":[{"name":"朴素贝叶斯","slug":"朴素贝叶斯","permalink":"https://klc1006.github.io/tags/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/"}]},{"title":"【AI Course】归结演绎推理","slug":"AI Course 6","date":"2022-04-27T16:00:00.000Z","updated":"2023-03-08T16:59:12.331Z","comments":true,"path":"2022/04/28/AI Course 6/","link":"","permalink":"https://klc1006.github.io/2022/04/28/AI%20Course%206/","excerpt":"中山大学计算机学院 人工智能实验报告（六） (2022春季实验报告) 课程名称:Artificial Intelligence 教学班级 专业方向 学号 姓名 计科1班 计算机科学与技术 20337013 陈梁坤 一、实验题目 编写程序，实现一阶逻辑归结算法，并用于求解给出的三个逻辑推理问题，要求输出按照如下格式： (P(x),Q(g(x))) (R(a),Q(z),¬P(a)) R1a,2c (Q(g(a)),R(a),Q(z)) “R” 表示归结步骤. “1a” 表示第一个子句(1-th)中的第一个 (a-th)个原子公式，即P(x). “2c”表示第二个子句(1-th)中的第三个 (c-th)个原子公式，即¬P(a). “1a”和“2c”是冲突的，所以应用最小合一{X = a}.","text":"中山大学计算机学院 人工智能实验报告（六） (2022春季实验报告) 课程名称:Artificial Intelligence 教学班级 专业方向 学号 姓名 计科1班 计算机科学与技术 20337013 陈梁坤 一、实验题目 编写程序，实现一阶逻辑归结算法，并用于求解给出的三个逻辑推理问题，要求输出按照如下格式： (P(x),Q(g(x))) (R(a),Q(z),¬P(a)) R1a,2c (Q(g(a)),R(a),Q(z)) “R” 表示归结步骤. “1a” 表示第一个子句(1-th)中的第一个 (a-th)个原子公式，即P(x). “2c”表示第二个子句(1-th)中的第三个 (c-th)个原子公式，即¬P(a). “1a”和“2c”是冲突的，所以应用最小合一{X = a}. 二、实验内容 1.算法原理 归结演绎推理 一种基于逻辑“反证法”的机械化定理证明方法。 基本的方法论是将永真性证明转换为不可满足证明。例如：要证明P→Q 的正确性，即可证明 P ∧ ﹁ Q 为不可满足的 该原理通过检查子句集 S 中是否包含空子句，若包含，则 S 不可满足。 若不包含，在 S 中选择合适的子句进行归结，一旦归结出空子句，就说明 S 是不可满足的。 可以看下面的例子有更加直观的理解 image-20220512165537913 最一般合一 为了解决谓词演算归结，不可避免地需要合一算法参与解决。 置换 定义: 置换是一个形如{t1/v1,…, tn/vn}的有限集,其中每个vi是变量,ti是不同于vi的项（常量、变量或函数）(vi≠ti). 当i≠j时，vi≠vj. 无元素组成的置换称为空置换, 记为ε; 被置换元素必是变量，置换元素是项; 置换元素必不同于被置换元素; 在一次置换中，针对同一元素的置换只能出现一次(单次置换的同时性); 无元素组成的置换，成为空置换; 合一 通过变量置换，使得具有两个相同（或相反）原子公式的子句可以归结，合一也被定义使得两个原子公式等价的一组变量替换/赋值 o由于一阶逻辑中存在变量，所以归结之前需要进行合一，如(P(john),Q(fred),R(x))和(¬P(y),R(susan),R(y))两个子句中，我们无法找到一样的原子及其对应的否定，但是不代表它们不能够归结 o通过将y替换为john，我们得到了(P(john),Q(fred),R(x))和(¬P(john),R(susan),R(john))，此时我们两个子句分别存在原子P(john)和它的否定¬P(john)，可以进行归结 最一般合一 指使得两个原子公式等价，最简单的一组变量替换 具体算法如下 输入两原子公式具有相同谓词，不同的参数项以及\"¬\" k=0,σ0={}，S0={f，g} 如果Sk的公式等价，返回σk作为最一般合一结果 否则找出Sk中的不匹配项Dk={e1,e2}t 如果e1=V是常量，e2=t是一个不包含变量V的项，将V=t添加到赋值集合σk+1=σkU{V=t}；并将Sk中的其他变量也赋值为t，得到Sk+1，k=k+1，转到第二步 否则合一失败 归结 将α取否定，加入到KB当中 将更新的KB转换为clausal form得到S 反复调用单步归结 如果得到空子句，即S|-()，说明KB ∧¬α 不可满足，算法终止，可得KB |= α 如果一直归结直到不产生新的子句，在这个过程中没有得到空子句，则KB |= α不成立 单步归结 使用MGU算法从两个子句中得到相同的原子，及其对应的原子否定 去掉该原子并将两个子句合为一个，加入到S子句集合中 例如(¬Student(x),HardWorker(x))和(HardWorker(sue))合并为(¬Student(sue)) 2.关键代码展示 分解句子 12345678910num = 0clauses = []num=int(input()) #输入子句for i in range(0, num): #分解子句为原子式 clause = [] #将原子式分解成谓词和项 for item in re.findall(r&#x27;¬*[a-zA-Z]+\\([a-zA-Z,\\s]*\\)&#x27;, input()): items = re.findall(r&#x27;[¬a-zA-Z]+&#x27;, item) clause.append(items) clauses.append(clause) 计算一个原子式子里的变量个数 123456def variable_num(item): vari_num=0 for i in range(1,len(item)): #遍历原子式 if(len(item[i])==1): #默认变量的长度都是1 vari_num+=1 #发现存在变量，vari_num++ return vari_num #返回变量总数 查找变量索引 12345def vari_index(item): index=1 while(len(item[index])!=1): #查找到第一个变量，返回索引 index+=1 return index #返回索引 判断原子式是否互补 12345def consistant(item1,item2): #再两个原子式传入之前，已经确定谓词互补 for i in range(1,len(item1)):#遍历，判断置换后的原子式是否一致,如果一致可以归结 if(item1[i]!=item2[i]): return False return True 数据结构 12345match=[] #用于记录匹配过的子句step=[] #用于回溯实用的子句for cnt in range(num): step.append((cnt,cnt,cnt,cnt,cnt,cnt)) #step[匹配子句1，匹配子句2，子句的原子式1，子句的原子式2,变量，替换的常量] 遍历子句（归结判断） 1234567891011121314while(i&lt;len(clauses)-1 ): #i,j用于遍历自己一一进行配对，将每一次的配对检测记录再mark数组中 if(new == []): #如果新归结的子句是[],跳出循环 break for j in range(len(clauses)):#如果新归结的子句是[],跳出循环 if(new == []): break #如果新归结的子句是[],跳出循环 for k in range(len(clauses[i])): #对于每一个子句都取出一个原子式，进行一一匹配 if(new == []): break #如果新归结的子句是[],跳出循环 for l in range(len(clauses[j])): ...... match.append((i,j)) #记录匹配过的子句 合一 123456789if(&#x27;¬&#x27;+clauses[i][k][0]==clauses[j][l][0] or clauses[i][k][0]==&#x27;¬&#x27;+clauses[j][l][0] ):# #判断谓词的互补情况 if((i,j) in match or (j,i) in match or i==j ): #匹配过不再匹配，子句自己不能匹配 continue temp1=copy.deepcopy(clauses[i][:])#记录子句1 temp2=copy.deepcopy(clauses[j][:])#记录子句2 item1=copy.deepcopy(clauses[i][k])#记录子句1中的原子式 item2=copy.deepcopy(clauses[j][l])#记录子句2中的原子式 置换 123456789101112131415161718192021dition=&#123;&#125; #记录需要置换的变量和常量del temp1[k] #删除临时子句中1的对应的可能可以归结的原子式del temp2[l] #删除临时子句中1的对应的可能可以归结的原子式id=vari_index(item2) #记录含有变量的原子式中变量的索引下标dition[item2[id]]=item1[id] #记录需要置换的变量和常量与字典给中，编译查找替换变量var1=item2[id] #记录置换的变量var2=item1[id] #记录置换的常量item2[id]=item1[id] #置换变量和常量for t in range(len(temp2)): #需要替换掉子句中对应的所有变量都置换为常量 for idx in range(1,len(temp2[t])): if(temp2[t][idx] in dition): temp2[t][idx]=dition[temp2[t][idx]] #使用字典便于置换if(consistant(item1,item2)): #判断置换后置换后的原子式是否一致，如果一致，则满足归结条件，以下进行归结 new=temp1+temp2 #保存归结后的子句 match.append((i,len(clauses)))#记录新产生的子句有哪两个子句归结生成，不在进行归结，使得子句不会变得归于复杂 match.append((j,len(clauses)))#记录新产生的子句有哪两个子句归结生成，不在进行归结，使得子句不会变得归于复杂 step.append((i,j,k,l,var1,var2))#记录每个子句由那两个子句，那两个原子式生成，保存置换情况 clauses.append(new) 输出步骤 12345678910111213141516171819202122232425262728293031323334353637383940explored=[] #记录输出过的子句，避免重复输出step_num=num-1 #记录目前输出的子句编号def print_step(n): #递归回溯 global step_num if(n&lt;num):return #当搜索子句序号小于起始子句总数时，返回 print_step(step[n][0]) #递归搜索&quot;父母子句&quot; print_step(step[n][1]) #递归搜索&quot;父母子句&quot; if( clauses[n] in explored ):return #避免重复输出子句 step_num+=1 d[n]=step_num #记录子句输出编号 #step[匹配子句1，匹配子句2，子句的原子式1，子句的原子式2,变量，替换的常量] #输出子句 print(&quot;R[&quot;+str(d[step[n][0]]+1),end=&quot;&quot;) if(len(clauses[step[n][0]])!=1): #匹配子句1不止一个原子式 print(chr(step[n][2]+97),end=&quot;&quot;) print(&quot;,&quot;+str(d[step[n][1]]+1),end=&quot;&quot;) if(len(clauses[step[n][1]])!=1): #匹配子句2不止一个原子式 print(chr(step[n][3]+97),end=&quot;&quot;) if(len(step[n])==6): #子句合一存在置换操作，输出置换操作 print(&quot;](&quot;+str(step[n][4])+&quot;=&quot;+str(step[n][5])+&quot;) = &quot;,end=&quot;&quot;) else: print(&quot;R[&quot;+str(d[step[n][0]]+1)+chr(step[n][2]+97)+&quot;,&quot;+str(d[step[n][1]]+1)+chr(step[n][3]+97)+&quot;] = &quot;,end=&quot;&quot;) if(len(clauses[n])==0):print(&quot;[]&quot;) #输出合一后的子句 for i in range(len(clauses[n])): for j in range(len(clauses[n][i])): if(j==0): print(str(clauses[n][i][j])+&quot;(&quot;,end=&quot;&quot;) elif(j==len(clauses[n][i])-1): print(str(clauses[n][i][j])+&quot;)&quot;,end=&quot;&quot;) else: print(str(clauses[n][i][j])+&quot;,&quot;,end=&quot;&quot;) if(i!=len(clauses[n])-1):print(&quot;,&quot;,end=&quot;&quot;) else:print(&quot; &quot;) explored.append(clauses[n]) #把输出过的子句加入explored数组，避免重复输出 3.创新点&amp;优化 1match=[] #用于记录匹配过的子句 加入match数组以避免相同的子句进行归结，减少探索子句。 样例3：3' blocks 优化前 优化后 优化结果表明探索的语句从71句降到了15局，明显减少了探索语句，提高时间效率，很好地解决了重复探索的问题 样例4：自测 优化前 优化后 可以看到优化前后探索子句数量有明显差异，去重方法能够减少探索子句数量，提高算法效率。 三、实验结果及分析 1.实验结果展示实例 样例1：AIpine Club 12345678910111213###### input for AIpine Club ######A(tony)A(mike)A(john)L(tony, rain)L(tony, snow)(¬A(x), S(x), C(x))(¬C(y), ¬L(y, rain))(L(z, snow), ¬S(z))(¬L(tony, u), ¬L(mike, u))(L(tony, v), L(mike, v))(¬A(w), ¬C(w), S(w))################################### 参考结果 实验结果 实验结果比参考结果的归结语句多了一句，实际上是由于遍历顺序导致的，遍历的顺序不同，导致首先产生归结语句也所不同 样例2：hardworker(sue) 123456#### input for hardworker(sue) #### GradStudent(sue) (¬GradStudent(x), Student(x)) (¬Student(x), HardWorker(x)) ¬HardWorker(sue)################################### 参考结果 实验结果 实验结果的归结语句与参考的结果一致，但是归结的句子有所不同，遍历的顺序不同，导致首先产生归结语句也所不同。 样例3：3' blocks 1234567####### input for 3&#x27; blocks ####### On(aa,bb) On(bb,cc) Green(aa) ¬Green(cc) (¬On(x,y), ¬Green(x), Green(y))################################### 参考结果 实验结果 实验结果的归结语句与参考的结果一致，但是归结的句子有所不同，遍历的顺序不同，导致首先产生归结语句也所不同。 样例4：自测 12345T(Wang,Li)C(Li,Zhang)¬ANSWER(Wang)(¬C(Li,y),¬T(z,Li),T(z,y))(¬T(u,Zhang),ANSWER(Wang)) image-20220427175024500 由自测结果表明设计的算法能够归结成功 样例5：自测（归结演绎） 1234T(Wang,Li)C(Li,Zhang)(¬C(Li,y),¬T(z,Li),T(z,y))(¬T(u,Zhang),ANSWER(Wang)) image-20220428150059648 按照自测的归结演绎，成功归结出ANSWER(Wang) 2.指标展示和分析 样例1：AIpine Club image-20220428131323571 探索子句总共产生620句，与优化前的结果相当，此处不在作展示 样例2：hardworker(sue) image-20220428142403308 探索子句总共产生10句，与优化前的结果相当，此处不在作展示 样例3：3' blocks image-20220428142414371 探索子句总共产生15句，相比优化前的探索语句（71句）有所提升 样例4：自测 image-20220428142423200 探索子句总共产生14，相比优化前的探索语句（22句）有所提升 四、总结 本次归结算法设计存储子句，合一操作，置换操作，归结操作。 存储子句需要将原子式分离谓词以及项 置换操作需要判断原子式中变量和常量之间的关系，才有利于程序更加有条理地执行 合一操作在置换操作下进行，判断两个原子式互补即可进行合一 归结操作输出合一后产生的子句，该子句可用于新的归结操作 以上算法通过全局遍历，寻找可归结的子句，在子句较多时能够快速等到归结方案。 五、参考资料 无","categories":[],"tags":[{"name":"归结推理","slug":"归结推理","permalink":"https://klc1006.github.io/tags/%E5%BD%92%E7%BB%93%E6%8E%A8%E7%90%86/"}]},{"title":"【AI Course】A*和 IDA*算法解决15-puzzle问题","slug":"AI Course3","date":"2022-04-08T16:00:00.000Z","updated":"2023-03-09T03:06:56.794Z","comments":true,"path":"2022/04/09/AI Course3/","link":"","permalink":"https://klc1006.github.io/2022/04/09/AI%20Course3/","excerpt":"中山大学计算机学院 人工智能实验报告（三） (2022春季实验报告) 课程名称:Artificial Intelligence 教学班级 专业方向 学号 姓名 计科1班 计算机科学与技术 20337013 陈梁坤 一、实验题目 使用A*和 IDA*算法解决15-puzzle问题，启发式函数自己选取，可以尝试多种不同的启发式函数","text":"中山大学计算机学院 人工智能实验报告（三） (2022春季实验报告) 课程名称:Artificial Intelligence 教学班级 专业方向 学号 姓名 计科1班 计算机科学与技术 20337013 陈梁坤 一、实验题目 使用A*和 IDA*算法解决15-puzzle问题，启发式函数自己选取，可以尝试多种不同的启发式函数 二、实验内容 1.算法原理 问题重述 15数码问题本质上就是棋盘上乱序的15个数字将牌（整数1~15），通过允许空格周围的四个方向的将牌向空格移动，通过移动空格周围的数字将牌改变棋盘的格局（状态）。本实验的目标就是移动将牌。将初始状态改为目标状态 A*算法原理 A*算法应用启发式搜索的原理，启发式搜索又叫有信息搜索。利用问题当前状态所具有的信息来引导问题的解决方向（向最有希望的方向前进），相较于盲目搜索（无信息搜索），能够降低问题的复杂度。 定义函数： 函数 意义 g(n) 从初始节点到节点n付出的实际代价 h(n) 从节点n到目标节点的最优路径的估计代价 h*(n) 从节点n到目标节点的最优路径的实际代价 f(n) 从初始节点到目标节点的最优路径的估计代价 \\[ f(n)=g(n)+h(n) \\] A*算法可以看作BFS的优化，在BFS算法st的基础上加以提升：从初始节点（状态）开始，检测后继节点（状态），选取f(n)最小的节点进行拓展（可以利用优先队列来实现），同时更新被访问过的节点的g(n),直到找到目标节点，即当前节点的f(n)==0 核心算法步骤： ①从起始状态start开始，把start作为一个待处理的对象加入优先队列OPEN中 ②从起始状态开始，搜索空格周围可能处理的下一个状态，并把他们加入OPEN中，计算这些状态的f(n),g(n),h(n),设置存储他们的父状态start 或设置存储上一步操作 ③从OPEN中删除状态start，并加入CLOSE列表（相当于visit数组），循环操作直到找到目标状态或者开启列表为空 ④从OPEN中找到f(n)最小的状态，并进行拓展，计算这些状态的f(n),g(n),h(n),设置存储他们的父状态start 或设置存储上一步操作 ⑥如果新的相邻状态已经在开启列表，则更新他们的g(x) IDA*算法原理 IDA*是迭代加深深度优先搜索的拓展，与A*算法的结合。由于不需要存储父节点（状态），空间复杂度远远小于A* 定义函数 函数 意义 g(n) 从初始节点到节点n付出的实际代价 h(n) 从节点n到目标节点的最优路径的估计代价 h*(n) 从节点n到目标节点的最优路径的实际代价 f(n) 从初始节点到目标节点的最优路径的估计代价 在每一步的迭代深度搜索的过程中，都是优先对邻接状态f(n)最小的状态进行搜索，当某一层的搜素的所有可访问的最小可估价函数&gt;某一给定的阈值时，即h(n)&gt;h*(n)，进行剪纸，不在访问，进行回溯。 核心算法布置 ①设计阈值bound，定义递归的进程 ②从起始状态start开始，计算start可达到的每一个下一个状态的估计f(n),选取最小的节点作为下一个访问状态 ③对于某一个状态，如果估价函数大于bound，返回当前状态的估价函数值，范围为false ④对一某一个状态，如果是目标状态，则返回true，并返回该状态。 2.关键代码展示 **启发式函数** 123456789101112131415161718MDT=[] #定义矩阵MDT,MDT[i][j]定义为第i个格子到第j个格子的曼哈顿距离for i in range(16): tmp=[] for j in range(16): tmp.append(abs(int(i / N) - int(j / N))+abs(int(i % N) - int(j % N))) #构造每个数字将牌到目标位置的曼哈顿距离 MDT.append(tmp) #虽然增加了空间的使用，但是减少了函数的调用，把调用函数转化为访问空间def manhattan(pz): #定义曼哈顿距离函数（启发式函数） sum=0 #初始化h(n)为0 for i in range(N2): if pz[0][i]==N2: #当数字为16，即空格位置，不算入h(n)估价，跳过 continue sum+=MDT[i][pz[0][i]-1] #遍历每个数字，计算累积的的最终状态代价 return sum #返回h(n) ​ A*算法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465def Astar(s): OPEN=PriorityQueue() #优先队列OPEN存放待访问状态，f(n)函数小的状态优先拓展 s.MD=manhattan(s) #求初始状态的h(n) s.cost=0 #定义初始状态的g(n)为0 CLOSE=&#123;&#125; #定义CLOSE数组，存放拓展过的状态节点 u=puzzle() #声明u便于暂存当前状态 v=puzzle() # 声明v便于暂存当前状态 initial=State() # 声initial便于暂存当前状态 # initial.puzzle.MD=0+s.MD # initial.puzzle.cost=0+s.cost # initial.puzzle.space=0+s.space # for i in range(45): # initial.puzzle.path[i]=0+s.path[i] # for i in range(16): # initial.puzzle.f[i]=0+s.f[i] initial.puzzle=copy.deepcopy(s) #深拷贝函数耗时较长 initial.estimated=manhattan(s) #计算初始状态h(n) OPEN.put(initial) #初始状态加入队列 while (not OPEN.empty()): #当队列不为空，搜索不停止 global sum #就算探索状态节点 sum+=1 st=State() #声明st便于暂存出队状态节点 st=copy.deepcopy(OPEN.get()) #st暂存出队状态节点 # print(st.puzzle.f) u=copy.deepcopy(st.puzzle) #u暂存出队状态节点的数字棋盘 # print(u.f) if(u.MD==0): #当启发函数最小估计代价为0，即搜索至目标状态 # print(u.f) # print(u.path) print(len(CLOSE)) return u #返回成功搜索节点状态 CLOSE[u.f.__str__()]=True #CLOSE数组存储已经拓展过的状态节点 sx=int(u.space/N) #空格的横坐标 sy=int(u.space%N) #空格的纵坐标 # print(sx,sy) for r in range(4): #对四个方向的邻接状态进行探索 tx=sx+diraction[r][0] #下一个状态的横坐标 ty=sy+diraction[r][1] #下一个状态的纵坐标 if (tx&lt;0 or ty&lt;0 or tx&gt;=N or ty&gt;=N):#空格越界，接续执行 continue v=copy.deepcopy(u) #保存出队状态 v.MD-=MDT[tx*N+ty][v.f[tx*N+ty]-1] v.MD+=MDT[sx*N+sy][v.f[tx*N+ty]-1] #计算移动数字后的状态的h(n) temp=v.f[tx * N + ty] v.f[tx * N + ty]=v.f[sx * N + sy] v.f[sx * N + sy]=temp #移动数字的操作:被移动数字与16交换 v.space=tx*N+ty #记录移动后空格所处的位置 if(not (v.f.__str__() in CLOSE) ): #环检测，如果没有出过队 # path[v.cost]=dir[r] #找路径和状态 # print(v.f) v.path.append(r) #队列加入邻接状态 v.cost+=1 #cost++ g(n)函数 new=State() #创建新的state，用于入队列 new.puzzle=copy.deepcopy(v) new.estimated=v.cost+v.MD OPEN.put(new) #入优先队列OPEN return -1 ​ IDA*算法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102def IDAstar(depth,prev): #IDA*函数 global sum_node #统计访问过的状态的数量 sum_node+=1 global state #使用全局变量 状态state global bound #使用全局变量 阈值bound if state[2] ==0: #如果当前状态到目标状态的最小估计代价为0,即当前状态为目标状态 return (True,depth+state[2]) #返回（搜索成功，成功搜索步数） if depth+state[2]&gt;bound: #如果初始状态到当前状态的最小代价g(n)=depth+当前状态到目标状态的最小估计代价h(n)&gt;阈值 return (False,depth+state[2]) #返回（搜索失败，失败搜索步数） sx=int(state[1]/N) #一维位置转换为二维坐标 sy=int(state[1]%N) #一维位置转换为二维坐标 tmp=[[],0,0] #用于存储当前状态，便于回溯 successor=[] #后继，邻接状态 for r in range(4): tx=sx+diraction[r][0] #下一个状态的横坐标 ty=sy+diraction[r][1] #下一个状态的纵坐标 if (tx&lt;0 or ty&lt;0 or tx&gt;=N or ty&gt;=N): #空格越界，接续执行 continue if((max(prev,r)-min(prev,r))==2): #不走回头路 continue h_n=state[2]-MDT[tx*N+ty][state[0][tx*N+ty]-1] h_n+=MDT[sx*N+sy][state[0][tx*N+ty]-1] #计算移动数字后的状态的h(n) successor.append((h_n,r)) #插入后继数组 sorted(successor,key=lambda x:(x[0],x[1])) #对后继数组进行排序，h(n)较小的优先访问 successor.reverse() Min=[False,9999] #保存邻接状态的最小代价 for r in successor: tx=sx+diraction[r[1]][0] #下一个状态的横坐标 ty=sy+diraction[r[1]][1] #下一个状态的纵坐标 if (tx&lt;0 or ty&lt;0 or tx&gt;=N or ty&gt;=N): #空格越界，接续执行 continue if((max(prev,r[1])-min(prev,r[1]))==2): #对上一个状态判重剪枝 continue #tmp=copy.deepcopy(state) #存储当前状态，便于回溯 for item in state[0]: tmp[0].append(item) tmp[1]=0+state[1] tmp[2]=0+state[2] state[2]-=MDT[tx*N+ty][state[0][tx*N+ty]-1] state[2]+=MDT[sx*N+sy][state[0][tx*N+ty]-1] #计算移动数字后的状态的h(n) temp=state[0][tx * N + ty] state[0][tx * N + ty]=state[0][sx * N + sy] state[0][sx * N + sy]=temp #移动数字的操作:被移动数字与16交换 # print(state[0]) state[1]=tx*N+ty #记录移动后空格所处的位置 a=(False,0) #记录递归搜索后搜索成功与否，以及搜索步长 if(not str(state[0]) in CLOSE): #环检测 CLOSE[str(state[0])]=depth+state[2] #如果没有探索过，加入字典，并记录该状态的f(n) a=IDAstar(depth+1,r[1]) #迭代深搜 if(a[0]): #如果搜索成功 path[depth]=r[1] #记录当前深度的操作 return a #返回（搜索成功，最小步长） else: if(a[1]&lt;Min[1]): #如果没有搜索成功 Min[1]=a[1] #更新邻接状态的最小代价，用于更新阈值bound else: if CLOSE[str(state[0])]&gt;=(depth+state[2]): #如果当前状态已经被探索过，而且先前探索过的状态的f(n)&gt;目前相同状态的f(n) CLOSE[str(state[0])]=depth+state[2] #更新该状态的最小f(n) a=IDAstar(depth+1,r[1]) #迭代搜索 if(a[0]): #如果搜索成功 path[depth]=r[1] #记录当前深度的操作 return a #返回（搜索成功，最小步长） elif a[1]&lt;Min[1]: #如果没有搜索成功 Min[1]=a[1] #更新邻接状态的最小代价，用于更新阈值bound #state=copy.deepcopy(tmp) #回溯 for i in range(16): state[0][i]=0+tmp[0][i] state[1]=0+tmp[1] state[2]=0+tmp[2] return Mindef ID(In): #迭代深搜 global state #使用全局变量 状态state global bound #使用全局变量 阈值bound In[2] = manhattan(In) while True: #bound的值用全局变量进行更新 #state=copy.deepcopy(In) #使用深拷贝函数，保存状态 for i in range(16): state[0][i]=0+In[0][i] state[1]=0+In[1] state[2]=0+In[2] a=IDAstar(0,-100) #进入IDA*算法，返回（a[0]搜索成功与否，a[1]搜索代价） if (a[0]): #搜索成功，保存搜索路径 ans=&quot;&quot; for i in range(bound): ans+=dir[path[i]] #path利用0右边移动，1上边移动，2左边移动，3下边移动，保存 return ans bound=a[1] #阈值更新临界状态的最小代价f(n) if bound&gt;100: #超过限制退出循环 break return &quot;failed&quot; 3.创新点&amp;优化 提前判断该15数码问题是否有解 123456789101112def isValid(In): ans=1 for i in range(16): if not In[0][i]: ans+=6-i%4-i/4 for j in range(i): if In[0][j]&gt;In[0][i]: ans+=1 if ans&amp;1: return 1 #合法 else: return 0 #不合法 image-20220317000740937 原理： 在算N数码的逆序数时，不把0算入在内； 当N为奇数时， 当 两个N数码的逆序数 奇偶性相同时，可以互达，否则不行； 当N为偶数时，当 两个N数码的奇偶性相同的话，那么两个N数码中的0所在行的差值 k，k也必须是偶数时，才能互达； 当两个N数码的奇偶性不同时，那么两个N数码中的0所在行的差值 k，k也必须是奇数时，才能互达； 将深拷贝换成赋值语句 123456#tmp=copy.deepcopy(state) #存储当前状态，便于回溯for item in state[0]: tmp[0].append(item)tmp[1]=0+state[1]tmp[2]=0+state[2] 时间对比： 样例1 样例2 样例3 样例4 直接赋值 0.5s 0.3s 0.1s 4s 调用深拷贝函数 5.25s 3.1s 1.17s 38s 使用copy.deepcopy()是，程序新建地址空间，耗费大量时间，可以看到直接使用赋值语句，减少copy.deepcopy()函数的调用，大大提高用时效率。 **对IDA*加入环检测，较少访问节点次数** 123456789101112131415161718if(not str(state[0]) in CLOSE): #环检测 CLOSE[str(state[0])]=depth+state[2] #如果没有探索过，加入字典，并记录该状态的f(n) a=IDAstar(depth+1,r[1]) #迭代深搜 if(a[0]): #如果搜索成功 path[depth]=r[1] #记录当前深度的操作 return a #返回（搜索成功，最小步长） else: if(a[1]&lt;Min[1]): #如果没有搜索成功 Min[1]=a[1] #更新邻接状态的最小代价，用于更新阈值boundelse: if CLOSE[str(state[0])]&gt;=(depth+state[2]): #如果当前状态已经被探索过，而且先前探索过的状态的f(n)&gt;目前相同状态的f(n) CLOSE[str(state[0])]=depth+state[2] #更新该状态的最小f(n) a=IDAstar(depth+1,r[1]) #迭代搜索 if(a[0]): #如果搜索成功 path[depth]=r[1] #记录当前深度的操作 return a #返回（搜索成功，最小步长） elif a[1]&lt;Min[1]: #如果没有搜索成功 Min[1]=a[1] #更新邻接状态的最小代价，用于更新阈值bound 加入环检测后，针对IDA*的性能分析如下表： 样例1 样例2 样例3 样例4 有环检测剪枝 18651 12201 4315 158044 无环检测剪枝 21985 15389 4414 261175 仅对IDA*做出改进，可以看到加入环检测（判重）剪枝后，探索的状态节点有所减少，样例4为例，探访的状态节点少了五分之二 提前计算每个数字到指定位置的曼哈顿距离 123456MDT=[]for i in range(16): tmp=[] for j in range(16): tmp.append(abs(int(i / N) - int(j / N))+abs(int(i % N) - int(j % N))) MDT.append(tmp) 能够减少函数的调用，把函数调用转换为访问二维列表，提高运算效率 先对初步判断其后继状态节点的最小估计函数，较小的先探索 12345678910111213successor=[] #后继，邻接状态for r in range(4): tx=sx+diraction[r][0] #下一个状态的横坐标 ty=sy+diraction[r][1] #下一个状态的纵坐标 if (tx&lt;0 or ty&lt;0 or tx&gt;=N or ty&gt;=N): #空格越界，接续执行 continue if((max(prev,r)-min(prev,r))==2): #不走回头路 continue h_n=state[2]-MDT[tx*N+ty][state[0][tx*N+ty]-1] h_n+=MDT[sx*N+sy][state[0][tx*N+ty]-1] #计算移动数字后的状态的h(n) successor.append((h_n,r)) #插入后继数组sorted(successor,key=lambda x:(x[0],x[1])) #对后继数组进行排序，h(n)较小的优先访问successor.reverse() 访问节点： 样例1 样例2 样例3 样例4 有排序 18651 12201 4315 158044 无排序 18514 6087 6498 43405 运行耗时： 样例1 样例2 样例3 样例4 有排序 0.5s 0.3s 0.1s 4s 无排序 0.68s 0.285s 0.29s 1.7s 可以看到对邻接状态的最小估价进行排序，并没有实质上减少状态节点的访问。对于样例3有明显的改进，但是对于样例4反而增加了访问的状态节点数，增加了运算时间。 三、实验结果及分析 1.实验结果展示实例 A* 实验结果 期望结果 IDA* 实验结果 期望结果 2.评测指标展示及分析 A*与IDA*算法性能分析 A*算法采取的是广度优先搜索的策略，但是在运算过程中，我们引入启发函数，使得在广度搜索的时候是有意识的优先拓展最小代价比较小的部分，有一定前进的方向，但是目标仍然不明确。虽然该算法是有提示的搜素，但是可以发现该算法所用的时间复杂度较大，因为该算法需要使用大量的空间存储以及探索过的状态节点，以防止重复探索 IDA*算法采用的是迭代深度优先搜索的策略，搜索过程中会采用估价函数，通过剪枝减少不必要的搜索。该算法通过更新阈值来不断迭代深度搜索。由于使用了回溯的方法，所以在回溯过程中不必保存中间状态，大大节省空间。然而在每次回溯过程中，需要从头搜索，由此，该算法的时间复杂性较大 由于A*算法与IDA*算法所写的代码不能够完全一致，所以在理论上与实践中运行程序所用的时间存在一定的差距，我们通过比较两个算法访问状态节点的数目，比较两个算法的时间复杂度。 样例1 样例2 样例3 样例4 A* 3180 5649 3871 28017 IDA* 18651 12201 4315 158044 可以看到IDA*相较于A*算法，访问节点的数目上较多，所以该算法的时间复杂度理论上要大。 **为什么实验结果表明A*算法所用的时间会比IDA*的算法所用时长？** 样例1 样例2 样例3 样例4 A* 5s 9s 6s 47s IDA 0.5s 0.3s 0.1s 4s 原因是 A*算法在调用函数时创建大量的空间，创建空间所用的时间已经远大于算法真正所需要的时间。 另一方面，A*算法在保存状态时在5处使用了copy.deepcopy()函数，相较于没有使用该函数的IDA*时间性能较差，事实上，IDA*是优化后的版本，将copy.deepcopy（）函数替换为赋值语句，大大提高了计算性能。 启发式函数性能分析 在极端情况下,如果h(n)=0,那么只有g(n)实际上是有用的,这时A*算法也就是迪杰斯特拉算法,它能保证一定可以找到一条最优路径. 如果h(n)总是小于(或者等于)从结点n走到目标结点的步数,那么A算法是一定可以找到最优路径的.h(n)越小,A扩展的结点越多,导致A*算法越慢. 如果h(n)恰好等于从结点n走到目标结点的步数,A算法扩展的所有结点都在最优路径上,它不会扩展任何其他无关结点,此时A算法的速度是非常快的.尽管你无法总是做到这一点,但在某些特定情况下你确实做到.知道A*算法可以在某些时候运行的很好是一件很值得高兴的事. 如果h(n)所给出的信息有时大于从结点n走到目标结点的步数,那么A*算法将无法确保能够找到最优路径,但它会运行得更快. 在另一种极端的情况下,如果h(n)非常接近于g(n),那么只有h(n)将起作用,此时A*算法实际上变成宽度优先搜索. 当h(n)尽量接近h*(n)时算法是较为优秀的 曼哈顿距离的启发函数以及算是一个优秀的启发式函数了 环检测，剪枝性能分析 对IDA*做出改进 无环检测 有环检测 样例1 样例2 样例3 样例4 有环检测剪枝 18651 12201 4315 158044 无环检测剪枝 21985 15389 4414 261175 仅对IDA*做出改进，可以看到加入环检测（判重）剪枝后，探索的状态节点有所减少，样例四为例，探访的状态节点少了五分之二 c++与python 性能分析 在用python写这两份算法之前，先用c++编写了这两个算法，用c++写程序相较于python性能也有很大的提升 使用C++运行IDA*算法代码 运行ppt上的代码（最初四个样例） 样例1： image-20220316154305038 样例2： image-20220316154108436 样例3： image-20220316154329768 样例4： image-20220316154346252 由于python运行时间较长 此处只对ppt样例4和ppt样例2进行演示： 样例2 image-20220316202125114 image-20220316202134604 样例4 image-20220316154646873 image-20220316154531485 可以看到仅仅是样例4，用python版本的IDA*算法也跑了220s左右而样例2也跑了393s ppt样例1 ppt样例2 ppt样例3 ppt样例4 c++版IDA* 100s 0.4s 152s 2.2s python版IDA* —— 393s —— 220s 原因： c++和python代码都会转变成CPU指令，然而python转换出来的cpu指令会比较多。 c++是编译型语言，需要通过预处理，编译，链接之后才会生成可执行文件 python是解释型语言，需要把源代码转换成字节码文件，再由python虚拟机一条条执行字节码指令，需要经过解释器这个过程 四、思考题 如果用列表作为字典的键，会发生什么现象？用元组呢？ 字典用法解释： 键必须是可哈希的，大多数Python对象可以作为键，但它们必须是可哈希的对象。像列表和字典这样的可变类型，由于它们不是可哈希的，所以不能作为键。 所有不可变的类型都是可哈希的，因此它们都可以做为字典的键。 数字和字符串可以被用做字典的键，元组是不可变的但也可能不是一成不变的，因此用元组做有效的键必须要加限制：若元组中只包括像数字和字符串这样的不可变参数，才可以作为字典中有效的键。 为什么键必须是可哈希的？ 解释器调用哈希函数，根据字典中键的值来计算存储你的数据的位置。如果键是可变对象，它的值可改变。如果键发生变化，哈希函数会映射到不同的地址来存储数据。如果这样的情况发生，哈希函数就不可能可靠地存储或获取相关的数据。选择可哈希的键的原因就是因为它们的值不能改变。 image-20220316233121076 字典中的键为list是可变的，不可哈希，报错 image-20220316233130209 字典中的键是元组，不可变，可哈希，程序正常运行 image-20220316233137776 字典中的键是元组，但是元组中含有list类型元素，导致元组可变，不可哈希，程序报错 在本课件第 2 章和第 4 章提到的数据类型中，哪些是可变数据类型， 哪些是不可变数据类型？试结合代码分析。 可变 /不可变 数据类型：变量值发生改变时，变量的内存地址 不变/改变 。 • 提示：① 你可能会用到 id() 函数。② Python 的赋值运算符（ （=）是引用传递。） 数字是不可变数据类型 image-20220316233922159 image-20220316233926553 每一个数字都由一片地址空间进行存储，=只是引用传递，本质上还是对同一片空间进行访问 列表是可变数据类型 image-20220316233936044 更改列表里面的元素，地址没有发生改变 元组是不可变数据类型 image-20220316233950944 image-20220316234726505 对元组内元素发生更改，会报错 字符串是不可变数据类型 image-20220316233941648 对字符串本身发生更改，地址会发生改变，追加元素，对原来字符串并没有发生更改 字典是可变数据类型 image-20220316234005372 更改字典里面的元素，地址没有发生改变 集合是不可变数据类型 image-20220316234316013 集合中有可变数据类型，会报错 image-20220316234022985 修改集合后，地址未发生更改，但是集合原本的元素并没有发生更改 五、参考资料 https://blog.csdn.net/free4wuyou/article/details/15676597?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164733496816781685340998%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=164733496816781685340998&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2allfirst_rank_ecpm_v1~rank_v31_ecpm-5-15676597.142 https://blog.csdn.net/qq_40998706/article/details/87828065?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164741396216780271553315%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=164741396216780271553315&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2allfirst_rank_ecpm_v1~rank_v31_ecpm-1-87828065.142 https://blog.csdn.net/stl112514/article/details/37689823?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164744586416780271921157%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=164744586416780271921157&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2allfirst_rank_ecpm_v1~rank_v31_ecpm-1-37689823.142","categories":[],"tags":[{"name":"A*","slug":"A","permalink":"https://klc1006.github.io/tags/A/"},{"name":"IDA*","slug":"IDA","permalink":"https://klc1006.github.io/tags/IDA/"}]},{"title":"【AI Course】一致代价实现最短路径","slug":"AI course 1_20337013","date":"2022-03-01T16:00:00.000Z","updated":"2023-03-08T16:59:19.670Z","comments":true,"path":"2022/03/02/AI course 1_20337013/","link":"","permalink":"https://klc1006.github.io/2022/03/02/AI%20course%201_20337013/","excerpt":"AI course LabsWeek2 一、实验目的 一致代价搜索（带环检测）实现最小代价路径查找","text":"AI course LabsWeek2 一、实验目的 一致代价搜索（带环检测）实现最小代价路径查找 image-20220302092206013 image-20220302092250062 二、实验原理 ​ 一致代价搜索是在广度优先搜索上进行扩展的，也被成为代价一致搜索，他的基本原理是：一致代价搜索总是扩展路径消耗最小的节点N。N点的路径消耗等于前一节点N-1的路径消耗加上N-1到N节点的路径消耗。 ​ 图的一致性代价搜索使用了优先级队列并在边缘中的状态发现更小代价的路径时引入的额外的检查。边缘的数据结构需要支持有效的成员校测，这样它就结合了优先级队列和哈希表的能力。 流程分析： 1.如果边缘为空，则返回失败。操作：EMPTY?(frontier) 2.否则从边缘中选择一个叶子节点。操作：POP(frontier) 3.目标测试：通过返回，否则将叶子节点的状态放在探索集 4.遍历叶子节点的所有动作 每个动作产生子节点 如果子节点的状态不在探索集或者边缘，则插入到边缘集合。操作：INSERT(child, frontier) 否则如果边缘集合中如果存在此状态且有更高的路径消耗，则用子节点替代边缘集合中的状态 三、实验过程 关键代码 数据输入： 123456789101112131415161718192021222324252627def create_adjList(edgeSet): #建立邻接表 temp=input().split() #输入地图的顶点个数和边的个数 v=int(temp[0]) #将以串类型输入顶点个数强制类型转换为int类型数据 e=int(temp[1]) #将以串类型输入边的个数强制类型转换为int类型数据 for i in range(e): #遍历每一条边 edge=input().split() #定义edge成分为（edge[0]前驱/后继，edge[1]后继/前驱，edge[2]代价） edge[2]=int(edge[2]) #将以串类型输入边的权重强制类型转换为int类型数据 if edge[0] in edgeSet : edgeSet[edge[0]].append((edge[1],edge[2])) #如果已对该顶点建立邻接表信息，在其后面追加与其他顶点建立邻接关系的信息 else: edgeSet[edge[0]]=[(edge[1],edge[2])] #如果未对该顶点建立邻接表信息，新定义该顶点的邻接关系 if edge[1] in edgeSet: #默认建立的是无向图，需要对后继顶点做上述同样的操作，从而建立双向的邻接表 edgeSet[edge[1]].append((edge[0],edge[2])) #如果已对该顶点建立邻接表信息，在其后面追加与其他顶点建立邻接关系的信息 else: edgeSet[edge[1]]=[(edge[0],edge[2])] #如果未对该顶点建立邻接表信息，新定义该顶点的邻接关系 路径查找： 1234567891011121314151617181920212223242526272829303132def find_path(start,end,visit,path): #采用一致代价搜索以及环检测查找最短路径 q=PriorityQueue() #使用优先队列，每一次取积累代价最小的顶点做拓展，从而遍历顶点，直到寻找到目标定点 q.put((0,start,&#x27;0&#x27;)) #队列中元素的组成为（[0]积累代价，[1]当前出队顶点，[2]出队顶点的前驱） PS:&#x27;0&#x27; 用于标记起始点，方便后续遍历输出路径 print(&quot;出队遍历顺序：&quot;,end=&quot;&quot;) while(not q.empty()): #跳出循环的条件：优先队列非空。若优先队列已空，则起始点所处的连通分量里面的所有顶点遍历完毕 temp=q.get() print(temp[1],end=&quot;→&quot;) if visit.count(temp[1])!=0: continue #已经出过队的顶点相当于已经找到起点到该顶点的最小值，不再加入path else: #将最小代价顶点出队，temp成分为（temp[0]积累代价，temp[1]当前出队顶点，temp[2]出队顶点的前驱） path[temp[1]]=temp[2] #保存出队顶点的的前驱，以便查找成功在输出路径，path成份（path[0]出队顶点，path[1]出队顶点的前驱） visit.append(temp[1]) #保存出队结点，用于环检测 if temp[1]==end: minCost=temp[0] #找到目标节点后，保存最小代价并返回 return minCost else: for edge in edgeSet[temp[1]]: #遍历出队顶点的邻接顶点 if visit.count(edge[0])==0: q.put((temp[0]+edge[1],edge[0],temp[1])) #如果邻接顶点没有被探索过，按（积累代价，当前出队顶点，出队顶点的前驱）结构入队 return -1 #如果没有查找成功，返回-1 实现功能 1.查找起点到终点的最小代价路径 2.判断输入的起点终点是否在讨论顶点范围内 3.判断输入的起点终点是否在同一连通分量当中 四、实验结果 case1 image-20220302150653541 分析解释： 一致代价搜索（带环检测），若出队元素已经加入过进path里面，不在对其延拓，且不再加入path数组 图中出队遍历顺序包含不加入path数组的顶点元素 由a→z的代价最小路径为a→b→e→d→z，最小代价为7 case2 image-20220302092735025 case3 image-20220302092756474 case4 image-20220302092551253 case5（查找失败） image-20220302092825714 分析解释： 遍历完a顶点所处连通分量的其余顶点后，没有发现e顶点，输出查找失败fail case6（查找失败） image-20220302093117532 分析解释： 遍历完a顶点所处连通分量的其余顶点后，没有发现e顶点，输出查找失败fail case7（查找失败） image-20220302153710558 分析解释： 发现f顶点并没有在集合edgeSet当中，即讨论的地图不包括f顶点输出查找失败fail","categories":[],"tags":[{"name":"AI","slug":"AI","permalink":"https://klc1006.github.io/tags/AI/"},{"name":"最短路径","slug":"最短路径","permalink":"https://klc1006.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"}]},{"title":"【计组实验】单周期CPU","slug":"【计组实验】单周期CPU","date":"2021-11-14T16:00:00.000Z","updated":"2023-03-13T06:57:10.050Z","comments":true,"path":"2021/11/15/【计组实验】单周期CPU/","link":"","permalink":"https://klc1006.github.io/2021/11/15/%E3%80%90%E8%AE%A1%E7%BB%84%E5%AE%9E%E9%AA%8C%E3%80%91%E5%8D%95%E5%91%A8%E6%9C%9FCPU/","excerpt":"","text":"12345678910111213141516171819module PC( input CLK, input Reset, input PCWre, input[31:0] newAddress, output reg[31:0] PCAddr); initial begin PCAddr=0; end always@(posedge CLK or negedge Reset)begin if(Reset==0)begin PCAddr=0; end else if(PCWre)begin PCAddr=newAddress; end endendmodule 123456789101112131415161718192021222324252627282930313233`timescale 1ns / 1psmodule ALU( input[31:0] A, //输入A input[31:0] B, //输入B input[2:0] ALUOp, //ALU操作控制 output reg[31:0] result, //ALU运算结果 output zero,//运算结果result的标志，result为0输出1，否则输出0 output sign //运算结果result的正负性（有符号数的情况），result为负数输出1，否则输出0); parameter _ADD= 3&#x27;b000; parameter _SUB= 3&#x27;b001; parameter _SLL= 3&#x27;b010; parameter _OR=3&#x27;b011; parameter _AND= 3&#x27;b100; parameter _SLTU= 3&#x27;b101; parameter _SLT= 3&#x27;b110; parameter _XOR= 3&#x27;b111; assign zero= result==0; assign sign= result[31]; always@(*)begin//进行ALU计算 case(ALUOp) //进行运算 _ADD: result= A+B; //加法 _SUB: result= A-B; //减法 _SLL: result= B&lt;&lt;A; //B左移A位 _OR: result= A|B; //或 _AND: result= A&amp;B; //与 _SLTU: result= A&lt;B; //比较A&lt;B不带符号 _SLT: result= A[31]!=B[31]?A[31]&gt;B[31]:A&lt;B; //比较A&lt;B带符号 _XOR: result= A^B; //异或 default: result= 0; endcase endendmodule 123456789101112131415161718192021222324252627`timescale 1ns / 1psmodule DataMemory( input[31:0] DAddr, input CLK, input mRD, input mWR, input[31:0] DataIn, output reg[31:0] DataOut); reg[7:0] dataMemory [255:0]; always@(mRD or DAddr)begin if(mRD)begin DataOut[7:0]= dataMemory[DAddr+3]; DataOut[15:8]= dataMemory[DAddr+2]; DataOut[23:16]= dataMemory[DAddr+1]; DataOut[31:24]= dataMemory[DAddr]; end end always@(negedge CLK)begin //总是在时钟下降沿到来时触发 if(mWR)begin dataMemory[DAddr+3]&lt;= DataIn[7:0]; dataMemory[DAddr+2]&lt;= DataIn[15:8]; dataMemory[DAddr+1]&lt;= DataIn[23:16]; dataMemory[DAddr]&lt;= DataIn[31:24]; end endendmodule 1234567module SignZeroExtend( input[15:0] immediate, input ExtSel, output[31:0] extendImmediate); assign extendImmediate= &#123;ExtSel&amp;&amp;immediate[15]?16&#x27;hffff:16&#x27;h0000,immediate&#125;;endmodule 12345678module Multiplexer5( input Select, input[4:0] DataIn1, input[4:0] DataIn2, output[4:0] DataOut); assign DataOut= Select?DataIn2:DataIn1;endmodule 12345678module Multiplexer32( input Select, input[31:0] DataIn1, input[31:0] DataIn2, output[31:0] DataOut); assign DataOut= Select?DataIn2:DataIn1;endmodule 12345678910module multiplexer32_4( input [1:0]select, input [31:0]In00, input [31:0]In01, input [31:0]In10, input [31:0]In11, output [31:0]Out); assign Out= select[0]?(select[1]?In11:In01):(select[1]?In10:In00);endmodule 1234567891011121314151617181920212223module RegisterFile( input WE, input CLK, input[4:0] ReadReg1, input[4:0] ReadReg2, input[4:0] WriteReg, input[31:0] WriteData, output[31:0] ReadData1, output[31:0] ReadData2); reg[31:0] registers[0:31]; integer i; initial begin //初始时，将32个寄存器全部赋值为0 for(i=0; i&lt;32; i=i+1)registers[i]&lt;= 0; end assign ReadData1= ReadReg1?registers[ReadReg1]:0; assign ReadData2= ReadReg2?registers[ReadReg2]:0; always@(negedge CLK)begin if(WriteReg&amp;&amp;WE)begin registers[WriteReg]= WriteData; end endendmodule 12345678910111213141516171819`timescale 1ns / 1psmodule InstructionMemory( input[31:0] IAddr, input RW, output reg[31:0] IDataOut); reg[7:0] InstMemory[83:0]; initial begin //此处为绝对地址，注意斜杠方向 $readmemb(&quot;D:/CPU/SingleCPU_1/SingleCPU_1/input.txt&quot;,InstMemory); end always@(IAddr or RW)begin if(RW==0)begin IDataOut= &#123;InstMemory[IAddr],InstMemory[IAddr+1],InstMemory[IAddr+2],InstMemory[I Addr+3]&#125;; end endendmodule 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061`timescale 1ns / 1psmodule ControlUnit(output ExtSel,output PCWre,output InsMemRW,output RegDst,output RegWre,output[2:0] ALUOp,output[1:0] PCSrc,output ALUSrcA,output ALUSrcB,output mRD,output mWR,output DBDataSrc,input[5:0] op,input [5:0]func,input zero,input sign);parameter ADD= 6&#x27;b100000;parameter SUB= 6&#x27;b100010;parameter ADDIU= 6&#x27;b001001;parameter ANDI= 6&#x27;b001100;parameter AND= 6&#x27;b100100;parameter ORI= 6&#x27;b001101;parameter OR= 6&#x27;b100101;parameter SLL= 6&#x27;b000000;parameter SLTI= 6&#x27;b001010;parameter SW= 6&#x27;b101011;parameter LW= 6&#x27;b100011;parameter BEQ= 6&#x27;b000100;parameter BNE= 6&#x27;b000101;parameter BLTZ= 6&#x27;b000001;parameter J= 6&#x27;b000010;parameter HALT= 6&#x27;b111111;parameter _ADD= 3&#x27;b000;parameter _SUB= 3&#x27;b001;parameter _SLL= 3&#x27;b010;parameter _OR= 3&#x27;b011;parameter _AND= 3&#x27;b100;parameter _SLTU= 3&#x27;b101;parameter _SLT= 3&#x27;b110;parameter _XOR= 3&#x27;b111;assign PCWre= op!=HALT;assign ALUSrcA= op==0&amp;&amp;func==SLL;assign ALUSrcB= op==ADDIU||op==ANDI || op==ORI||op==SLTI||op==SW||op==LW;assign DBDataSrc= op==LW;assign RegWre= op!=BEQ&amp;&amp;op!=BNE&amp;&amp;op!=BLTZ&amp;&amp;op!=SW&amp;&amp;op!=HALT;assign InsMemRW= 0;assign mRD= op==LW;assign mWR= op==SW;assign RegDst= op!=ADDIU&amp;&amp;op!=ANDI&amp;&amp;op!=ORI&amp;&amp;op!=SLTI&amp;&amp;op!=LW;assign ExtSel= op!=ANDI&amp;&amp;op!=ORI;assign PCSrc[1]= op==J;assign PCSrc[0]= op==BEQ&amp;&amp;zero==1||op==BNE&amp;&amp;zero==0||op==BLTZ&amp;&amp;sign==1;assign ALUOp= op==0&amp;&amp;func==SUB||op==BNE||op==BEQ||op==BLTZ?_SUB:op==0&amp;&amp;func==SLL?_SLL:op==ORI||op==0&amp;&amp;func==OR?_OR:op==ANDI||op==0&amp;&amp;func==AND?_AND:op==SLTI?_SLT:_ADD;endmodule 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354module SingleCPU( input CLK, //时钟信号 input Reset, //置零信号 output[31:0] CurPC, //当前指令地址 output[31:0] newaddress, //下一个指令地址 output[31:0] instcode, //rs,rt寄存器所在指令 output[31:0] Reg1Out, //寄存器组rs寄存器的值 output[31:0] Reg2Out, //寄存器组rt寄存器的值 output[31:0] ALU_Out, //ALU的result输出值 output[31:0] WriteData //DB总线值); wire ExtSel; //位扩展信号，1为符号扩展，0为0扩展 wire PCWre; //PC工作信号，0不更改，1更改 wire InsMemRW; //指令寄存器信号，0为写，1为读 wire RegDst; //指令读取时判断是rt还是rd进入寄存器组的写数据端，0为rt，1为rd wire RegWre; //寄存器组是否需要写功能，0为无写功能，1为些功能 wire[2:0] ALUOp; //ALU8种运算功能选择 wire[1:0] PCSrc; //PC正常+4还是要跳转，0为正常+4，1为跳转 wire ALUSrcA; //寄存器组Data1的输出，0为寄存器本身输出，1为指令码的最后16 位立即数 wire ALUSrcB; //寄存器组Data2的输出，0位本身的输出，1为扩展后的立即数 wire RD; //读数据存储器功能，0时读取 wire WR;//写数据存储器功能，1时写 wire DBDataSrc; //决定将什么数据传入寄存器组Write Data端，0为ALU结果，1为存 储器 wire[4:0] WriteRegAddr; //寄存器组Write Reg输入端 wire[31:0] ALU_Input_A; //ALU的A输入端 wire[31:0] ALU_Input_B; //ALU的B输入端 wire zero; //ALU的zero输出 wire sign;//ALU的sign输出 wire[31:0] MemOut; //存储器的输出 wire[31:0] Ext_Imm; //位扩展后的立即数 wire[31:0] CurPC4=CurPC+4; multiplexer32_4 mux41PC(PCSrc,CurPC4,CurPC4+(Ext_Imm&lt;&lt;2),&#123;CurPC4[31:28],instcode[25:0],2&#x27;b00&#125;,0,newa ddress); PC pc(CLK,Reset,PCWre,newaddress,CurPC); ALU alu(ALU_Input_A,ALU_Input_B,ALUOp,ALU_Out,zero,sign); DataMemory dm(ALU_Out,CLK,RD,WR,Reg2Out,MemOut); SignZeroExtend sze(instcode[15:0],ExtSel,Ext_Imm); Multiplexer5 mux21R(RegDst,instcode[20:16],instcode[15:11],WriteRegAddr); Multiplexer32 mux21A(ALUSrcA,Reg1Out,&#123;27&#x27;b000000000000000000000000000,instcode[10:6]&#125;,ALU_Input _A); Multiplexer32 mux21B(ALUSrcB,Reg2Out,Ext_Imm,ALU_Input_B); Multiplexer32 mux21RW(DBDataSrc,ALU_Out,MemOut,WriteData); RegisterFile rf(RegWre,CLK,instcode[25:21],instcode[20:16],WriteRegAddr,WriteData,Reg1Out,Reg2Out); ControlUnit cu(ExtSel,PCWre,InsMemRW,RegDst,RegWre,ALUOp,PCSrc,ALUSrcA,ALUSrcB,RD,WR,DB DataSrc,instcode[31:26],instcode[5:0],zero,sign); InstructionMemory im(CurPC,InsMemRW,instcode);endmodule 1234567891011121314151617`timescale 1ns / 1psmodule SingleCPU_sim; reg CLK; //时钟信号 reg Reset; //置零信号 SingleCPU scpu(CLK,Reset); initial begin CLK= 0; Reset= 0; //刚开始设置pc为0 #50; //等待Reset完成 CLK= !CLK; //下降沿，使PC先清零 #50; Reset= 1; //清除保持信号 forever #50 begin //产生时钟信号，周期为50s CLK= !CLK; end endendmodule 第三部分还包括烧板实现代码，这里不再一一描述了，上述项目可以完成一个单周期CPU的仿真实验，并且观察各个寄存器的波形图。 最后贴上我的实验心得~ 遗憾的是，这么课没有给我带来较高的绩点，原因是答辩过程中有个寄存器出现了错误，这也是我粗心所致。不过由于这次错误，我又复盘了一次CPU原理，总的来说收获很多！！！","categories":[],"tags":[{"name":"CPU","slug":"CPU","permalink":"https://klc1006.github.io/tags/CPU/"}]}],"categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://klc1006.github.io/tags/leetcode/"},{"name":"cpp","slug":"cpp","permalink":"https://klc1006.github.io/tags/cpp/"},{"name":"PDDL","slug":"PDDL","permalink":"https://klc1006.github.io/tags/PDDL/"},{"name":"规划问题","slug":"规划问题","permalink":"https://klc1006.github.io/tags/%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98/"},{"name":"KNN","slug":"KNN","permalink":"https://klc1006.github.io/tags/KNN/"},{"name":"分类","slug":"分类","permalink":"https://klc1006.github.io/tags/%E5%88%86%E7%B1%BB/"},{"name":"朴素贝叶斯","slug":"朴素贝叶斯","permalink":"https://klc1006.github.io/tags/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/"},{"name":"归结推理","slug":"归结推理","permalink":"https://klc1006.github.io/tags/%E5%BD%92%E7%BB%93%E6%8E%A8%E7%90%86/"},{"name":"A*","slug":"A","permalink":"https://klc1006.github.io/tags/A/"},{"name":"IDA*","slug":"IDA","permalink":"https://klc1006.github.io/tags/IDA/"},{"name":"AI","slug":"AI","permalink":"https://klc1006.github.io/tags/AI/"},{"name":"最短路径","slug":"最短路径","permalink":"https://klc1006.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"},{"name":"CPU","slug":"CPU","permalink":"https://klc1006.github.io/tags/CPU/"}]}